// C√≥digo compilado del proyecto: diegopapic/cinenacional
// Commit: ce7ea7c6121d78676b47768828180caa1b5c4145
// Fecha: 2026-01-21T17:43:34.841Z
// ============================================



// ==================================================
// next-env.d.ts
// ==================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


// ==================================================
// scripts/create-admin.ts
// ==================================================
// scripts/create-admin.ts

import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'
import { config } from 'dotenv'
import path from 'path'

config()

const prisma = new PrismaClient()

// Cargar .env.local espec√≠ficamente
config({ path: path.resolve(process.cwd(), '.env.local') })

async function createAdmin() {
  const email = process.env.ADMIN_EMAIL || 'admin@cinenacional.com'
  const password = process.env.ADMIN_PASSWORD || 'ChangeMeNow2024!'
  const username = process.env.ADMIN_USERNAME || 'admin'
  
  try {
    const hashedPassword = await bcrypt.hash(password, 12)
    
    const user = await prisma.user.upsert({
      where: { email },
      update: {
        password: hashedPassword,
        role: 'ADMIN',
        isAdmin: true,  // Por compatibilidad
        isActive: true
      },
      create: {
        email,
        username,
        password: hashedPassword,
        displayName: 'Administrador',
        role: 'ADMIN',
        isAdmin: true,  // Por compatibilidad
        isActive: true
      }
    })
    
    console.log('‚úÖ Usuario admin creado/actualizado:')
    console.log('üìß Email:', user.email)
    console.log('üë§ Username:', user.username || 'N/A')
    console.log('üîë Password temporal:', password)
    console.log('\n‚ö†Ô∏è  IMPORTANTE: Cambia la contrase√±a despu√©s del primer login')
    
    // Crear log de auditor√≠a
    await prisma.auditLog.create({
      data: {
        userId: user.id,
        action: 'ADMIN_CREATED',
        entity: 'user',
        entityId: user.id,
        metadata: {
          createdBy: 'script',
          timestamp: new Date().toISOString()
        }
      }
    })
    
  } catch (error) {
    console.error('Error creando admin:', error)
  } finally {
    await prisma.$disconnect()
  }
}

createAdmin()

// ==================================================
// scripts/tmdb/apply-high-scores.ts
// ==================================================
/**
 * Script para aplicar matches con score >= 80 desde el CSV
 * 
 * Uso:
 *   npx tsx apply-high-scores.ts --dry-run     # Solo muestra qu√© har√≠a
 *   npx tsx apply-high-scores.ts --apply       # Aplica los cambios
 */

import * as fs from 'fs';
import * as path from 'path';
import { Pool } from 'pg';

// Configuraci√≥n de conexi√≥n (ajustar seg√∫n tu entorno)
const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5433'),
  database: process.env.DB_NAME || 'cinenacional',
  user: process.env.DB_USER || 'cinenacional',
  password: process.env.DB_PASSWORD || 'Paganitzu',
});

const MIN_SCORE = 80;

interface MatchRow {
  local_id: number;
  local_title: string;
  tmdb_id: number | null;
  tmdb_title: string | null;
  match_score: number;
  match_status: string;
  match_reason: string;
}

function parseCSV(filePath: string): MatchRow[] {
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n').filter(line => line.trim());
  
  // Detectar separador (puede ser ; o ,)
  const separator = lines[0].includes(';') ? ';' : ',';
  
  // Parsear header
  const headers = lines[0].replace(/^\uFEFF/, '').split(separator);
  
  const rows: MatchRow[] = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(separator);
    
    // Mapear valores a objeto
    const row: any = {};
    headers.forEach((header, idx) => {
      let value = values[idx]?.replace(/^"|"$/g, '').trim();
      row[header.trim()] = value;
    });
    
    // Convertir tipos
    const matchRow: MatchRow = {
      local_id: parseInt(row.local_id) || 0,
      local_title: row.local_title || '',
      tmdb_id: row.tmdb_id ? parseInt(row.tmdb_id) : null,
      tmdb_title: row.tmdb_title || null,
      match_score: parseInt(row.match_score) || 0,
      // El CSV tiene "auto_accept" como nombre de columna para el status
      match_status: row.auto_accept || row.match_status || 'no_match',
      match_reason: row.match_reason || '',
    };
    
    if (matchRow.local_id > 0) {
      rows.push(matchRow);
    }
  }
  
  return rows;
}

async function main() {
  const args = process.argv.slice(2);
  const isDryRun = !args.includes('--apply');
  const csvPath = args.find(a => a.endsWith('.csv')) || 'movies-matches-20260120T011323.csv';
  
  console.log('\nüé¨ Aplicar matches con score >= ' + MIN_SCORE);
  console.log('=' .repeat(50) + '\n');
  
  // Buscar el archivo CSV
  let fullPath = csvPath;
  if (!fs.existsSync(fullPath)) {
    // Buscar en directorio actual y com√∫n
    const possiblePaths = [
      csvPath,
      path.join(process.cwd(), csvPath),
      path.join(process.cwd(), 'reports', csvPath),
      path.join(process.cwd(), 'scripts', 'reports', csvPath),
      path.join(process.cwd(), '..', 'reports', csvPath),
    ];
    
    for (const p of possiblePaths) {
      if (fs.existsSync(p)) {
        fullPath = p;
        break;
      }
    }
  }
  
  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå No se encontr√≥ el archivo: ${csvPath}`);
    process.exit(1);
  }
  
  console.log(`üìÑ Leyendo: ${fullPath}`);
  const rows = parseCSV(fullPath);
  console.log(`   Total registros: ${rows.length}`);
  
  // Filtrar los que tienen score >= MIN_SCORE y tmdb_id v√°lido
  const toApply = rows.filter(r => 
    r.match_score >= MIN_SCORE && 
    r.tmdb_id && 
    r.tmdb_id > 0
  );
  
  // Separar los que ya fueron aplicados (auto_accept) de los nuevos
  const alreadyApplied = toApply.filter(r => r.match_status === 'auto_accept');
  const newToApply = toApply.filter(r => r.match_status !== 'auto_accept');
  
  console.log(`\nüìä Estad√≠sticas:`);
  console.log(`   Score >= ${MIN_SCORE} con TMDB ID: ${toApply.length}`);
  console.log(`   Ya aplicados (auto_accept):    ${alreadyApplied.length}`);
  console.log(`   Nuevos a aplicar:              ${newToApply.length}`);
  
  // Mostrar distribuci√≥n por score
  const byScore: Record<number, number> = {};
  newToApply.forEach(r => {
    const scoreRange = Math.floor(r.match_score / 10) * 10;
    byScore[scoreRange] = (byScore[scoreRange] || 0) + 1;
  });
  
  console.log(`\n   Distribuci√≥n de nuevos por score:`);
  Object.keys(byScore).sort((a, b) => parseInt(b) - parseInt(a)).forEach(score => {
    console.log(`     ${score}-${parseInt(score) + 9}: ${byScore[parseInt(score)]} pel√≠culas`);
  });
  
  if (newToApply.length === 0) {
    console.log('\n‚úÖ No hay nuevos matches para aplicar.');
    await pool.end();
    return;
  }
  
  // Mostrar algunos ejemplos
  console.log(`\nüìù Ejemplos de lo que se aplicar√°:`);
  newToApply.slice(0, 10).forEach(r => {
    console.log(`   [${r.match_score}] "${r.local_title}" ‚Üí TMDB ${r.tmdb_id} "${r.tmdb_title}"`);
  });
  if (newToApply.length > 10) {
    console.log(`   ... y ${newToApply.length - 10} m√°s`);
  }
  
  if (isDryRun) {
    console.log('\nüí° Modo DRY-RUN: No se aplicaron cambios.');
    console.log('   Para aplicar: npx tsx apply-high-scores.ts --apply');
    await pool.end();
    return;
  }
  
  // Aplicar cambios
  console.log(`\nüîÑ Aplicando ${newToApply.length} cambios a la base de datos...`);
  
  let updated = 0;
  let errors = 0;
  
  for (const match of newToApply) {
    try {
      const result = await pool.query(
        'UPDATE movies SET tmdb_id = $1 WHERE id = $2 AND (tmdb_id IS NULL OR tmdb_id = 0)',
        [match.tmdb_id, match.local_id]
      );
      
      if (result.rowCount && result.rowCount > 0) {
        updated++;
      }
    } catch (error) {
      console.error(`   ‚ùå Error en pel√≠cula ${match.local_id}: ${error}`);
      errors++;
    }
    
    // Mostrar progreso cada 100
    if ((updated + errors) % 100 === 0) {
      process.stdout.write(`\r   Procesadas: ${updated + errors}/${newToApply.length}`);
    }
  }
  
  console.log(`\n\n‚úÖ Resultado:`);
  console.log(`   Actualizadas: ${updated}`);
  console.log(`   Errores:      ${errors}`);
  console.log(`   Sin cambio:   ${newToApply.length - updated - errors} (ya ten√≠an tmdb_id)`);
  
  await pool.end();
  console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
  console.error('Error fatal:', error);
  process.exit(1);
});

// ==================================================
// scripts/tmdb/discover-argentina.ts
// ==================================================
/**
 * Script para descubrir pel√≠culas argentinas en TMDB que no est√°n en CineNacional
 * 
 * Uso:
 *   npx tsx discover-argentina.ts                # Genera reporte completo
 *   npx tsx discover-argentina.ts --year 2024   # Solo pel√≠culas de un a√±o
 *   npx tsx discover-argentina.ts --from 2020   # Desde un a√±o en adelante
 */

import { getMovieDetails, testConnection } from './tmdb-client';
import { 
  getPool, 
  closePool, 
  normalizeText,
  stringSimilarity,
  saveToCSV, 
  formatDuration,
  progressBar,
  log 
} from './utils';
import config from './config';

const TMDB_BASE_URL = 'https://api.themoviedb.org/3';

interface TMDBDiscoverMovie {
  id: number;
  title: string;
  original_title: string;
  release_date: string;
  overview: string;
  popularity: number;
  vote_average: number;
  vote_count: number;
}

interface DiscoverResult {
  page: number;
  results: TMDBDiscoverMovie[];
  total_pages: number;
  total_results: number;
}

interface TMDBReleaseDate {
  certification: string;
  iso_639_1: string;
  note: string;
  release_date: string;
  type: number; // 1=Premiere, 2=Theatrical limited, 3=Theatrical, 4=Digital, 5=Physical, 6=TV
}

interface TMDBReleaseDatesResult {
  iso_3166_1: string;
  release_dates: TMDBReleaseDate[];
}

interface PremiereInfo {
  date: string;
  country: string;
  note: string;
}

/**
 * Obtener informaci√≥n de la primera release de una pel√≠cula
 */
async function getPremiereInfo(tmdbId: number): Promise<PremiereInfo> {
  const url = `${TMDB_BASE_URL}/movie/${tmdbId}/release_dates?api_key=${config.tmdbApiKey}`;
  
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      return { date: '', country: '', note: '' };
    }
    
    const data: { results: TMDBReleaseDatesResult[] } = await response.json();
    
    // Recolectar todas las releases
    const allReleases: Array<{ date: string; country: string; note: string }> = [];
    
    for (const countryResult of data.results) {
      for (const release of countryResult.release_dates) {
        if (release.release_date) {
          allReleases.push({
            date: release.release_date.split('T')[0],
            country: countryResult.iso_3166_1,
            note: release.note || '',
          });
        }
      }
    }
    
    if (allReleases.length === 0) {
      return { date: '', country: '', note: '' };
    }
    
    // Ordenar por fecha
    allReleases.sort((a, b) => a.date.localeCompare(b.date));
    
    // Buscar la primera release con nota
    const firstWithNote = allReleases.find(r => r.note);
    if (firstWithNote) {
      return firstWithNote;
    }
    
    // Si ninguna tiene nota, devolver la primera
    return allReleases[0];
    
  } catch (error) {
    return { date: '', country: '', note: '' };
  }
}

interface MovieComparison {
  tmdb_id: number;
  tmdb_title: string;
  tmdb_original_title: string;
  tmdb_year: number | null;
  tmdb_release_date: string;
  premiere_date: string;
  premiere_country: string;
  premiere_note: string;
  tmdb_overview: string;
  tmdb_popularity: number;
  tmdb_vote_average: number;
  tmdb_vote_count: number;
  status: 'missing' | 'exists_by_tmdb' | 'exists_by_title' | 'possible_match';
  local_id: number | null;
  local_title: string | null;
  local_year: number | null;
  match_reason: string;
}

/**
 * Descubrir pel√≠culas argentinas en TMDB
 */
async function discoverArgentineMovies(year?: number, fromYear?: number): Promise<TMDBDiscoverMovie[]> {
  const allMovies: TMDBDiscoverMovie[] = [];
  let page = 1;
  let totalPages = 1;
  
  log('Descubriendo pel√≠culas argentinas en TMDB...', 'info');
  
  while (page <= totalPages && page <= 500) { // TMDB limita a 500 p√°ginas
    const params = new URLSearchParams({
      api_key: config.tmdbApiKey,
      with_origin_country: 'AR',
      language: 'es-AR',
      sort_by: 'primary_release_date.desc',
      page: page.toString(),
      include_adult: 'true',
      include_video: 'false',
    });
    
    // Filtros de a√±o
    if (year) {
      params.set('primary_release_year', year.toString());
    } else if (fromYear) {
      params.set('primary_release_date.gte', `${fromYear}-01-01`);
    }
    
    const url = `${TMDB_BASE_URL}/discover/movie?${params}`;
    
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`TMDB error: ${response.status}`);
      }
      
      const data: DiscoverResult = await response.json();
      
      if (page === 1) {
        totalPages = Math.min(data.total_pages, 500);
        log(`Total en TMDB: ${data.total_results} pel√≠culas (${totalPages} p√°ginas)`, 'info');
      }
      
      allMovies.push(...data.results);
      
      process.stdout.write(`\r${progressBar(page, totalPages)} - ${allMovies.length} pel√≠culas...`);
      
      page++;
      
      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 250));
      
    } catch (error) {
      log(`Error en p√°gina ${page}: ${error}`, 'error');
      break;
    }
  }
  
  console.log('\n');
  return allMovies;
}

/**
 * Obtener pel√≠culas locales para comparaci√≥n
 */
async function getLocalMovies(): Promise<Map<number, { id: number; title: string; year: number | null; tmdb_id: number | null }>> {
  const pool = getPool();
  
  const result = await pool.query(`
    SELECT id, title, year, tmdb_id
    FROM movies
    ORDER BY year DESC NULLS LAST
  `);
  
  // Crear mapa por tmdb_id para b√∫squeda r√°pida
  const moviesByTmdbId = new Map<number, { id: number; title: string; year: number | null; tmdb_id: number | null }>();
  
  for (const row of result.rows) {
    if (row.tmdb_id) {
      moviesByTmdbId.set(row.tmdb_id, row);
    }
  }
  
  return moviesByTmdbId;
}

/**
 * Obtener todas las pel√≠culas locales para b√∫squeda por t√≠tulo
 */
async function getAllLocalMovies(): Promise<Array<{ id: number; title: string; year: number | null; tmdb_id: number | null }>> {
  const pool = getPool();
  
  const result = await pool.query(`
    SELECT id, title, year, tmdb_id
    FROM movies
    ORDER BY year DESC NULLS LAST
  `);
  
  return result.rows;
}

/**
 * Buscar pel√≠cula local por t√≠tulo y a√±o
 */
function findLocalByTitleYear(
  tmdbTitle: string, 
  tmdbOriginalTitle: string,
  tmdbYear: number | null,
  localMovies: Array<{ id: number; title: string; year: number | null; tmdb_id: number | null }>
): { movie: typeof localMovies[0] | null; similarity: number } {
  
  let bestMatch: typeof localMovies[0] | null = null;
  let bestSimilarity = 0;
  
  for (const local of localMovies) {
    // Comparar t√≠tulos
    const sim1 = stringSimilarity(tmdbTitle, local.title);
    const sim2 = stringSimilarity(tmdbOriginalTitle, local.title);
    const titleSimilarity = Math.max(sim1, sim2);
    
    if (titleSimilarity < 80) continue;
    
    // Verificar a√±o si ambos tienen
    if (tmdbYear && local.year) {
      const yearDiff = Math.abs(tmdbYear - local.year);
      if (yearDiff > 1) continue; // M√°s de 1 a√±o de diferencia, descartar
    }
    
    if (titleSimilarity > bestSimilarity) {
      bestSimilarity = titleSimilarity;
      bestMatch = local;
    }
  }
  
  return { movie: bestMatch, similarity: bestSimilarity };
}

/**
 * Comparar pel√≠culas de TMDB con locales
 */
async function compareMovies(tmdbMovies: TMDBDiscoverMovie[]): Promise<MovieComparison[]> {
  log('Comparando con base de datos local...', 'info');
  
  const localByTmdbId = await getLocalMovies();
  const allLocalMovies = await getAllLocalMovies();
  
  log(`Pel√≠culas locales: ${allLocalMovies.length}`, 'info');
  log(`Pel√≠culas locales con tmdb_id: ${localByTmdbId.size}`, 'info');
  
  const results: MovieComparison[] = [];
  
  for (let i = 0; i < tmdbMovies.length; i++) {
    const tmdb = tmdbMovies[i];
    
    process.stdout.write(`\r${progressBar(i + 1, tmdbMovies.length)} - ${tmdb.title.slice(0, 30)}...`);
    
    const tmdbYear = tmdb.release_date ? parseInt(tmdb.release_date.split('-')[0]) : null;
    
    // Obtener info de premiere
    const premiere = await getPremiereInfo(tmdb.id);
    
    // Rate limiting
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const comparison: MovieComparison = {
      tmdb_id: tmdb.id,
      tmdb_title: tmdb.title,
      tmdb_original_title: tmdb.original_title,
      tmdb_year: tmdbYear,
      tmdb_release_date: tmdb.release_date || '',
      premiere_date: premiere.date,
      premiere_country: premiere.country,
      premiere_note: premiere.note,
      tmdb_overview: tmdb.overview?.slice(0, 200) || '',
      tmdb_popularity: tmdb.popularity,
      tmdb_vote_average: tmdb.vote_average,
      tmdb_vote_count: tmdb.vote_count,
      status: 'missing',
      local_id: null,
      local_title: null,
      local_year: null,
      match_reason: '',
    };
    
    // 1. Buscar por tmdb_id
    const localByTmdb = localByTmdbId.get(tmdb.id);
    if (localByTmdb) {
      comparison.status = 'exists_by_tmdb';
      comparison.local_id = localByTmdb.id;
      comparison.local_title = localByTmdb.title;
      comparison.local_year = localByTmdb.year;
      comparison.match_reason = 'Match por tmdb_id';
      results.push(comparison);
      continue;
    }
    
    // 2. Buscar por t√≠tulo + a√±o
    const { movie: localByTitle, similarity } = findLocalByTitleYear(
      tmdb.title,
      tmdb.original_title,
      tmdbYear,
      allLocalMovies
    );
    
    if (localByTitle) {
      if (similarity >= 95) {
        comparison.status = 'exists_by_title';
        comparison.match_reason = `Match por t√≠tulo (${similarity}%)`;
      } else {
        comparison.status = 'possible_match';
        comparison.match_reason = `Posible match (${similarity}%)`;
      }
      comparison.local_id = localByTitle.id;
      comparison.local_title = localByTitle.title;
      comparison.local_year = localByTitle.year;
    } else {
      comparison.match_reason = 'No encontrada en CineNacional';
    }
    
    results.push(comparison);
  }
  
  console.log('\n');
  return results;
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  
  const yearArg = args.find(a => a.startsWith('--year'));
  const year = yearArg ? parseInt(yearArg.split('=')[1] || args[args.indexOf('--year') + 1]) : undefined;
  
  const fromArg = args.find(a => a.startsWith('--from'));
  const fromYear = fromArg ? parseInt(fromArg.split('=')[1] || args[args.indexOf('--from') + 1]) : undefined;
  
  console.log('\nüá¶üá∑ TMDB Argentina Discovery Script');
  console.log('====================================\n');
  
  if (year) {
    log(`Filtrando por a√±o: ${year}`, 'info');
  } else if (fromYear) {
    log(`Filtrando desde a√±o: ${fromYear}`, 'info');
  }
  
  // Test conexi√≥n a TMDB
  log('Probando conexi√≥n a TMDB...', 'info');
  const connected = await testConnection();
  if (!connected) {
    log('No se pudo conectar a TMDB', 'error');
    process.exit(1);
  }
  log('Conexi√≥n a TMDB exitosa', 'success');
  
  const startTime = Date.now();
  
  // Descubrir pel√≠culas argentinas
  const tmdbMovies = await discoverArgentineMovies(year, fromYear);
  log(`Encontradas ${tmdbMovies.length} pel√≠culas argentinas en TMDB`, 'success');
  
  // Comparar con BD local
  const comparisons = await compareMovies(tmdbMovies);
  
  // Estad√≠sticas
  const stats = {
    total: comparisons.length,
    existsByTmdb: comparisons.filter(c => c.status === 'exists_by_tmdb').length,
    existsByTitle: comparisons.filter(c => c.status === 'exists_by_title').length,
    possibleMatch: comparisons.filter(c => c.status === 'possible_match').length,
    missing: comparisons.filter(c => c.status === 'missing').length,
    missingWithNote: comparisons.filter(c => c.status === 'missing' && c.premiere_note).length,
  };
  
  const elapsed = Date.now() - startTime;
  
  // Guardar CSVs
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
  
  // CSV completo
  saveToCSV(comparisons, `argentina-discovery-${timestamp}.csv`, [
    'tmdb_id', 'tmdb_title', 'tmdb_original_title', 'tmdb_year', 'tmdb_release_date',
    'premiere_date', 'premiere_country', 'premiere_note',
    'tmdb_overview', 'tmdb_popularity', 'tmdb_vote_average', 'tmdb_vote_count',
    'status', 'local_id', 'local_title', 'local_year', 'match_reason'
  ]);
  
  // CSV solo faltantes (con premiere_note)
  const missing = comparisons.filter(c => c.status === 'missing' && c.premiere_note);
  if (missing.length > 0) {
    saveToCSV(missing, `argentina-missing-${timestamp}.csv`, [
      'tmdb_id', 'tmdb_title', 'tmdb_original_title', 'tmdb_year', 'tmdb_release_date',
      'premiere_date', 'premiere_country', 'premiere_note',
      'tmdb_overview', 'tmdb_popularity', 'tmdb_vote_average', 'tmdb_vote_count'
    ]);
  }
  
  // CSV posibles matches (para revisar)
  const possibleMatches = comparisons.filter(c => c.status === 'possible_match');
  if (possibleMatches.length > 0) {
    saveToCSV(possibleMatches, `argentina-possible-matches-${timestamp}.csv`, [
      'tmdb_id', 'tmdb_title', 'tmdb_year', 'tmdb_release_date', 'premiere_date', 'premiere_country', 'premiere_note',
      'local_id', 'local_title', 'local_year', 'match_reason'
    ]);
  }
  
  // Resumen
  console.log('\nüìä Resumen:');
  console.log(`   Total en TMDB:         ${stats.total}`);
  console.log(`   Ya existen (tmdb_id):  ${stats.existsByTmdb}`);
  console.log(`   Ya existen (t√≠tulo):   ${stats.existsByTitle}`);
  console.log(`   Posibles matches:      ${stats.possibleMatch}`);
  console.log(`   Faltan en CineNacional: ${stats.missing}`);
  console.log(`   ‚ùå Faltan (con festival): ${stats.missingWithNote}`);
  console.log(`   Tiempo:                ${formatDuration(elapsed)}`);
  
  await closePool();
  console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
  console.error('Error fatal:', error);
  process.exit(1);
});

// ==================================================
// scripts/tmdb/enrich-movies.ts
// ==================================================
/**
 * Script para enriquecer pel√≠culas con TMDB ID desde TMDB
 * 
 * Uso:
 *   npx tsx enrich-movies.ts --dry-run          # Solo genera CSV
 *   npx tsx enrich-movies.ts --apply            # Aplica cambios a la BD
 *   npx tsx enrich-movies.ts --apply-csv        # Aplica desde CSV revisado
 *   npx tsx enrich-movies.ts --limit 100        # Procesar solo 100 pel√≠culas
 *   npx tsx enrich-movies.ts --offset 500       # Empezar desde la 501
 */

import { searchMovies, getMovieDetails, testConnection, TMDBMovieDetails } from './tmdb-client';
import { 
  getPool, 
  closePool, 
  normalizeText, 
  stringSimilarity,
  saveToCSV, 
  loadFromCSV,
  formatDuration,
  progressBar,
  log 
} from './utils';
import config from './config';

// Tipos
interface LocalMovie {
  id: number;
  title: string;
  year: number | null;
  duration: number | null;
  imdb_id: string | null;
  director_names: string | null; // "Nombre1, Nombre2"
}

interface MatchResult {
  local_id: number;
  local_title: string;
  local_year: number | null;
  local_director: string | null;
  tmdb_id: number | null;
  tmdb_title: string | null;
  tmdb_year: number | null;
  tmdb_director: string | null;
  imdb_id: string | null;
  match_score: number;
  match_status: 'auto_accept' | 'review' | 'no_match' | 'multiple';
  match_reason: string;
}

/**
 * Obtener pel√≠culas sin TMDB ID de la base de datos
 */
async function getMoviesWithoutTmdbId(limit?: number, offset?: number): Promise<LocalMovie[]> {
  const pool = getPool();
  
  const query = `
    SELECT 
      m.id,
      m.title,
      m.year,
      m.duration,
      m.imdb_id,
      STRING_AGG(CONCAT(p.first_name, ' ', p.last_name), ', ') as director_names
    FROM movies m
    LEFT JOIN movie_crew mc ON m.id = mc.movie_id AND mc.role_id = $1
    LEFT JOIN people p ON mc.person_id = p.id
    WHERE m.tmdb_id IS NULL OR m.tmdb_id = 0
    GROUP BY m.id, m.title, m.year, m.duration, m.imdb_id
    ORDER BY m.year DESC NULLS LAST, m.id
    ${limit ? `LIMIT ${limit}` : ''}
    ${offset ? `OFFSET ${offset}` : ''}
  `;
  
  const result = await pool.query(query, [config.roles.director]);
  return result.rows;
}

/**
 * Calcular score de match entre pel√≠cula local y TMDB
 */
function calculateMatchScore(
  local: LocalMovie,
  tmdb: TMDBMovieDetails
): { score: number; reasons: string[] } {
  let score = 0;
  const reasons: string[] = [];
  
  // 1. Comparar t√≠tulos
  const titleSimilarity = Math.max(
    stringSimilarity(local.title, tmdb.title),
    stringSimilarity(local.title, tmdb.original_title)
  );
  
  if (titleSimilarity >= 95) {
    score += 40;
    reasons.push(`T√≠tulo exacto (${titleSimilarity}%)`);
  } else if (titleSimilarity >= 80) {
    score += 30;
    reasons.push(`T√≠tulo similar (${titleSimilarity}%)`);
  } else if (titleSimilarity >= 60) {
    score += 15;
    reasons.push(`T√≠tulo parcial (${titleSimilarity}%)`);
  }
  
  // 2. Comparar a√±o
  if (local.year && tmdb.release_date) {
    const tmdbYear = parseInt(tmdb.release_date.split('-')[0]);
    if (local.year === tmdbYear) {
      score += 25;
      reasons.push('A√±o exacto');
    } else if (Math.abs(local.year - tmdbYear) === 1) {
      score += 15;
      reasons.push('A√±o ¬±1');
    }
  }
  
  // 3. Comparar director
  if (local.director_names && tmdb.credits?.crew) {
    const tmdbDirectors = tmdb.credits.crew
      .filter(c => c.job === 'Director')
      .map(c => normalizeText(c.name));
    
    const localDirectors = local.director_names
      .split(',')
      .map(d => normalizeText(d.trim()));
    
    const hasDirectorMatch = localDirectors.some(ld => 
      tmdbDirectors.some(td => stringSimilarity(ld, td) >= 80)
    );
    
    if (hasDirectorMatch) {
      score += config.matching.movie.directorMatchBonus;
      reasons.push('Director coincide');
    }
  }
  
  // 4. Pa√≠s Argentina
  if (tmdb.production_countries?.some(c => c.iso_3166_1 === 'AR')) {
    score += config.matching.movie.argentinaCountryBonus;
    reasons.push('Producci√≥n Argentina');
  }
  
  // 5. Comparar duraci√≥n
  if (local.duration && tmdb.runtime) {
    const diff = Math.abs(local.duration - tmdb.runtime);
    if (diff <= config.matching.movie.durationToleranceMinutes) {
      score += config.matching.movie.durationMatchBonus;
      reasons.push(`Duraci√≥n similar (¬±${diff}min)`);
    }
  }
  
  return { score, reasons };
}

/**
 * Buscar y matchear una pel√≠cula
 */
async function findMatchForMovie(movie: LocalMovie): Promise<MatchResult> {
  const result: MatchResult = {
    local_id: movie.id,
    local_title: movie.title,
    local_year: movie.year,
    local_director: movie.director_names,
    tmdb_id: null,
    tmdb_title: null,
    tmdb_year: null,
    tmdb_director: null,
    imdb_id: null,
    match_score: 0,
    match_status: 'no_match',
    match_reason: '',
  };
  
  try {
    // Buscar por t√≠tulo y a√±o
    const searchResult = await searchMovies(movie.title, movie.year || undefined);
    
    if (searchResult.total_results === 0) {
      // Intentar sin a√±o
      const searchWithoutYear = await searchMovies(movie.title);
      if (searchWithoutYear.total_results === 0) {
        result.match_reason = 'Sin resultados en TMDB';
        return result;
      }
      searchResult.results = searchWithoutYear.results;
    }
    
    // Evaluar cada candidato
    const candidates: Array<{
      tmdb: TMDBMovieDetails;
      score: number;
      reasons: string[];
    }> = [];
    
    // Limitar a los primeros 5 resultados para no hacer demasiadas requests
    for (const tmdbMovie of searchResult.results.slice(0, 5)) {
      const details = await getMovieDetails(tmdbMovie.id);
      const { score, reasons } = calculateMatchScore(movie, details);
      
      if (score > 0) {
        candidates.push({ tmdb: details, score, reasons });
      }
    }
    
    if (candidates.length === 0) {
      result.match_reason = 'Ning√∫n candidato supera umbral m√≠nimo';
      return result;
    }
    
    // Ordenar por score descendente
    candidates.sort((a, b) => b.score - a.score);
    const best = candidates[0];
    
    // Obtener director de TMDB
    const tmdbDirector = best.tmdb.credits?.crew
      ?.filter(c => c.job === 'Director')
      .map(c => c.name)
      .join(', ') || null;
    
    result.tmdb_id = best.tmdb.id;
    result.tmdb_title = best.tmdb.title;
    result.tmdb_year = best.tmdb.release_date ? parseInt(best.tmdb.release_date.split('-')[0]) : null;
    result.tmdb_director = tmdbDirector;
    result.imdb_id = best.tmdb.imdb_id;
    result.match_score = best.score;
    result.match_reason = best.reasons.join('; ');
    
    // Determinar status
    // Regla especial: t√≠tulo exacto + director coincide = auto_accept
    const hasExactTitle = best.reasons.some(r => r.includes('T√≠tulo exacto'));
    const hasDirectorMatch = best.reasons.some(r => r.includes('Director coincide'));
    
    if (best.score >= config.matching.movie.autoAcceptScore) {
      result.match_status = 'auto_accept';
    } else if (hasExactTitle && hasDirectorMatch) {
      // T√≠tulo exacto + director = suficiente confianza
      result.match_status = 'auto_accept';
      result.match_reason += ' [Auto: t√≠tulo exacto + director]';
    } else if (best.score >= config.matching.movie.reviewScore) {
      if (candidates.length > 1 && candidates[1].score >= config.matching.movie.reviewScore) {
        result.match_status = 'multiple';
        result.match_reason += ` [Alternativas: ${candidates.slice(1, 3).map(c => c.tmdb.title).join(', ')}]`;
      } else {
        result.match_status = 'review';
      }
    }
    
  } catch (error) {
    result.match_reason = `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
  
  return result;
}

/**
 * Aplicar cambios a la base de datos (guarda tmdb_id)
 */
async function applyChanges(matches: MatchResult[]): Promise<{ updated: number; errors: number }> {
  const pool = getPool();
  let updated = 0;
  let errors = 0;
  
  for (const match of matches) {
    if (!match.tmdb_id || match.match_status === 'no_match') continue;
    
    try {
      await pool.query(
        'UPDATE movies SET tmdb_id = $1 WHERE id = $2',
        [match.tmdb_id, match.local_id]
      );
      updated++;
    } catch (error) {
      log(`Error actualizando pel√≠cula ${match.local_id}: ${error}`, 'error');
      errors++;
    }
  }
  
  return { updated, errors };
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry-run') || !args.includes('--apply');
  const applyFromCSV = args.includes('--apply-csv');
  
  const limitArg = args.find(a => a.startsWith('--limit'));
  const limit = limitArg ? parseInt(limitArg.split('=')[1] || args[args.indexOf('--limit') + 1]) : undefined;
  
  const offsetArg = args.find(a => a.startsWith('--offset'));
  const offset = offsetArg ? parseInt(offsetArg.split('=')[1] || args[args.indexOf('--offset') + 1]) : undefined;
  
  console.log('\nüé¨ TMDB Movie Enrichment Script');
  console.log('================================\n');
  
  // Test conexi√≥n a TMDB
  log('Probando conexi√≥n a TMDB...', 'info');
  const connected = await testConnection();
  if (!connected) {
    log('No se pudo conectar a TMDB', 'error');
    process.exit(1);
  }
  log('Conexi√≥n a TMDB exitosa', 'success');
  
  if (applyFromCSV) {
    // Modo: Aplicar desde CSV revisado
    log('Cargando matches desde CSV...', 'info');
    const matches = loadFromCSV('movies-matches.csv') as MatchResult[];
    
    if (matches.length === 0) {
      log('No se encontr√≥ el archivo movies-matches.csv', 'error');
      process.exit(1);
    }
    
    const toApply = matches.filter(m => 
      m.match_status === 'auto_accept' || m.match_status === 'review'
    );
    
    log(`Aplicando ${toApply.length} matches a la base de datos...`, 'info');
    const { updated, errors } = await applyChanges(toApply);
    
    log(`Actualizadas: ${updated} | Errores: ${errors}`, updated > 0 ? 'success' : 'warn');
    
  } else {
    // Modo: Procesar pel√≠culas
    log('Obteniendo pel√≠culas sin TMDB ID...', 'info');
    const movies = await getMoviesWithoutTmdbId(limit, offset);
    log(`Encontradas ${movies.length} pel√≠culas para procesar`, 'info');
    
    if (movies.length === 0) {
      log('No hay pel√≠culas para procesar', 'success');
      await closePool();
      return;
    }
    
    const startTime = Date.now();
    const results: MatchResult[] = [];
    
    // Stats
    let processed = 0;
    let autoAccepted = 0;
    let needsReview = 0;
    let noMatch = 0;
    let multiple = 0;
    
    for (const movie of movies) {
      processed++;
      process.stdout.write(`\r${progressBar(processed, movies.length)} - ${movie.title.slice(0, 30)}...`);
      
      const match = await findMatchForMovie(movie);
      results.push(match);
      
      switch (match.match_status) {
        case 'auto_accept': autoAccepted++; break;
        case 'review': needsReview++; break;
        case 'no_match': noMatch++; break;
        case 'multiple': multiple++; break;
      }
    }
    
    console.log('\n');
    
    const elapsed = Date.now() - startTime;
    
    // Guardar CSV
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
    saveToCSV(results, `movies-matches-${timestamp}.csv`, [
      'local_id', 'local_title', 'local_year', 'local_director',
      'tmdb_id', 'tmdb_title', 'tmdb_year', 'tmdb_director',
      'imdb_id', 'match_score', 'match_status', 'match_reason'
    ]);
    
    // Tambi√©n guardar versi√≥n "latest" para aplicar despu√©s
    saveToCSV(results, 'movies-matches.csv', [
      'local_id', 'local_title', 'local_year', 'local_director',
      'tmdb_id', 'tmdb_title', 'tmdb_year', 'tmdb_director',
      'imdb_id', 'match_score', 'match_status', 'match_reason'
    ]);
    
    // Resumen
    console.log('\nüìä Resumen:');
    console.log(`   Procesadas:      ${processed}`);
    console.log(`   Auto-aceptadas:  ${autoAccepted} (score >= ${config.matching.movie.autoAcceptScore})`);
    console.log(`   Para revisar:    ${needsReview} (score ${config.matching.movie.reviewScore}-${config.matching.movie.autoAcceptScore - 1})`);
    console.log(`   M√∫ltiples:       ${multiple}`);
    console.log(`   Sin match:       ${noMatch}`);
    console.log(`   Tiempo:          ${formatDuration(elapsed)}`);
    
    if (!isDryRun) {
      const toApply = results.filter(r => r.match_status === 'auto_accept');
      log(`\nAplicando ${toApply.length} matches autom√°ticos a la BD...`, 'info');
      const { updated, errors } = await applyChanges(toApply);
      log(`Actualizadas: ${updated} | Errores: ${errors}`, 'success');
    } else {
      console.log('\nüí° Modo dry-run: No se aplicaron cambios.');
      console.log('   Para aplicar auto-aceptados: npx tsx enrich-movies.ts --apply');
      console.log('   Para aplicar desde CSV:      npx tsx enrich-movies.ts --apply-csv');
    }
  }
  
  await closePool();
  console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
  console.error('Error fatal:', error);
  process.exit(1);
});

// ==================================================
// scripts/tmdb/enrich-people.ts
// ==================================================
/**
 * Script para enriquecer personas con IMDB ID desde TMDB
 * 
 * Uso:
 *   npx ts-node enrich-people.ts --dry-run          # Solo genera CSV
 *   npx ts-node enrich-people.ts --apply            # Aplica cambios a la BD
 *   npx ts-node enrich-people.ts --apply-csv        # Aplica desde CSV revisado
 *   npx ts-node enrich-people.ts --limit 100        # Procesar solo 100 personas
 *   npx ts-node enrich-people.ts --offset 500       # Empezar desde la 501
 *   npx ts-node enrich-people.ts --min-movies 3     # Solo personas con 3+ pel√≠culas
 */

import { searchPeople, getPersonDetails, testConnection, TMDBPersonDetails } from './tmdb-client';
import { 
  getPool, 
  closePool, 
  normalizeText, 
  stringSimilarity,
  parseTMDBDate,
  compareDates,
  isArgentineLocation,
  saveToCSV, 
  loadFromCSV,
  formatDuration,
  progressBar,
  log 
} from './utils';
import config from './config';

// Tipos
interface LocalPerson {
  id: number;
  first_name: string | null;
  last_name: string | null;
  full_name: string;
  birth_year: number | null;
  birth_month: number | null;
  birth_day: number | null;
  death_year: number | null;
  death_month: number | null;
  death_day: number | null;
  imdb_id: string | null;
  movie_count: number;
  movie_titles: string | null; // "Pel√≠cula1, Pel√≠cula2"
}

interface MatchResult {
  local_id: number;
  local_name: string;
  local_birth: string | null;
  local_death: string | null;
  local_movies: number;
  tmdb_id: number | null;
  tmdb_name: string | null;
  tmdb_birth: string | null;
  tmdb_death: string | null;
  tmdb_place: string | null;
  imdb_id: string | null;
  match_score: number;
  match_status: 'auto_accept' | 'review' | 'no_match' | 'multiple';
  match_reason: string;
}

/**
 * Obtener personas sin IMDB ID de la base de datos
 */
async function getPeopleWithoutImdbId(
  limit?: number, 
  offset?: number,
  minMovies: number = 1
): Promise<LocalPerson[]> {
  const pool = getPool();
  
  const query = `
    WITH person_movies AS (
      SELECT 
        person_id,
        COUNT(DISTINCT movie_id) as movie_count,
        STRING_AGG(DISTINCT m.title, ', ' ORDER BY m.title) as movie_titles
      FROM (
        SELECT person_id, movie_id FROM movie_cast
        UNION ALL
        SELECT person_id, movie_id FROM movie_crew
      ) all_roles
      JOIN movies m ON all_roles.movie_id = m.id
      GROUP BY person_id
    )
    SELECT 
      p.id,
      p.first_name,
      p.last_name,
      CONCAT(COALESCE(p.first_name, ''), ' ', COALESCE(p.last_name, '')) as full_name,
      p.birth_year,
      p.birth_month,
      p.birth_day,
      p.death_year,
      p.death_month,
      p.death_day,
      p.imdb_id,
      COALESCE(pm.movie_count, 0) as movie_count,
      pm.movie_titles
    FROM people p
    LEFT JOIN person_movies pm ON p.id = pm.person_id
    WHERE (p.tmdb_id IS NULL OR p.tmdb_id = 0)
      AND COALESCE(pm.movie_count, 0) >= $1
    ORDER BY COALESCE(pm.movie_count, 0) DESC, p.id
    ${limit ? `LIMIT ${limit}` : ''}
    ${offset ? `OFFSET ${offset}` : ''}
  `;
  
  const result = await pool.query(query, [minMovies]);
  return result.rows;
}

/**
 * Obtener t√≠tulos de pel√≠culas de una persona en nuestra BD
 */
async function getPersonMovieTitles(personId: number): Promise<string[]> {
  const pool = getPool();
  
  const query = `
    SELECT DISTINCT m.title, m.year
    FROM movies m
    JOIN (
      SELECT movie_id FROM movie_cast WHERE person_id = $1
      UNION
      SELECT movie_id FROM movie_crew WHERE person_id = $1
    ) roles ON m.id = roles.movie_id
    ORDER BY m.year DESC NULLS LAST
    LIMIT 20
  `;
  
  const result = await pool.query(query, [personId]);
  return result.rows.map(r => r.title);
}

/**
 * Calcular score de match entre persona local y TMDB
 */
function calculateMatchScore(
  local: LocalPerson,
  tmdb: TMDBPersonDetails,
  localMovieTitles: string[]
): { score: number; reasons: string[] } {
  let score = 0;
  const reasons: string[] = [];
  
  // 1. Comparar nombres
  const nameSimilarity = stringSimilarity(local.full_name, tmdb.name);
  
  if (nameSimilarity >= 95) {
    score += 30;
    reasons.push(`Nombre exacto (${nameSimilarity}%)`);
  } else if (nameSimilarity >= 80) {
    score += 20;
    reasons.push(`Nombre similar (${nameSimilarity}%)`);
  } else if (nameSimilarity >= 60) {
    score += 10;
    reasons.push(`Nombre parcial (${nameSimilarity}%)`);
  }
  
  // Tambi√©n verificar nombres alternativos de TMDB
  if (tmdb.also_known_as) {
    for (const altName of tmdb.also_known_as) {
      const altSimilarity = stringSimilarity(local.full_name, altName);
      if (altSimilarity >= 90 && altSimilarity > nameSimilarity) {
        score += 10;
        reasons.push(`Nombre alternativo match`);
        break;
      }
    }
  }
  
  // 2. Comparar fecha de nacimiento
  if (local.birth_year && tmdb.birthday) {
    const tmdbBirth = parseTMDBDate(tmdb.birthday);
    const localBirth = {
      year: local.birth_year,
      month: local.birth_month,
      day: local.birth_day,
    };
    
    const birthScore = compareDates(localBirth, tmdbBirth);
    if (birthScore >= 50) {
      score += birthScore / 2; // Max 50 puntos
      reasons.push(`Nacimiento coincide (${birthScore}%)`);
    }
  }
  
  // 3. Comparar fecha de muerte
  if (local.death_year && tmdb.deathday) {
    const tmdbDeath = parseTMDBDate(tmdb.deathday);
    const localDeath = {
      year: local.death_year,
      month: local.death_month,
      day: local.death_day,
    };
    
    const deathScore = compareDates(localDeath, tmdbDeath);
    if (deathScore >= 50) {
      score += deathScore / 2; // Max 50 puntos
      reasons.push(`Fallecimiento coincide (${deathScore}%)`);
    }
  }
  
  // 4. Verificar si es argentino
  if (isArgentineLocation(tmdb.place_of_birth)) {
    score += 15;
    reasons.push('Origen argentino');
  }
  
  // 5. Comparar filmograf√≠a (muy importante para hom√≥nimos)
  if (tmdb.movie_credits && localMovieTitles.length > 0) {
    const tmdbMovies = [
      ...tmdb.movie_credits.cast.map(m => normalizeText(m.title)),
      ...tmdb.movie_credits.crew.map(m => normalizeText(m.title)),
    ];
    
    let movieMatches = 0;
    for (const localTitle of localMovieTitles) {
      const normalizedLocal = normalizeText(localTitle);
      if (tmdbMovies.some(tm => stringSimilarity(normalizedLocal, tm) >= 80)) {
        movieMatches++;
      }
    }
    
    if (movieMatches > 0) {
      const movieScore = Math.min(movieMatches * 10, 30); // Max 30 puntos
      score += movieScore;
      reasons.push(`${movieMatches} pel√≠cula(s) en com√∫n`);
    }
  }
  
  return { score, reasons };
}

/**
 * Buscar y matchear una persona
 */
async function findMatchForPerson(person: LocalPerson): Promise<MatchResult> {
  const result: MatchResult = {
    local_id: person.id,
    local_name: person.full_name.trim(),
    local_birth: person.birth_year ? 
      `${person.birth_year}${person.birth_month ? '-' + String(person.birth_month).padStart(2, '0') : ''}${person.birth_day ? '-' + String(person.birth_day).padStart(2, '0') : ''}` 
      : null,
    local_death: person.death_year ?
      `${person.death_year}${person.death_month ? '-' + String(person.death_month).padStart(2, '0') : ''}${person.death_day ? '-' + String(person.death_day).padStart(2, '0') : ''}`
      : null,
    local_movies: person.movie_count,
    tmdb_id: null,
    tmdb_name: null,
    tmdb_birth: null,
    tmdb_death: null,
    tmdb_place: null,
    imdb_id: null,
    match_score: 0,
    match_status: 'no_match',
    match_reason: '',
  };
  
  // Nombre vac√≠o
  if (!person.full_name.trim()) {
    result.match_reason = 'Nombre vac√≠o';
    return result;
  }
  
  try {
    // Obtener pel√≠culas de la persona para comparar filmograf√≠a
    const localMovieTitles = await getPersonMovieTitles(person.id);
    
    // Buscar en TMDB
    const searchResult = await searchPeople(person.full_name.trim());
    
    if (searchResult.total_results === 0) {
      result.match_reason = 'Sin resultados en TMDB';
      return result;
    }
    
    // Evaluar cada candidato
    const candidates: Array<{
      tmdb: TMDBPersonDetails;
      score: number;
      reasons: string[];
    }> = [];
    
    // Limitar a los primeros 5 resultados
    for (const tmdbPerson of searchResult.results.slice(0, 5)) {
      const details = await getPersonDetails(tmdbPerson.id);
      const { score, reasons } = calculateMatchScore(person, details, localMovieTitles);
      
      if (score > 0) {
        candidates.push({ tmdb: details, score, reasons });
      }
    }
    
    if (candidates.length === 0) {
      result.match_reason = 'Ning√∫n candidato supera umbral m√≠nimo';
      return result;
    }
    
    // Ordenar por score descendente
    candidates.sort((a, b) => b.score - a.score);
    const best = candidates[0];
    
    result.tmdb_id = best.tmdb.id;
    result.tmdb_name = best.tmdb.name;
    result.tmdb_birth = best.tmdb.birthday;
    result.tmdb_death = best.tmdb.deathday;
    result.tmdb_place = best.tmdb.place_of_birth;
    result.imdb_id = best.tmdb.imdb_id;
    result.match_score = best.score;
    result.match_reason = best.reasons.join('; ');
    
    // Determinar status
    // Regla especial: nombre exacto + 2 pel√≠culas en com√∫n = auto_accept
    const hasExactName = best.reasons.some(r => r.includes('Nombre exacto'));
    const movieMatchReason = best.reasons.find(r => r.includes('pel√≠cula(s) en com√∫n'));
    const movieMatchCount = movieMatchReason ? parseInt(movieMatchReason.match(/(\d+)/)?.[1] || '0') : 0;
    
    if (best.score >= config.matching.person.autoAcceptScore) {
      result.match_status = 'auto_accept';
    } else if (hasExactName && movieMatchCount >= 2) {
      // Nombre exacto + 2 pel√≠culas = suficiente confianza
      result.match_status = 'auto_accept';
      result.match_reason += ' [Auto: nombre exacto + pel√≠culas]';
    } else if (best.score >= config.matching.person.reviewScore) {
      // Verificar si hay m√∫ltiples candidatos con score similar
      if (candidates.length > 1 && candidates[1].score >= config.matching.person.reviewScore) {
        result.match_status = 'multiple';
        result.match_reason += ` [Alternativas: ${candidates.slice(1, 3).map(c => `${c.tmdb.name} (${c.score})`).join(', ')}]`;
      } else {
        result.match_status = 'review';
      }
    }
    
  } catch (error) {
    result.match_reason = `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
  
  return result;
}

/**
 * Aplicar cambios a la base de datos
 */
async function applyChanges(matches: MatchResult[]): Promise<{ updated: number; errors: number }> {
  const pool = getPool();
  let updated = 0;
  let errors = 0;
  
  for (const match of matches) {
    if (!match.tmdb_id || match.match_status === 'no_match') continue;
    
    try {
      await pool.query(
        'UPDATE people SET tmdb_id = $1 WHERE id = $2',
        [match.tmdb_id, match.local_id]
      );
      updated++;
    } catch (error) {
      log(`Error actualizando persona ${match.local_id}: ${error}`, 'error');
      errors++;
    }
  }
  
  return { updated, errors };
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry-run') || !args.includes('--apply');
  const applyFromCSV = args.includes('--apply-csv');
  
  const limitArg = args.find(a => a.startsWith('--limit'));
  const limit = limitArg ? parseInt(limitArg.split('=')[1] || args[args.indexOf('--limit') + 1]) : undefined;
  
  const offsetArg = args.find(a => a.startsWith('--offset'));
  const offset = offsetArg ? parseInt(offsetArg.split('=')[1] || args[args.indexOf('--offset') + 1]) : undefined;
  
  const minMoviesArg = args.find(a => a.startsWith('--min-movies'));
  const minMovies = minMoviesArg ? parseInt(minMoviesArg.split('=')[1] || args[args.indexOf('--min-movies') + 1]) : 1;
  
  console.log('\nüë§ TMDB People Enrichment Script');
  console.log('=================================\n');
  
  // Test conexi√≥n a TMDB
  log('Probando conexi√≥n a TMDB...', 'info');
  const connected = await testConnection();
  if (!connected) {
    log('No se pudo conectar a TMDB', 'error');
    process.exit(1);
  }
  log('Conexi√≥n a TMDB exitosa', 'success');
  
  if (applyFromCSV) {
    // Modo: Aplicar desde CSV revisado
    log('Cargando matches desde CSV...', 'info');
    const matches = loadFromCSV('people-matches.csv') as MatchResult[];
    
    if (matches.length === 0) {
      log('No se encontr√≥ el archivo people-matches.csv', 'error');
      process.exit(1);
    }
    
    const toApply = matches.filter(m => 
      m.match_status === 'auto_accept' || m.match_status === 'review'
    );
    
    log(`Aplicando ${toApply.length} matches a la base de datos...`, 'info');
    const { updated, errors } = await applyChanges(toApply);
    
    log(`Actualizadas: ${updated} | Errores: ${errors}`, updated > 0 ? 'success' : 'warn');
    
  } else {
    // Modo: Procesar personas
    log(`Obteniendo personas sin IMDB ID (min ${minMovies} pel√≠cula(s))...`, 'info');
    const people = await getPeopleWithoutImdbId(limit, offset, minMovies);
    log(`Encontradas ${people.length} personas para procesar`, 'info');
    
    if (people.length === 0) {
      log('No hay personas para procesar', 'success');
      await closePool();
      return;
    }
    
    const startTime = Date.now();
    const results: MatchResult[] = [];
    
    // Stats
    let processed = 0;
    let autoAccepted = 0;
    let needsReview = 0;
    let noMatch = 0;
    let multiple = 0;
    
    for (const person of people) {
      processed++;
      process.stdout.write(`\r${progressBar(processed, people.length)} - ${person.full_name.slice(0, 25)}...`);
      
      const match = await findMatchForPerson(person);
      results.push(match);
      
      switch (match.match_status) {
        case 'auto_accept': autoAccepted++; break;
        case 'review': needsReview++; break;
        case 'no_match': noMatch++; break;
        case 'multiple': multiple++; break;
      }
    }
    
    console.log('\n');
    
    const elapsed = Date.now() - startTime;
    
    // Guardar CSV
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
    saveToCSV(results, `people-matches-${timestamp}.csv`, [
      'local_id', 'local_name', 'local_birth', 'local_death', 'local_movies',
      'tmdb_id', 'tmdb_name', 'tmdb_birth', 'tmdb_death', 'tmdb_place',
      'imdb_id', 'match_score', 'match_status', 'match_reason'
    ]);
    
    // Tambi√©n guardar versi√≥n "latest" para aplicar despu√©s
    saveToCSV(results, 'people-matches.csv', [
      'local_id', 'local_name', 'local_birth', 'local_death', 'local_movies',
      'tmdb_id', 'tmdb_name', 'tmdb_birth', 'tmdb_death', 'tmdb_place',
      'imdb_id', 'match_score', 'match_status', 'match_reason'
    ]);
    
    // Resumen
    console.log('\nüìä Resumen:');
    console.log(`   Procesadas:      ${processed}`);
    console.log(`   Auto-aceptadas:  ${autoAccepted} (score >= ${config.matching.person.autoAcceptScore})`);
    console.log(`   Para revisar:    ${needsReview} (score ${config.matching.person.reviewScore}-${config.matching.person.autoAcceptScore - 1})`);
    console.log(`   M√∫ltiples:       ${multiple}`);
    console.log(`   Sin match:       ${noMatch}`);
    console.log(`   Tiempo:          ${formatDuration(elapsed)}`);
    
    // Estimaci√≥n para todo el dataset
    if (limit && processed > 0) {
      const avgTimePerPerson = elapsed / processed;
      const totalPeople = 63950; // De los datos que me diste
      const estimatedTotal = avgTimePerPerson * totalPeople;
      console.log(`\n‚è±Ô∏è  Tiempo estimado para ${totalPeople} personas: ${formatDuration(estimatedTotal)}`);
    }
    
    if (!isDryRun) {
      const toApply = results.filter(r => r.match_status === 'auto_accept');
      log(`\nAplicando ${toApply.length} matches autom√°ticos a la BD...`, 'info');
      const { updated, errors } = await applyChanges(toApply);
      log(`Actualizadas: ${updated} | Errores: ${errors}`, 'success');
    } else {
      console.log('\nüí° Modo dry-run: No se aplicaron cambios.');
      console.log('   Para aplicar auto-aceptados: npx ts-node enrich-people.ts --apply');
      console.log('   Para aplicar desde CSV:      npx ts-node enrich-people.ts --apply-csv');
    }
  }
  
  await closePool();
  console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
  console.error('Error fatal:', error);
  process.exit(1);
});

// ==================================================
// scripts/tmdb/import-tmdb-movies.ts
// ==================================================
/**
 * Script para importar pel√≠culas desde TMDB a CineNacional
 * 
 * Uso:
 *   npx tsx import-tmdb-movies.ts --csv argentina-missing.csv     # Importar desde CSV
 *   npx tsx import-tmdb-movies.ts --id 1525353                    # Importar una pel√≠cula espec√≠fica
 *   npx tsx import-tmdb-movies.ts --id 1525353 --dry-run          # Solo mostrar qu√© har√≠a
 *   npx tsx import-tmdb-movies.ts --csv argentina-missing.csv --limit 5  # Solo las primeras 5
 */

import * as fs from 'fs';
import * as path from 'path';
import { Pool } from 'pg';
import config from './config';

// ============================================================================
// CONFIGURACI√ìN Y TIPOS
// ============================================================================

const TMDB_BASE_URL = config.tmdbBaseUrl;
const RATE_LIMIT_MS = config.delayBetweenRequests;

interface TMDBMovieDetails {
    id: number;
    title: string;
    original_title: string;
    overview: string;
    release_date: string;
    runtime: number | null;
    genres: Array<{ id: number; name: string }>;
    production_countries: Array<{ iso_3166_1: string; name: string }>;
    credits: {
        cast: TMDBCastMember[];
        crew: TMDBCrewMember[];
    };
    translations: {
        translations: Array<{
            iso_3166_1: string;
            iso_639_1: string;
            data: {
                title: string;
                overview: string;
            };
        }>;
    };
}

interface TMDBCastMember {
    id: number;
    name: string;
    character: string;
    order: number;
    known_for_department: string;
}

interface TMDBCrewMember {
    id: number;
    name: string;
    job: string;
    department: string;
    known_for_department: string;
}

interface LocalPerson {
    id: number;
    first_name: string | null;
    last_name: string | null;
    tmdb_id: number | null;
    birth_year: number | null;
    death_year: number | null;
}

interface ImportResult {
    tmdb_id: number;
    title: string;
    status: 'success' | 'error' | 'skipped';
    movie_id?: number;
    message: string;
    cast_imported: number;
    crew_imported: number;
    people_created: number;
    people_found: number;
    people_needs_review: number;
}

interface NameSplitResult {
    firstName: string;
    lastName: string;
    gender: 'MALE' | 'FEMALE' | null;
    needsReview: boolean;
    reviewReason?: string;
}

interface PersonForReview {
    tmdb_id: number;
    full_name: string;
    first_name: string;
    last_name: string;
    gender: 'MALE' | 'FEMALE' | null;
    reason: string;
    movie_title: string;
    role: string;
}

interface PersonMatchResult {
    status: 'found' | 'create' | 'review';
    tmdb_id: number;
    name: string;
    local_id?: number;
    firstName?: string;
    lastName?: string;
    gender?: 'MALE' | 'FEMALE' | null;
    reason?: string;
}

// Cache global para first_name_gender
let firstNameGenderCache: Map<string, 'MALE' | 'FEMALE'> | null = null;

// Lista de personas que necesitan revisi√≥n
const peopleForReview: PersonForReview[] = [];

// ============================================================================
// MAPEO DE G√âNEROS TMDB -> CINENACIONAL
// ============================================================================

const GENRE_MAP: Record<number, number> = {
    28: 32,    // Action -> Acci√≥n
    12: 30,    // Adventure -> Aventuras
    16: 18,    // Animation -> Animaci√≥n
    35: 17,    // Comedy -> Comedia
    80: 21,    // Crime -> Policial
    99: 15,    // Documentary -> Documental
    18: 16,    // Drama -> Drama
    10751: 29, // Family -> Infantil
    14: 26,    // Fantasy -> Fant√°stico
    36: 28,    // History -> Hist√≥rica
    27: 19,    // Horror -> Terror
    10402: 25, // Music -> Musical
    9648: 22,  // Mystery -> Suspenso
    10749: 23, // Romance -> Rom√°ntica
    878: 27,   // Science Fiction -> Ciencia ficci√≥n
    53: 24,    // Thriller -> Thriller
    10752: 36, // War -> B√©lica
    37: 33,    // Western -> Western
};

// ============================================================================
// MAPEO DE DEPARTAMENTOS TMDB -> CINENACIONAL
// ============================================================================

const DEPARTMENT_MAP: Record<string, string> = {
    'Directing': 'DIRECCION',
    'Production': 'PRODUCCION',
    'Writing': 'GUION',
    'Camera': 'FOTOGRAFIA',
    'Editing': 'MONTAJE',
    'Sound': 'SONIDO',
    'Art': 'ARTE',
    'Costume & Make-Up': 'VESTUARIO',
    'Visual Effects': 'POSTPRODUCCION',
    'Lighting': 'FOTOGRAFIA',
    'Crew': 'OTROS',
};

// Mapeo de jobs de TMDB a role_id de CineNacional
const JOB_TO_ROLE_ID: Record<string, number> = {
    'Director': config.roles.director,
    'Director of Photography': 526,
    'Screenplay': 3,
    'Writer': 3,
    'Producer': 689,
    'Executive Producer': 703,
    'Editor': 636,
    'Original Music Composer': 641,
    'Music': 641,
    'Production Design': 836,
    'Art Direction': 836,
    'Costume Design': 835,
    'Makeup Artist': 838,
    'Sound Designer': 444,
    'Sound Mixer': 629,
    'Sound': 767,
};

// Mapeo de c√≥digo ISO a nombre del pa√≠s en castellano (como est√° en locations)
const ISO_TO_COUNTRY_NAME: Record<string, string> = {
    'AR': 'Argentina',
    'UY': 'Uruguay',
    'BR': 'Brasil',
    'CL': 'Chile',
    'MX': 'M√©xico',
    'ES': 'Espa√±a',
    'US': 'Estados Unidos',
    'FR': 'Francia',
    'IT': 'Italia',
    'DE': 'Alemania',
    'GB': 'Reino Unido',
    'CO': 'Colombia',
    'PE': 'Per√∫',
    'VE': 'Venezuela',
    'BO': 'Bolivia',
    'PY': 'Paraguay',
    'EC': 'Ecuador',
    'CU': 'Cuba',
    'PR': 'Puerto Rico',
    'DO': 'Rep√∫blica Dominicana',
    'CR': 'Costa Rica',
    'PA': 'Panam√°',
    'GT': 'Guatemala',
    'HN': 'Honduras',
    'SV': 'El Salvador',
    'NI': 'Nicaragua',
    'PT': 'Portugal',
    'CA': 'Canad√°',
    'AU': 'Australia',
    'NZ': 'Nueva Zelanda',
    'JP': 'Jap√≥n',
    'CN': 'China',
    'KR': 'Corea del Sur',
    'IN': 'India',
    'RU': 'Rusia',
    'PL': 'Polonia',
    'NL': 'Pa√≠ses Bajos',
    'BE': 'B√©lgica',
    'CH': 'Suiza',
    'AT': 'Austria',
    'SE': 'Suecia',
    'NO': 'Noruega',
    'DK': 'Dinamarca',
    'FI': 'Finlandia',
    'IE': 'Irlanda',
    'IL': 'Israel',
    'ZA': 'Sud√°frica',
};

// ============================================================================
// POOL DE CONEXI√ìN
// ============================================================================

let pool: Pool | null = null;

function getPool(): Pool {
    if (!pool) {
        pool = new Pool({
            connectionString: config.databaseUrl,
            max: 5,
            idleTimeoutMillis: 30000,
        });
    }
    return pool;
}

async function closePool(): Promise<void> {
    if (pool) {
        await pool.end();
        pool = null;
    }
}

// ============================================================================
// FUNCIONES DE API TMDB
// ============================================================================

async function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchTMDB<T>(endpoint: string, params: Record<string, string> = {}): Promise<T> {
    const url = new URL(`${TMDB_BASE_URL}${endpoint}`);
    Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value));

    const response = await fetch(url.toString(), {
        headers: {
            'Authorization': `Bearer ${config.tmdbAccessToken}`,
            'Content-Type': 'application/json',
        },
    });

    if (!response.ok) {
        throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
    }

    return response.json();
}

async function getMovieDetails(tmdbId: number): Promise<TMDBMovieDetails> {
    return fetchTMDB<TMDBMovieDetails>(`/movie/${tmdbId}`, {
        append_to_response: 'credits,translations',
        language: 'es-ES',
    });
}

function getSpanishTitle(movie: TMDBMovieDetails): string {
    const esTranslation = movie.translations.translations.find(
        t => t.iso_639_1 === 'es' && t.iso_3166_1 === 'ES'
    );

    if (esTranslation?.data?.title) {
        return esTranslation.data.title;
    }

    const esLaTranslation = movie.translations.translations.find(
        t => t.iso_639_1 === 'es'
    );

    if (esLaTranslation?.data?.title) {
        return esLaTranslation.data.title;
    }

    return movie.title;
}

function getSpanishOverview(movie: TMDBMovieDetails): string {
    const esTranslation = movie.translations.translations.find(
        t => t.iso_639_1 === 'es' && t.iso_3166_1 === 'ES'
    );

    if (esTranslation?.data?.overview) {
        return esTranslation.data.overview;
    }

    const esLaTranslation = movie.translations.translations.find(
        t => t.iso_639_1 === 'es'
    );

    if (esLaTranslation?.data?.overview) {
        return esLaTranslation.data.overview;
    }

    return movie.overview || '';
}

// ============================================================================
// INTEGRACI√ìN CON CLAUDE API
// ============================================================================

async function askClaude(prompt: string): Promise<string> {
    console.log('üîë API Key (primeros 20 chars):', config.anthropicApiKey?.substring(0, 20));

    const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': config.anthropicApiKey,
            'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 600,
            messages: [
                { role: 'user', content: prompt }
            ]
        })
    });

    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Claude API error: ${response.status} - ${error}`);
    }

    const data = await response.json();
    return data.content[0].text;
}

async function rewriteSynopsis(originalSynopsis: string, isDocumental: boolean): Promise<string> {
    if (!originalSynopsis || originalSynopsis.trim().length === 0) {
        return '';
    }

    const prompt = `Convert√≠ el siguiente texto en una sinopsis cinematogr√°fica que cumpla con estos criterios:

Extensi√≥n: entre 400 y 500 caracteres (incluyendo espacios)

Contenido:
- Describ√≠ √∫nicamente la premisa y situaci√≥n inicial
- Present√° los personajes principales y el conflicto central
- Sin spoilers: no reveles giros argumentales, desenlaces ni informaci√≥n del √∫ltimo tercio de la pel√≠cula
${isDocumental ? '- Es un documental: comenz√° con la estructura "Documental que..." e integr√° esa palabra al texto' : ''}
- Si el texto fuente no ofrece suficiente informaci√≥n para alcanzar los 400 caracteres, es preferible entregar una sinopsis m√°s breve antes que inventar o inferir datos que no est√©n en el original

Estilo:
- Tono neutral y objetivo, sin juicios de valor
- Sin lenguaje promocional ni adjetivos laudatorios
- Redacci√≥n clara y directa
- Tercera persona, tiempo presente
- Espa√±ol rioplatense (con voseo) pero sin lunfardo ni jerga

Restricciones:
- NO incluyas t√≠tulo, director, actores, pa√≠ses ni datos t√©cnicos
- NO uses metadiscurso como "La pel√≠cula narra...", "El film cuenta...", "Esta historia trata de..."
- Comenz√° directamente con la acci√≥n o situaci√≥n ${isDocumental ? '(usando "Documental que...")' : ''}

Texto original:
${originalSynopsis}

Responde SOLO con la sinopsis reescrita, sin explicaciones ni comentarios adicionales.`;

    try {
        const rewritten = await askClaude(prompt);
        return rewritten.trim();
    } catch (error) {
        console.log(`     ‚ö† Error al reescribir sinopsis con Claude: ${error}`);
        return originalSynopsis; // Fallback al original
    }
}

/**
 * Filtra nombres de personajes que est√°n en ingl√©s o son gen√©ricos
 */
function filterCharacterName(character: string | null): string | null {
    if (!character) return null;

    const invalidCharacters = [
        'self',
        'himself',
        'herself',
        'themselves',
        'narrator',
        'voice',
        'voice over',
        'voiceover',
        'archive footage',
        'archival footage',
        'interviewee',
        'additional voices',
        'uncredited',
    ];

    const lowerChar = character.toLowerCase().trim();

    // Si es un nombre inv√°lido o gen√©rico en ingl√©s, retornar null
    if (invalidCharacters.includes(lowerChar)) {
        return null;
    }

    // Si empieza con "Self -" o "Self (" tambi√©n es inv√°lido
    if (lowerChar.startsWith('self -') || lowerChar.startsWith('self (')) {
        return null;
    }

    return character;
}

// ============================================================================
// FUNCIONES DE SEPARACI√ìN DE NOMBRE Y G√âNERO
// ============================================================================

/**
 * Tokeniza un nombre respetando apodos entre comillas
 * Igual que en NameSplitModal.tsx
 */
function tokenizeName(fullName: string): string[] {
    const tokens: string[] = [];
    let current = '';
    let inQuotes = false;
    let quoteChar = '';

    for (let i = 0; i < fullName.length; i++) {
        const char = fullName[i];
        const prevChar = i > 0 ? fullName[i - 1] : '';

        // Detectar inicio de comillas (solo si hay espacio antes o es el inicio)
        if (!inQuotes && (char === '"' || char === "'" || char === '¬´' || char === '"')) {
            if (prevChar === ' ' || i === 0) {
                inQuotes = true;
                quoteChar = char === '¬´' ? '¬ª' : (char === '"' ? '"' : char);
                current += char;
                continue;
            }
        }

        // Detectar fin de comillas
        if (inQuotes && (char === quoteChar || (quoteChar === '"' && char === '"'))) {
            current += char;
            inQuotes = false;
            quoteChar = '';
            continue;
        }

        // Espacios fuera de comillas separan tokens
        if (char === ' ' && !inQuotes) {
            if (current.trim()) {
                tokens.push(current.trim());
            }
            current = '';
        } else {
            current += char;
        }
    }

    // Agregar √∫ltima palabra
    if (current.trim()) {
        tokens.push(current.trim());
    }

    return tokens;
}

/**
 * Carga el cache de first_name_gender desde la base de datos
 */
async function loadFirstNameGenderCache(): Promise<void> {
    if (firstNameGenderCache !== null) {
        return;
    }

    const pool = getPool();
    const result = await pool.query(`
    SELECT name, gender FROM first_name_genders
  `);

    firstNameGenderCache = new Map();
    for (const row of result.rows) {
        firstNameGenderCache.set(row.name.toLowerCase(), row.gender);
    }

    console.log(`üìö Cache de nombres cargado: ${firstNameGenderCache.size} entradas`);
}

/**
 * Busca un nombre en el cache de first_name_gender
 */
function lookupGender(name: string): 'MALE' | 'FEMALE' | null {
    if (!firstNameGenderCache) {
        return null;
    }

    const cleanName = name
        .replace(/["'"¬´¬ª""]/g, '')
        .trim()
        .toLowerCase();

    return firstNameGenderCache.get(cleanName) || null;
}

/**
 * Separa un nombre completo en nombre y apellido, y determina el g√©nero
 */
function splitNameAndGetGender(fullName: string): NameSplitResult {
    const tokens = tokenizeName(fullName.trim());

    if (tokens.length === 0) {
        return {
            firstName: '',
            lastName: '',
            gender: null,
            needsReview: true,
            reviewReason: 'Nombre vac√≠o'
        };
    }

    if (tokens.length === 1) {
        const gender = lookupGender(tokens[0]);
        return {
            firstName: tokens[0],
            lastName: '',
            gender,
            needsReview: gender === null,
            reviewReason: gender === null ? 'Nombre √∫nico no encontrado en base de datos' : undefined
        };
    }

    // Buscar progresivamente cu√°ntos tokens forman el nombre
    let firstNameWordCount = 0;
    let detectedGender: 'MALE' | 'FEMALE' | null = null;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const gender = lookupGender(token);

        if (gender !== null) {
            firstNameWordCount = i + 1;

            if (detectedGender === null) {
                detectedGender = gender;
            }
        } else {
            break;
        }
    }

    // Si no se encontr√≥ ning√∫n nombre conocido, usar la primera palabra
    if (firstNameWordCount === 0) {
        return {
            firstName: tokens[0],
            lastName: tokens.slice(1).join(' '),
            gender: null,
            needsReview: true,
            reviewReason: `Primer nombre "${tokens[0]}" no encontrado en base de datos`
        };
    }

    const firstName = tokens.slice(0, firstNameWordCount).join(' ');
    const lastName = tokens.slice(firstNameWordCount).join(' ');

    return {
        firstName,
        lastName,
        gender: detectedGender,
        needsReview: false
    };
}

// ============================================================================
// FUNCIONES DE BASE DE DATOS
// ============================================================================

async function movieExistsByTmdbId(tmdbId: number): Promise<number | null> {
    const pool = getPool();
    const result = await pool.query(
        'SELECT id FROM movies WHERE tmdb_id = $1',
        [tmdbId]
    );
    return result.rows.length > 0 ? result.rows[0].id : null;
}

async function findPersonByTmdbId(tmdbId: number): Promise<LocalPerson | null> {
    const pool = getPool();
    const result = await pool.query(
        `SELECT id, first_name, last_name, tmdb_id, birth_year, death_year 
     FROM people WHERE tmdb_id = $1`,
        [tmdbId]
    );
    return result.rows.length > 0 ? result.rows[0] : null;
}

async function findPersonByName(name: string): Promise<LocalPerson[]> {
    const pool = getPool();

    let query = `
    SELECT id, first_name, last_name, tmdb_id, birth_year, death_year 
    FROM people 
    WHERE LOWER(CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, ''))) = LOWER($1)
       OR LOWER(CONCAT(COALESCE(last_name, ''), ' ', COALESCE(first_name, ''))) = LOWER($1)
  `;

    const result = await pool.query(query, [name]);
    return result.rows;
}

async function findPersonByNameAndDepartment(
    name: string,
    department: string,
    movieYear: number
): Promise<LocalPerson | null> {
    const candidates = await findPersonByName(name);

    if (candidates.length === 0) {
        return null;
    }

    if (candidates.length === 1) {
        return candidates[0];
    }

    const pool = getPool();

    for (const candidate of candidates) {
        const deptResult = await pool.query(`
      SELECT DISTINCT mc.department 
      FROM movie_crew mc
      WHERE mc.person_id = $1
    `, [candidate.id]);

        const departments = deptResult.rows.map((r: any) => r.department);
        const localDept = DEPARTMENT_MAP[department] || 'OTROS';

        if (departments.includes(localDept)) {
            if (candidate.birth_year) {
                const estimatedAge = movieYear - candidate.birth_year;
                if (estimatedAge >= 15 && estimatedAge <= 90) {
                    return candidate;
                }
            } else {
                const yearsResult = await pool.query(`
          SELECT MIN(m.year) as min_year, MAX(m.year) as max_year
          FROM movies m
          JOIN movie_crew mc ON m.id = mc.movie_id
          WHERE mc.person_id = $1
        `, [candidate.id]);

                if (yearsResult.rows[0].min_year && yearsResult.rows[0].max_year) {
                    const minYear = yearsResult.rows[0].min_year;
                    const maxYear = yearsResult.rows[0].max_year;
                    if (movieYear >= minYear - 10 && movieYear <= maxYear + 30) {
                        return candidate;
                    }
                }
            }
        }
    }

    for (const candidate of candidates) {
        const castResult = await pool.query(`
      SELECT COUNT(*) as count FROM movie_cast WHERE person_id = $1
    `, [candidate.id]);

        if (castResult.rows[0].count > 0) {
            if (candidate.birth_year) {
                const estimatedAge = movieYear - candidate.birth_year;
                if (estimatedAge >= 5 && estimatedAge <= 95) {
                    return candidate;
                }
            }
        }
    }

    return null;
}

/**
 * Analiza una persona y determina qu√© se har√≠a (sin insertar)
 */
async function analyzePersonMatch(
    tmdbId: number,
    name: string,
    department: string,
    movieYear: number
): Promise<PersonMatchResult> {
    // 1. Buscar por tmdb_id
    const byTmdb = await findPersonByTmdbId(tmdbId);
    if (byTmdb) {
        return {
            status: 'found',
            tmdb_id: tmdbId,
            name: name,
            local_id: byTmdb.id
        };
    }

    // 2. Buscar por nombre
    const byName = await findPersonByNameAndDepartment(name, department, movieYear);
    if (byName) {
        return {
            status: 'found',
            tmdb_id: tmdbId,
            name: name,
            local_id: byName.id
        };
    }

    // 3. Se crear√≠a nueva - analizar nombre
    const splitResult = splitNameAndGetGender(name);

    if (splitResult.needsReview) {
        return {
            status: 'review',
            tmdb_id: tmdbId,
            name: name,
            firstName: splitResult.firstName,
            lastName: splitResult.lastName,
            gender: splitResult.gender,
            reason: splitResult.reviewReason
        };
    }

    return {
        status: 'create',
        tmdb_id: tmdbId,
        name: name,
        firstName: splitResult.firstName,
        lastName: splitResult.lastName,
        gender: splitResult.gender
    };
}

async function createPerson(
    tmdbId: number,
    name: string,
    knownForDepartment: string,
    movieTitle: string,
    role: string
): Promise<number> {
    const pool = getPool();

    const splitResult = splitNameAndGetGender(name);
    const { firstName, lastName, gender, needsReview, reviewReason } = splitResult;

    if (needsReview) {
        peopleForReview.push({
            tmdb_id: tmdbId,
            full_name: name,
            first_name: firstName,
            last_name: lastName,
            gender,
            reason: reviewReason || 'Requiere revisi√≥n manual',
            movie_title: movieTitle,
            role
        });
    }

    // Generar slug √∫nico
    const baseSlug = name.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');

    let slug = baseSlug;
    let counter = 1;

    while (true) {
        const existing = await pool.query('SELECT id FROM people WHERE slug = $1', [slug]);
        if (existing.rows.length === 0) break;
        slug = `${baseSlug}-${counter++}`;
    }

    const result = await pool.query(`
    INSERT INTO people (first_name, last_name, slug, tmdb_id, gender, is_active, created_at, updated_at)
    VALUES ($1, $2, $3, $4, $5, true, NOW(), NOW())
    RETURNING id
  `, [firstName, lastName, slug, tmdbId, gender]);

    return result.rows[0].id;
}

async function createMovie(
    movie: TMDBMovieDetails,
    title: string,
    synopsis: string,
    hasCoproduction: boolean
): Promise<number> {
    const pool = getPool();

    const year = movie.release_date ? parseInt(movie.release_date.split('-')[0]) : null;

    // Calcular tipo_duracion seg√∫n duraci√≥n
    let tipoDuracion = 'largometraje';
    if (movie.runtime) {
        if (movie.runtime < 30) {
            tipoDuracion = 'cortometraje';
        } else if (movie.runtime <= 59) {
            tipoDuracion = 'mediometraje';
        }
    }

    const baseSlug = title.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');

    let slug = year ? `${baseSlug}-${year}` : baseSlug;
    let counter = 1;

    while (true) {
        const existing = await pool.query('SELECT id FROM movies WHERE slug = $1', [slug]);
        if (existing.rows.length === 0) break;
        slug = `${baseSlug}-${year}-${counter++}`;
    }

    const result = await pool.query(`
    INSERT INTO movies (
      title, slug, year, 
      duration, synopsis, tmdb_id,
      stage, data_completeness,
      sound_type, color_type_id, tipo_duracion,
      is_coproduction,
      created_at, updated_at
    ) VALUES (
      $1, $2, $3, 
      $4, $5, $6,
      'COMPLETA', 'BASIC_PRESS_KIT',
      'Sonora', 1, $7,
      $8,
      NOW(), NOW()
    )
    RETURNING id
  `, [
        title,
        slug,
        year,
        movie.runtime,
        synopsis,
        movie.id,
        tipoDuracion,
        hasCoproduction,
    ]);

    return result.rows[0].id;
}

async function addMovieGenres(movieId: number, tmdbGenres: Array<{ id: number }>): Promise<void> {
    const pool = getPool();

    for (let i = 0; i < tmdbGenres.length; i++) {
        const tmdbGenreId = tmdbGenres[i].id;
        const localGenreId = GENRE_MAP[tmdbGenreId];

        if (localGenreId) {
            await pool.query(`
        INSERT INTO movie_genres (movie_id, genre_id, is_primary)
        VALUES ($1, $2, $3)
        ON CONFLICT DO NOTHING
      `, [movieId, localGenreId, i === 0]);
        }
    }
}

async function addMovieCountries(movieId: number, countries: Array<{ iso_3166_1: string }>): Promise<void> {
    const pool = getPool();

    // Solo agregar pa√≠ses que NO sean Argentina
    const coProducers = countries.filter(c => c.iso_3166_1 !== 'AR');

    for (const country of coProducers) {
        const countryName = ISO_TO_COUNTRY_NAME[country.iso_3166_1];

        if (countryName) {
            const countryResult = await pool.query(
                `SELECT id FROM locations WHERE name = $1 LIMIT 1`,
                [countryName]
            );

            if (countryResult.rows.length > 0) {
                await pool.query(`
          INSERT INTO movie_countries (movie_id, country_id, is_primary)
          VALUES ($1, $2, false)
          ON CONFLICT DO NOTHING
        `, [movieId, countryResult.rows[0].id]);
            } else {
                console.log(`     ‚ö† Pa√≠s no encontrado en locations: ${countryName} (${country.iso_3166_1})`);
            }
        } else {
            console.log(`     ‚ö† C√≥digo ISO no mapeado: ${country.iso_3166_1}`);
        }
    }
}

async function addMovieCast(
    movieId: number,
    cast: TMDBCastMember[],
    movieYear: number,
    movieTitle: string,
    tmdbGenres: Array<{ id: number; name: string }>,
    stats: { created: number }
): Promise<number> {
    const pool = getPool();
    let imported = 0;

    // Detectar si es documental (g√©nero TMDB id 99)
    const isDocumental = tmdbGenres.some(g => g.id === 99);
    const isActor = !isDocumental;

    const mainCast = cast.slice(0, 20);

    for (const member of mainCast) {
        let personId: number | null = null;

        const byTmdb = await findPersonByTmdbId(member.id);
        if (byTmdb) {
            personId = byTmdb.id;
        } else {
            const byName = await findPersonByNameAndDepartment(
                member.name,
                'Acting',
                movieYear
            );

            if (byName) {
                personId = byName.id;
                if (!byName.tmdb_id) {
                    await pool.query(
                        'UPDATE people SET tmdb_id = $1, updated_at = NOW() WHERE id = $2',
                        [member.id, personId]
                    );
                }
            } else {
                personId = await createPerson(
                    member.id,
                    member.name,
                    member.known_for_department,
                    movieTitle,
                    'cast'
                );
                stats.created++;
            }
        }

        await pool.query(`
      INSERT INTO movie_cast (
        movie_id, person_id, character_name, billing_order, is_principal, is_actor
      ) VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT DO NOTHING
    `, [movieId, personId, filterCharacterName(member.character), member.order, member.order < 5, isActor]);

        imported++;
    }

    return imported;
}

async function addMovieCrew(
    movieId: number,
    crew: TMDBCrewMember[],
    movieYear: number,
    movieTitle: string,
    stats: { created: number }
): Promise<number> {
    const pool = getPool();
    let imported = 0;

    const importantJobs = Object.keys(JOB_TO_ROLE_ID);

    const relevantCrew = crew.filter(c => importantJobs.includes(c.job));
    const uniqueCrew = new Map<string, TMDBCrewMember>();

    for (const member of relevantCrew) {
        const key = `${member.id}-${member.job}`;
        if (!uniqueCrew.has(key)) {
            uniqueCrew.set(key, member);
        }
    }

    // Registrar jobs no mapeados para el reporte
    const unmappedJobs = crew.filter(c => !importantJobs.includes(c.job));
    const uniqueUnmappedJobs = new Map<string, TMDBCrewMember>();
    for (const member of unmappedJobs) {
        const key = `${member.id}-${member.job}`;
        if (!uniqueUnmappedJobs.has(key)) {
            uniqueUnmappedJobs.set(key, member);
        }
    }

    // Agregar los no mapeados al reporte de revisi√≥n
    for (const [, member] of uniqueUnmappedJobs) {
        peopleForReview.push({
            tmdb_id: member.id,
            full_name: member.name,
            first_name: '',
            last_name: '',
            gender: null,
            reason: `Job no mapeado: "${member.job}" (${member.department})`,
            movie_title: movieTitle,
            role: member.job
        });
    }

    for (const [, member] of uniqueCrew) {
        let personId: number | null = null;

        const byTmdb = await findPersonByTmdbId(member.id);
        if (byTmdb) {
            personId = byTmdb.id;
        } else {
            const byName = await findPersonByNameAndDepartment(
                member.name,
                member.department,
                movieYear
            );

            if (byName) {
                personId = byName.id;
                if (!byName.tmdb_id) {
                    await pool.query(
                        'UPDATE people SET tmdb_id = $1, updated_at = NOW() WHERE id = $2',
                        [member.id, personId]
                    );
                }
            } else {
                personId = await createPerson(
                    member.id,
                    member.name,
                    member.known_for_department,
                    movieTitle,
                    member.job
                );
                stats.created++;
            }
        }

        const roleId = JOB_TO_ROLE_ID[member.job];

        await pool.query(`
      INSERT INTO movie_crew (movie_id, person_id, role_id, billing_order, created_at, updated_at)
      VALUES ($1, $2, $3, $4, NOW(), NOW())
      ON CONFLICT DO NOTHING
    `, [movieId, personId, roleId, null]);

        imported++;
    }

    return imported;
}

// ============================================================================
// FUNCI√ìN DE AN√ÅLISIS DRY-RUN
// ============================================================================

async function analyzeMovieDryRun(
    movie: TMDBMovieDetails,
    title: string,
    movieYear: number
): Promise<{ found: number; create: number; review: number }> {
    const stats = { found: 0, create: 0, review: 0 };

    // Analizar Cast
    const mainCast = movie.credits.cast.slice(0, 20);
    console.log(`\n  üë• CAST (${mainCast.length} personas):`);

    for (const member of mainCast) {
        const result = await analyzePersonMatch(member.id, member.name, 'Acting', movieYear);

        if (result.status === 'found') {
            console.log(`     ‚úì ${member.name} (tmdb:${member.id}) ‚Üí Encontrado: ID ${result.local_id}`);
            stats.found++;
        } else if (result.status === 'create') {
            const genderStr = result.gender ? (result.gender === 'MALE' ? 'M' : 'F') : '?';
            console.log(`     + ${member.name} (tmdb:${member.id}) ‚Üí CREAR: "${result.firstName}" + "${result.lastName}" (${genderStr})`);
            stats.create++;
        } else {
            console.log(`     ‚ö† ${member.name} (tmdb:${member.id}) ‚Üí CREAR: "${result.firstName}" + "${result.lastName}" (?) - ${result.reason}`);
            stats.review++;
        }
    }

    // Analizar Crew
    const importantJobs = ['Director', 'Director of Photography', 'Screenplay', 'Writer',
        'Producer', 'Executive Producer', 'Editor', 'Original Music Composer', 'Music',
        'Production Design', 'Art Direction', 'Costume Design', 'Makeup Artist',
        'Sound Designer', 'Sound Mixer'];

    const relevantCrew = movie.credits.crew.filter(c => importantJobs.includes(c.job));
    const uniqueCrew = new Map<string, TMDBCrewMember>();

    for (const member of relevantCrew) {
        const key = `${member.id}-${member.job}`;
        if (!uniqueCrew.has(key)) {
            uniqueCrew.set(key, member);
        }
    }

    console.log(`\n  üé¨ CREW (${uniqueCrew.size} personas):`);

    for (const [, member] of uniqueCrew) {
        const result = await analyzePersonMatch(member.id, member.name, member.department, movieYear);

        if (result.status === 'found') {
            console.log(`     ‚úì ${member.name} [${member.job}] (tmdb:${member.id}) ‚Üí Encontrado: ID ${result.local_id}`);
            stats.found++;
        } else if (result.status === 'create') {
            const genderStr = result.gender ? (result.gender === 'MALE' ? 'M' : 'F') : '?';
            console.log(`     + ${member.name} [${member.job}] (tmdb:${member.id}) ‚Üí CREAR: "${result.firstName}" + "${result.lastName}" (${genderStr})`);
            stats.create++;
        } else {
            console.log(`     ‚ö† ${member.name} [${member.job}] (tmdb:${member.id}) ‚Üí CREAR: "${result.firstName}" + "${result.lastName}" (?) - ${result.reason}`);
            stats.review++;
        }
    }

    return stats;
}

// ============================================================================
// FUNCI√ìN PRINCIPAL DE IMPORTACI√ìN
// ============================================================================

async function importMovie(tmdbId: number, dryRun: boolean): Promise<ImportResult> {
    const result: ImportResult = {
        tmdb_id: tmdbId,
        title: '',
        status: 'error',
        message: '',
        cast_imported: 0,
        crew_imported: 0,
        people_created: 0,
        people_found: 0,
        people_needs_review: 0,
    };

    try {
        const existingId = await movieExistsByTmdbId(tmdbId);
        if (existingId) {
            result.status = 'skipped';
            result.message = `Ya existe con ID ${existingId}`;
            result.movie_id = existingId;
            return result;
        }

        console.log(`  üì• Obteniendo datos de TMDB...`);
        const movie = await getMovieDetails(tmdbId);
        await sleep(RATE_LIMIT_MS);

        const title = getSpanishTitle(movie);
        const originalSynopsis = getSpanishOverview(movie);
        const isDocumental = movie.genres.some(g => g.id === 99);

        // Reescribir sinopsis con Claude
        let synopsis = originalSynopsis;
        if (originalSynopsis && !dryRun) {
            console.log(`  ‚úçÔ∏è  Reescribiendo sinopsis con Claude...`);
            synopsis = await rewriteSynopsis(originalSynopsis, isDocumental);
        }
        const year = movie.release_date ? parseInt(movie.release_date.split('-')[0]) : new Date().getFullYear();

        result.title = title;

        console.log(`  üìã T√≠tulo: ${title}`);
        console.log(`  üìÖ A√±o: ${year}`);
        console.log(`  ‚è±Ô∏è  Duraci√≥n: ${movie.runtime || 'N/A'} min`);
        console.log(`  üé≠ G√©neros: ${movie.genres.map(g => g.name).join(', ')}`);
        console.log(`  üåç Pa√≠ses: ${movie.production_countries.map(c => c.iso_3166_1).join(', ')}`);

        if (dryRun) {
            // An√°lisis detallado de personas
            const personStats = await analyzeMovieDryRun(movie, title, year);

            result.people_found = personStats.found;
            result.people_created = personStats.create;
            result.people_needs_review = personStats.review;

            console.log(`\n  üìä Resumen personas:`);
            console.log(`     ‚úì Encontradas: ${personStats.found}`);
            console.log(`     + A crear: ${personStats.create}`);
            console.log(`     ‚ö† Requieren revisi√≥n: ${personStats.review}`);

            result.status = 'success';
            result.message = 'DRY RUN - An√°lisis completado';
            return result;
        }

        console.log(`\n  üíæ Creando pel√≠cula...`);
        // Detectar si hay coproducci√≥n (otro pa√≠s adem√°s de Argentina)
        const hasCoproduction = movie.production_countries.some(c => c.iso_3166_1 !== 'AR');
        const movieId = await createMovie(movie, title, synopsis, hasCoproduction);
        result.movie_id = movieId;

        console.log(`  üè∑Ô∏è  Agregando g√©neros...`);
        await addMovieGenres(movieId, movie.genres);

        console.log(`  üåç Agregando pa√≠ses...`);
        await addMovieCountries(movieId, movie.production_countries);

        console.log(`  üë• Importando cast...`);
        const stats = { created: 0 };
        result.cast_imported = await addMovieCast(movieId, movie.credits.cast, year, title, movie.genres, stats);

        console.log(`  üé¨ Importando crew...`);
        result.crew_imported = await addMovieCrew(movieId, movie.credits.crew, year, title, stats);
        result.people_created = stats.created;

        result.status = 'success';
        result.message = `Importada exitosamente`;

    } catch (error) {
        result.status = 'error';
        result.message = error instanceof Error ? error.message : 'Error desconocido';
    }

    return result;
}

// ============================================================================
// PARSEO DE CSV
// ============================================================================

function parseCSV(filePath: string): Array<{ tmdb_id: number; tmdb_title: string }> {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n').filter(line => line.trim());

    const firstLine = lines[0];
    const delimiter = firstLine.includes(';') ? ';' : ',';

    const headers = lines[0].split(delimiter).map(h => h.replace(/"/g, '').replace(/^\uFEFF/, ''));
    const tmdbIdIndex = headers.findIndex(h => h === 'tmdb_id');
    const titleIndex = headers.findIndex(h => h === 'tmdb_title');

    if (tmdbIdIndex === -1) {
        throw new Error('No se encontr√≥ la columna tmdb_id en el CSV');
    }

    const movies: Array<{ tmdb_id: number; tmdb_title: string }> = [];

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(delimiter);
        const tmdbId = parseInt(values[tmdbIdIndex]);
        const title = titleIndex >= 0 ? values[titleIndex]?.replace(/"/g, '') : '';

        if (!isNaN(tmdbId)) {
            movies.push({ tmdb_id: tmdbId, tmdb_title: title });
        }
    }

    return movies;
}

// ============================================================================
// GENERACI√ìN DE REPORTE DE REVISI√ìN
// ============================================================================

function generateReviewReport(): void {
    if (peopleForReview.length === 0) {
        console.log('\n‚úÖ No hay personas que requieran revisi√≥n manual.');
        return;
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const reportPath = path.join(__dirname, 'reports', `people-review-${timestamp}.csv`);

    const reportsDir = path.join(__dirname, 'reports');
    if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
    }

    const headers = ['tmdb_id', 'full_name', 'first_name', 'last_name', 'gender', 'reason', 'movie_title', 'role'];
    const rows = peopleForReview.map(p => [
        p.tmdb_id,
        `"${p.full_name}"`,
        `"${p.first_name}"`,
        `"${p.last_name}"`,
        p.gender || 'NULL',
        `"${p.reason}"`,
        `"${p.movie_title}"`,
        `"${p.role}"`
    ].join(','));

    const csvContent = [headers.join(','), ...rows].join('\n');
    fs.writeFileSync(reportPath, csvContent, 'utf-8');

    console.log(`\nüìã PERSONAS QUE REQUIEREN REVISI√ìN: ${peopleForReview.length}`);
    console.log(`   Reporte guardado en: ${reportPath}`);

    const reasonCounts = new Map<string, number>();
    for (const p of peopleForReview) {
        const count = reasonCounts.get(p.reason) || 0;
        reasonCounts.set(p.reason, count + 1);
    }

    console.log('\n   Resumen por raz√≥n:');
    for (const [reason, count] of reasonCounts) {
        console.log(`   - ${reason}: ${count}`);
    }
}

// ============================================================================
// MAIN
// ============================================================================

async function main(): Promise<void> {
    console.log('üé¨ TMDB Movie Import Script v2.0');
    console.log('================================\n');

    const args = process.argv.slice(2);
    const csvIndex = args.indexOf('--csv');
    const idIndex = args.indexOf('--id');
    const limitIndex = args.indexOf('--limit');
    const dryRun = args.includes('--dry-run');

    let moviesToImport: Array<{ tmdb_id: number; tmdb_title: string }> = [];

    if (idIndex !== -1 && args[idIndex + 1]) {
        const tmdbId = parseInt(args[idIndex + 1]);
        if (isNaN(tmdbId)) {
            console.error('‚ùå ID inv√°lido');
            process.exit(1);
        }
        moviesToImport = [{ tmdb_id: tmdbId, tmdb_title: '' }];
    } else if (csvIndex !== -1 && args[csvIndex + 1]) {
        const csvPath = args[csvIndex + 1];
        if (!fs.existsSync(csvPath)) {
            const reportsPath = path.join(__dirname, 'reports', csvPath);
            if (fs.existsSync(reportsPath)) {
                moviesToImport = parseCSV(reportsPath);
            } else {
                console.error(`‚ùå No se encontr√≥ el archivo: ${csvPath}`);
                process.exit(1);
            }
        } else {
            moviesToImport = parseCSV(csvPath);
        }
    } else {
        console.log('Uso:');
        console.log('  npx tsx import-tmdb-movies.ts --id <tmdb_id>              # Importar una pel√≠cula');
        console.log('  npx tsx import-tmdb-movies.ts --csv <archivo.csv>        # Importar desde CSV');
        console.log('  npx tsx import-tmdb-movies.ts --csv <archivo.csv> --limit 5');
        console.log('  npx tsx import-tmdb-movies.ts --id <tmdb_id> --dry-run   # Solo mostrar qu√© har√≠a');
        process.exit(0);
    }

    if (limitIndex !== -1 && args[limitIndex + 1]) {
        const limit = parseInt(args[limitIndex + 1]);
        if (!isNaN(limit)) {
            moviesToImport = moviesToImport.slice(0, limit);
        }
    }

    console.log(`üìã Pel√≠culas a importar: ${moviesToImport.length}`);
    if (dryRun) {
        console.log('üîç MODO DRY-RUN: No se aplicar√°n cambios\n');
    }

    // Cargar cache de nombres SIEMPRE (para dry-run tambi√©n)
    await loadFirstNameGenderCache();

    const results: ImportResult[] = [];
    const startTime = Date.now();

    for (let i = 0; i < moviesToImport.length; i++) {
        const movie = moviesToImport[i];
        console.log(`\n[${i + 1}/${moviesToImport.length}] üé¨ TMDB ID: ${movie.tmdb_id} - ${movie.tmdb_title || '(sin t√≠tulo)'}`);

        const result = await importMovie(movie.tmdb_id, dryRun);
        results.push(result);

        const statusIcon = result.status === 'success' ? '‚úÖ' :
            result.status === 'skipped' ? '‚è≠Ô∏è' : '‚ùå';
        console.log(`\n  ${statusIcon} ${result.message}`);

        if (result.status === 'success' && !dryRun) {
            console.log(`     ID: ${result.movie_id} | Cast: ${result.cast_imported} | Crew: ${result.crew_imported} | Personas nuevas: ${result.people_created}`);
        }

        await sleep(RATE_LIMIT_MS);
    }

    // Resumen
    const elapsed = Date.now() - startTime;
    const successCount = results.filter(r => r.status === 'success').length;
    const skippedCount = results.filter(r => r.status === 'skipped').length;
    const errorCount = results.filter(r => r.status === 'error').length;

    console.log('\n' + '='.repeat(50));
    console.log('üìä RESUMEN GENERAL');
    console.log('='.repeat(50));
    console.log(`   Total procesadas:    ${results.length}`);
    console.log(`   ‚úÖ Exitosas:         ${successCount}`);
    console.log(`   ‚è≠Ô∏è  Ya exist√≠an:      ${skippedCount}`);
    console.log(`   ‚ùå Errores:          ${errorCount}`);

    if (dryRun) {
        const totalFound = results.reduce((sum, r) => sum + r.people_found, 0);
        const totalCreate = results.reduce((sum, r) => sum + r.people_created, 0);
        const totalReview = results.reduce((sum, r) => sum + r.people_needs_review, 0);

        console.log(`\n   üë• Personas:`);
        console.log(`      ‚úì Encontradas:       ${totalFound}`);
        console.log(`      + A crear:           ${totalCreate}`);
        console.log(`      ‚ö† Requieren revisi√≥n: ${totalReview}`);
    } else {
        const totalPeopleCreated = results.reduce((sum, r) => sum + r.people_created, 0);
        console.log(`   üë§ Personas creadas: ${totalPeopleCreated}`);
    }

    console.log(`   ‚è±Ô∏è  Tiempo:           ${Math.round(elapsed / 1000)}s`);

    if (dryRun) {
        console.log('\nüí° Modo dry-run: Para aplicar cambios, quitar --dry-run');
    }

    // Generar reporte de personas que necesitan revisi√≥n (solo si no es dry-run)
    if (!dryRun) {
        generateReviewReport();
    }

    await closePool();
    console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
    console.error('Error fatal:', error);
    process.exit(1);
});

// ==================================================
// scripts/tmdb/test-connection.ts
// ==================================================
/**
 * Test de conexi√≥n a TMDB y PostgreSQL
 */

import { testConnection, searchMovies, searchPeople } from './tmdb-client';
import { getPool, closePool, log } from './utils';

async function main() {
  console.log('\nüîå Test de Conexiones\n');
  
  // Test TMDB
  log('Probando TMDB API...', 'info');
  const tmdbOk = await testConnection();
  if (tmdbOk) {
    log('TMDB API: OK', 'success');
    
    // Test b√∫squeda de pel√≠cula
    log('Buscando "El secreto de sus ojos"...', 'info');
    const movieSearch = await searchMovies('El secreto de sus ojos', 2009);
    log(`Encontradas ${movieSearch.total_results} pel√≠culas`, 'info');
    if (movieSearch.results.length > 0) {
      const first = movieSearch.results[0];
      log(`  ‚Üí ${first.title} (${first.release_date})`, 'success');
    }
    
    // Test b√∫squeda de persona
    log('Buscando "Ricardo Dar√≠n"...', 'info');
    const personSearch = await searchPeople('Ricardo Dar√≠n');
    log(`Encontradas ${personSearch.total_results} personas`, 'info');
    if (personSearch.results.length > 0) {
      const first = personSearch.results[0];
      log(`  ‚Üí ${first.name} (${first.known_for_department})`, 'success');
    }
  } else {
    log('TMDB API: FALLO', 'error');
  }
  
  console.log('');
  
  // Test PostgreSQL
  log('Probando PostgreSQL...', 'info');
  try {
    const pool = getPool();
    const result = await pool.query('SELECT COUNT(*) as count FROM movies');
    log(`PostgreSQL: OK (${result.rows[0].count} pel√≠culas)`, 'success');
    
    const peopleResult = await pool.query('SELECT COUNT(*) as count FROM people');
    log(`PostgreSQL: OK (${peopleResult.rows[0].count} personas)`, 'success');
  } catch (error) {
    log(`PostgreSQL: FALLO - ${error}`, 'error');
  }
  
  await closePool();
  console.log('\n‚ú® Test completado\n');
}

main().catch(console.error);


// ==================================================
// scripts/tmdb/tmdb-client.ts
// ==================================================
/**
 * TMDB API Client
 * Documentaci√≥n: https://developer.themoviedb.org/reference/intro/getting-started
 */

import config from './config';

// Tipos para respuestas de TMDB
export interface TMDBMovie {
  id: number;
  title: string;
  original_title: string;
  release_date: string; // "YYYY-MM-DD"
  overview: string;
  popularity: number;
  vote_average: number;
  vote_count: number;
  poster_path: string | null;
  backdrop_path: string | null;
  genre_ids: number[];
  original_language: string;
  adult: boolean;
  video: boolean;
}

export interface TMDBMovieDetails extends TMDBMovie {
  imdb_id: string | null;
  runtime: number | null;
  budget: number;
  revenue: number;
  status: string;
  tagline: string;
  production_countries: Array<{ iso_3166_1: string; name: string }>;
  production_companies: Array<{ id: number; name: string; origin_country: string }>;
  spoken_languages: Array<{ iso_639_1: string; name: string }>;
  genres: Array<{ id: number; name: string }>;
  credits?: {
    cast: Array<{
      id: number;
      name: string;
      character: string;
      order: number;
    }>;
    crew: Array<{
      id: number;
      name: string;
      job: string;
      department: string;
    }>;
  };
}

export interface TMDBPerson {
  id: number;
  name: string;
  original_name: string;
  popularity: number;
  profile_path: string | null;
  adult: boolean;
  gender: number; // 0: not specified, 1: female, 2: male, 3: non-binary
  known_for_department: string;
  known_for: TMDBMovie[];
}

export interface TMDBPersonDetails extends TMDBPerson {
  imdb_id: string | null;
  birthday: string | null; // "YYYY-MM-DD"
  deathday: string | null; // "YYYY-MM-DD"
  place_of_birth: string | null;
  biography: string;
  also_known_as: string[];
  homepage: string | null;
  movie_credits?: {
    cast: Array<{
      id: number;
      title: string;
      character: string;
      release_date: string;
    }>;
    crew: Array<{
      id: number;
      title: string;
      job: string;
      department: string;
      release_date: string;
    }>;
  };
}

export interface TMDBSearchResult<T> {
  page: number;
  total_pages: number;
  total_results: number;
  results: T[];
}

// Rate limiting
let lastRequestTime = 0;

async function rateLimitedFetch(url: string, options: RequestInit): Promise<Response> {
  const now = Date.now();
  const timeSinceLastRequest = now - lastRequestTime;
  
  if (timeSinceLastRequest < config.delayBetweenRequests) {
    await new Promise(resolve => setTimeout(resolve, config.delayBetweenRequests - timeSinceLastRequest));
  }
  
  lastRequestTime = Date.now();
  return fetch(url, options);
}

// Headers comunes para todas las requests
function getHeaders(): HeadersInit {
  return {
    'Authorization': `Bearer ${config.tmdbAccessToken}`,
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  };
}

/**
 * Buscar pel√≠culas por t√≠tulo
 */
export async function searchMovies(
  query: string, 
  year?: number,
  page: number = 1
): Promise<TMDBSearchResult<TMDBMovie>> {
  const params = new URLSearchParams({
    query,
    language: 'es-AR',
    page: page.toString(),
    include_adult: 'false',
  });
  
  if (year) {
    params.append('year', year.toString());
  }
  
  const url = `${config.tmdbBaseUrl}/search/movie?${params}`;
  
  const response = await rateLimitedFetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });
  
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
}

/**
 * Obtener detalles de una pel√≠cula (incluye imdb_id)
 */
export async function getMovieDetails(tmdbId: number): Promise<TMDBMovieDetails> {
  const params = new URLSearchParams({
    language: 'es-AR',
    append_to_response: 'credits',
  });
  
  const url = `${config.tmdbBaseUrl}/movie/${tmdbId}?${params}`;
  
  const response = await rateLimitedFetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });
  
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
}

/**
 * Buscar personas por nombre
 */
export async function searchPeople(
  query: string,
  page: number = 1
): Promise<TMDBSearchResult<TMDBPerson>> {
  const params = new URLSearchParams({
    query,
    language: 'es-AR',
    page: page.toString(),
    include_adult: 'false',
  });
  
  const url = `${config.tmdbBaseUrl}/search/person?${params}`;
  
  const response = await rateLimitedFetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });
  
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
}

/**
 * Obtener detalles de una persona (incluye imdb_id)
 */
export async function getPersonDetails(tmdbId: number): Promise<TMDBPersonDetails> {
  const params = new URLSearchParams({
    language: 'es-AR',
    append_to_response: 'movie_credits',
  });
  
  const url = `${config.tmdbBaseUrl}/person/${tmdbId}?${params}`;
  
  const response = await rateLimitedFetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });
  
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
}

/**
 * Test de conexi√≥n a la API
 */
export async function testConnection(): Promise<boolean> {
  try {
    const url = `${config.tmdbBaseUrl}/configuration`;
    const response = await rateLimitedFetch(url, {
      method: 'GET',
      headers: getHeaders(),
    });
    return response.ok;
  } catch (error) {
    console.error('Error testing TMDB connection:', error);
    return false;
  }
}

export default {
  searchMovies,
  getMovieDetails,
  searchPeople,
  getPersonDetails,
  testConnection,
};


// ==================================================
// scripts/tmdb/utils.ts
// ==================================================
/**
 * Utilidades comunes para scripts de enriquecimiento
 */

import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import config from './config';

// Pool de conexi√≥n a PostgreSQL
let pool: Pool | null = null;

export function getPool(): Pool {
  if (!pool) {
    pool = new Pool({
      connectionString: config.databaseUrl,
    });
  }
  return pool;
}

export async function closePool(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = null;
  }
}

/**
 * Normalizar texto para comparaci√≥n
 * - Quita acentos
 * - Convierte a min√∫sculas
 * - Quita caracteres especiales
 */
export function normalizeText(text: string): string {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Quitar acentos
    .replace(/[^a-z0-9\s]/g, ' ')    // Quitar caracteres especiales
    .replace(/\s+/g, ' ')            // Normalizar espacios
    .trim();
}

/**
 * Calcular similitud entre dos strings (0-100)
 * Usa distancia de Levenshtein normalizada
 */
export function stringSimilarity(str1: string, str2: string): number {
  const s1 = normalizeText(str1);
  const s2 = normalizeText(str2);
  
  if (s1 === s2) return 100;
  if (s1.length === 0 || s2.length === 0) return 0;
  
  const matrix: number[][] = [];
  
  for (let i = 0; i <= s1.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= s2.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,      // deletion
        matrix[i][j - 1] + 1,      // insertion
        matrix[i - 1][j - 1] + cost // substitution
      );
    }
  }
  
  const distance = matrix[s1.length][s2.length];
  const maxLength = Math.max(s1.length, s2.length);
  return Math.round((1 - distance / maxLength) * 100);
}

/**
 * Parsear fecha de TMDB (YYYY-MM-DD) a objeto
 */
export function parseTMDBDate(dateStr: string | null): { year: number | null; month: number | null; day: number | null } {
  if (!dateStr) return { year: null, month: null, day: null };
  
  const parts = dateStr.split('-');
  return {
    year: parts[0] ? parseInt(parts[0]) : null,
    month: parts[1] ? parseInt(parts[1]) : null,
    day: parts[2] ? parseInt(parts[2]) : null,
  };
}

/**
 * Comparar fechas parciales
 * Retorna puntuaci√≥n: 0-100 basado en coincidencia
 */
export function compareDates(
  date1: { year: number | null; month: number | null; day: number | null },
  date2: { year: number | null; month: number | null; day: number | null }
): number {
  if (!date1.year || !date2.year) return 0;
  
  let score = 0;
  
  // A√±o coincide: 50 puntos
  if (date1.year === date2.year) {
    score += 50;
    
    // Si ambos tienen mes y coincide: 30 puntos m√°s
    if (date1.month && date2.month && date1.month === date2.month) {
      score += 30;
      
      // Si ambos tienen d√≠a y coincide: 20 puntos m√°s
      if (date1.day && date2.day && date1.day === date2.day) {
        score += 20;
      }
    }
  } else if (Math.abs(date1.year - date2.year) === 1) {
    // Un a√±o de diferencia: 20 puntos (puede ser error de datos)
    score += 20;
  }
  
  return score;
}

/**
 * Verificar si un lugar contiene "Argentina"
 */
export function isArgentineLocation(place: string | null): boolean {
  if (!place) return false;
  const normalized = normalizeText(place);
  return normalized.includes('argentina') || 
         normalized.includes('buenos aires') ||
         normalized.includes('cordoba') ||
         normalized.includes('rosario') ||
         normalized.includes('mendoza');
}

/**
 * Guardar resultados en CSV
 */
export function saveToCSV(
  data: Record<string, any>[],
  filename: string,
  headers: string[]
): void {
  const reportsDir = path.join(__dirname, 'reports');
  
  if (!fs.existsSync(reportsDir)) {
    fs.mkdirSync(reportsDir, { recursive: true });
  }
  
  const filepath = path.join(reportsDir, filename);
  
  // Escapar valores CSV
  const escapeCSV = (value: any): string => {
    if (value === null || value === undefined) return '';
    const str = String(value);
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };
  
  const lines = [
    headers.join(','),
    ...data.map(row => headers.map(h => escapeCSV(row[h])).join(','))
  ];
  
  fs.writeFileSync(filepath, lines.join('\n'), 'utf-8');
  console.log(`‚úÖ Guardado: ${filepath} (${data.length} registros)`);
}

/**
 * Parsear una l√≠nea CSV respetando comillas
 */
function parseCSVLine(line: string): string[] {
  const values: string[] = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    const nextChar = line[i + 1];
    
    if (inQuotes) {
      if (char === '"' && nextChar === '"') {
        // Comilla escapada
        current += '"';
        i++;
      } else if (char === '"') {
        // Fin de campo entrecomillado
        inQuotes = false;
      } else {
        current += char;
      }
    } else {
      if (char === '"') {
        // Inicio de campo entrecomillado
        inQuotes = true;
      } else if (char === ',') {
        // Fin de campo
        values.push(current);
        current = '';
      } else {
        current += char;
      }
    }
  }
  
  // √öltimo campo
  values.push(current);
  
  return values;
}

/**
 * Cargar CSV existente
 */
export function loadFromCSV(filename: string): Record<string, any>[] {
  const filepath = path.join(__dirname, 'reports', filename);
  
  if (!fs.existsSync(filepath)) {
    return [];
  }
  
  const content = fs.readFileSync(filepath, 'utf-8');
  const lines = content.split('\n').filter(l => l.trim());
  
  if (lines.length < 2) return [];
  
  const headers = parseCSVLine(lines[0]);
  const data: Record<string, any>[] = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]);
    const row: Record<string, any> = {};
    headers.forEach((h, idx) => {
      row[h] = values[idx] || '';
    });
    data.push(row);
  }
  
  return data;
}

/**
 * Formatear duraci√≥n para logging
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

/**
 * Progress bar simple para consola
 */
export function progressBar(current: number, total: number, width: number = 40): string {
  const percentage = Math.round((current / total) * 100);
  const filled = Math.round((current / total) * width);
  const empty = width - filled;
  
  return `[${'‚ñà'.repeat(filled)}${'‚ñë'.repeat(empty)}] ${percentage}% (${current}/${total})`;
}

/**
 * Logger con timestamp
 */
export function log(message: string, level: 'info' | 'warn' | 'error' | 'success' = 'info'): void {
  const timestamp = new Date().toISOString().slice(11, 19);
  const icons = {
    info: '‚ÑπÔ∏è',
    warn: '‚ö†Ô∏è',
    error: '‚ùå',
    success: '‚úÖ',
  };
  console.log(`[${timestamp}] ${icons[level]} ${message}`);
}

export default {
  getPool,
  closePool,
  normalizeText,
  stringSimilarity,
  parseTMDBDate,
  compareDates,
  isArgentineLocation,
  saveToCSV,
  loadFromCSV,
  formatDuration,
  progressBar,
  log,
};

// ==================================================
// scripts/tmdb-daily-detector.ts
// ==================================================
/**
 * TMDB Daily Detector v2.1
 * 
 * Script que detecta pel√≠culas argentinas nuevas en TMDB bas√°ndose en IDs.
 * Guarda el √∫ltimo ID procesado para retomar en la pr√≥xima ejecuci√≥n.
 * 
 * Uso:
 *   npx tsx scripts/tmdb-daily-detector.ts                    # Ejecutar desde √∫ltimo ID guardado
 *   npx tsx scripts/tmdb-daily-detector.ts --from-id 1619544  # Empezar desde ID espec√≠fico
 *   npx tsx scripts/tmdb-daily-detector.ts --dry-run          # Solo mostrar, no guardar
 *   npx tsx scripts/tmdb-daily-detector.ts --limit 1000       # Procesar m√°ximo 1000 IDs
 */

import { Pool } from 'pg';

// ============================================================================
// CONFIGURACI√ìN
// ============================================================================

const config = {
    tmdbAccessToken: process.env.TMDB_ACCESS_TOKEN || 'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkZWU4NjYxYmU4NDc4YzQ2ODljOWZmYTVmMTAzOGY4ZiIsIm5iZiI6MTU3NDIxMjg5NC41MzMsInN1YiI6IjVkZDQ5NTFlMzU2YTcxNTg3NWViM2RmNyIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.nhpEuKh4uyr4Mp0avMqNmGuwPC2cj0byvHJaAsGIdkE',
    tmdbBaseUrl: 'https://api.themoviedb.org/3',
    databaseUrl: process.env.DATABASE_URL || 'postgresql://cinenacional:Paganitzu@localhost:5432/cinenacional',
    telegramBotToken: process.env.TELEGRAM_BOT_TOKEN || '7690309153:AAEa3LZ1o-f5NayeOHwtjyuQ1BfY6LRj6s0',
    telegramChatId: process.env.TELEGRAM_CHAT_ID || '1414789486',
    
    // Configuraci√≥n de b√∫squeda por ID
    delayBetweenRequests: 30,   // ms entre requests a TMDB (m√°s r√°pido porque muchos ser√°n 404)
    defaultLimit: 5000,         // M√°ximo de IDs a procesar por ejecuci√≥n
    
    // Umbrales de matching
    matching: {
        exactMatchThreshold: 90,   // Score >= 90: match exacto, asignar autom√°ticamente
        fuzzyMatchThreshold: 60,   // Score 60-89: match dudoso, preguntar
        yearTolerance: 1,          // ¬±1 a√±o de tolerancia
    },
    
    // Rol de director
    directorRoleId: 2,
};

// ============================================================================
// TIPOS
// ============================================================================

interface TMDBMovie {
    id: number;
    title: string;
    original_title: string;
    overview: string;
    release_date: string;
    runtime: number | null;
    genre_ids?: number[];
    adult: boolean;
    popularity: number;
    status: string;
}

interface TMDBMovieDetails extends TMDBMovie {
    credits: {
        crew: Array<{
            id: number;
            name: string;
            job: string;
            department: string;
        }>;
    };
    production_countries: Array<{
        iso_3166_1: string;
        name: string;
    }>;
}

interface LocalMovie {
    id: number;
    title: string;
    year: number | null;
    tmdb_id: number | null;
    director_name: string | null;
    director_tmdb_id: number | null;
}

interface PendingMovie {
    tmdb_id: number;
    tmdb_title: string;
    tmdb_original_title: string | null;
    tmdb_year: number | null;
    tmdb_release_date: string | null;
    tmdb_overview: string | null;
    tmdb_runtime: number | null;
    tmdb_popularity: number | null;
    tmdb_status: string | null;
    tmdb_director_name: string | null;
    tmdb_director_id: number | null;
    local_movie_id: number | null;
    local_movie_title: string | null;
    local_movie_year: number | null;
    local_director_name: string | null;
    action_type: 'match_exact' | 'match_fuzzy' | 'no_match';
    match_score: number | null;
}

// ============================================================================
// POOL DE CONEXI√ìN
// ============================================================================

let pool: Pool | null = null;

function getPool(): Pool {
    if (!pool) {
        pool = new Pool({
            connectionString: config.databaseUrl,
            max: 5,
            idleTimeoutMillis: 30000,
        });
    }
    return pool;
}

async function closePool(): Promise<void> {
    if (pool) {
        await pool.end();
        pool = null;
    }
}

// ============================================================================
// FUNCIONES DE ESTADO (√öLTIMO ID PROCESADO)
// ============================================================================

/**
 * Crea la tabla de estado si no existe
 */
async function ensureSyncStateTable(): Promise<void> {
    const pool = getPool();
    await pool.query(`
        CREATE TABLE IF NOT EXISTS tmdb_sync_state (
            id SERIAL PRIMARY KEY,
            key VARCHAR(50) UNIQUE NOT NULL,
            value_int BIGINT,
            value_text TEXT,
            updated_at TIMESTAMP DEFAULT NOW()
        )
    `);
}

/**
 * Obtiene el √∫ltimo ID procesado de la BD
 */
async function getLastProcessedId(): Promise<number | null> {
    const pool = getPool();
    const result = await pool.query(
        "SELECT value_int FROM tmdb_sync_state WHERE key = 'last_processed_tmdb_id'"
    );
    return result.rows.length > 0 ? Number(result.rows[0].value_int) : null;
}

/**
 * Guarda el √∫ltimo ID procesado en la BD
 */
async function saveLastProcessedId(id: number): Promise<void> {
    const pool = getPool();
    await pool.query(`
        INSERT INTO tmdb_sync_state (key, value_int, updated_at)
        VALUES ('last_processed_tmdb_id', $1, NOW())
        ON CONFLICT (key) DO UPDATE SET
            value_int = EXCLUDED.value_int,
            updated_at = NOW()
    `, [id]);
}

// ============================================================================
// FUNCIONES DE API TMDB
// ============================================================================

async function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchTMDB<T>(endpoint: string, params: Record<string, string> = {}): Promise<T> {
    const url = new URL(`${config.tmdbBaseUrl}${endpoint}`);
    Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value));

    const response = await fetch(url.toString(), {
        headers: {
            'Authorization': `Bearer ${config.tmdbAccessToken}`,
            'Content-Type': 'application/json',
        },
    });

    if (!response.ok) {
        throw new Error(`TMDB API error: ${response.status} ${response.statusText}`);
    }

    return response.json();
}

/**
 * Obtiene el √∫ltimo ID de pel√≠cula en TMDB
 */
async function getLatestTMDBId(): Promise<number> {
    const response = await fetchTMDB<{ id: number }>('/movie/latest');
    return response.id;
}

/**
 * Obtiene detalles de una pel√≠cula de TMDB
 * Retorna null si no existe (404)
 */
async function getMovieDetails(tmdbId: number): Promise<TMDBMovieDetails | null> {
    try {
        return await fetchTMDB<TMDBMovieDetails>(`/movie/${tmdbId}`, {
            append_to_response: 'credits',
            language: 'es-ES',
        });
    } catch (error: any) {
        // Los 404 son esperados (IDs que no existen), no logueamos
        if (error.message?.includes('404')) {
            return null;
        }
        // Otros errores s√≠ los logueamos
        console.log(`   ‚ö†Ô∏è Error obteniendo TMDB ID ${tmdbId}: ${error.message}`);
        return null;
    }
}

/**
 * Verifica si una pel√≠cula es argentina
 */
function isArgentineMovie(movie: TMDBMovieDetails): boolean {
    return movie.production_countries?.some(c => c.iso_3166_1 === 'AR') || false;
}

/**
 * Obtiene el director de una pel√≠cula
 */
function getDirector(movie: TMDBMovieDetails): { name: string; id: number } | null {
    const director = movie.credits?.crew?.find(c => c.job === 'Director');
    return director ? { name: director.name, id: director.id } : null;
}

// ============================================================================
// FUNCIONES DE BASE DE DATOS LOCAL
// ============================================================================

/**
 * Verifica si ya tenemos una pel√≠cula por tmdb_id
 */
async function movieExistsByTmdbId(tmdbId: number): Promise<boolean> {
    const pool = getPool();
    const result = await pool.query(
        'SELECT id FROM movies WHERE tmdb_id = $1',
        [tmdbId]
    );
    return result.rows.length > 0;
}

/**
 * Verifica si ya tenemos esta pel√≠cula en pending
 */
async function isPendingMovie(tmdbId: number): Promise<boolean> {
    const pool = getPool();
    const result = await pool.query(
        "SELECT id FROM tmdb_pending_movies WHERE tmdb_id = $1 AND status = 'pending'",
        [tmdbId]
    );
    return result.rows.length > 0;
}

/**
 * Busca pel√≠culas locales que podr√≠an hacer match
 */
async function findPotentialMatches(
    title: string,
    originalTitle: string | null,
    year: number | null
): Promise<LocalMovie[]> {
    const pool = getPool();
    
    // Normalizar t√≠tulos para comparaci√≥n
    const normalizedTitle = normalizeTitle(title);
    const normalizedOriginal = originalTitle ? normalizeTitle(originalTitle) : null;
    
    // Buscar por t√≠tulo similar y a√±o cercano
    const yearCondition = year 
        ? `AND (m.year BETWEEN $2 AND $3 OR m.year IS NULL)`
        : '';
    
    const query = `
        SELECT 
            m.id,
            m.title,
            m.year,
            m.tmdb_id,
            CONCAT(p.first_name, ' ', p.last_name) as director_name,
            p.tmdb_id as director_tmdb_id
        FROM movies m
        LEFT JOIN movie_crew mc ON m.id = mc.movie_id AND mc.role_id = $1
        LEFT JOIN people p ON mc.person_id = p.id
        WHERE m.tmdb_id IS NULL
        ${yearCondition}
        ORDER BY m.year DESC
        LIMIT 100
    `;
    
    const params: (number | string)[] = [config.directorRoleId];
    if (year) {
        params.push(year - config.matching.yearTolerance);
        params.push(year + config.matching.yearTolerance);
    }
    
    const result = await pool.query(query, params);
    
    // Filtrar por similitud de t√≠tulo
    const matches: LocalMovie[] = [];
    for (const row of result.rows) {
        const localNormalized = normalizeTitle(row.title);
        const titleScore = calculateSimilarity(normalizedTitle, localNormalized);
        const originalScore = normalizedOriginal 
            ? calculateSimilarity(normalizedOriginal, localNormalized)
            : 0;
        
        const maxScore = Math.max(titleScore, originalScore);
        
        if (maxScore >= config.matching.fuzzyMatchThreshold) {
            matches.push({
                id: row.id,
                title: row.title,
                year: row.year,
                tmdb_id: row.tmdb_id,
                director_name: row.director_name,
                director_tmdb_id: row.director_tmdb_id,
            });
        }
    }
    
    return matches;
}

/**
 * Normaliza un t√≠tulo para comparaci√≥n
 */
function normalizeTitle(title: string): string {
    return title
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')  // Quitar acentos
        .replace(/[^a-z0-9\s]/g, '')       // Solo alfanum√©ricos
        .replace(/\s+/g, ' ')              // Normalizar espacios
        .trim();
}

/**
 * Calcula la similitud entre dos strings (0-100)
 * Usa distancia de Levenshtein normalizada
 */
function calculateSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 100;
    if (!str1 || !str2) return 0;
    
    const len1 = str1.length;
    const len2 = str2.length;
    
    // Matriz de distancia
    const matrix: number[][] = [];
    
    for (let i = 0; i <= len1; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,      // deletion
                matrix[i][j - 1] + 1,      // insertion
                matrix[i - 1][j - 1] + cost // substitution
            );
        }
    }
    
    const distance = matrix[len1][len2];
    const maxLen = Math.max(len1, len2);
    
    return Math.round((1 - distance / maxLen) * 100);
}

/**
 * Calcula el score de match considerando t√≠tulo, a√±o y director
 */
function calculateMatchScore(
    tmdbMovie: TMDBMovieDetails,
    localMovie: LocalMovie,
    tmdbDirector: { name: string; id: number } | null
): number {
    let score = 0;
    
    // Score por t√≠tulo (m√°x 50 puntos)
    const titleSimilarity = Math.max(
        calculateSimilarity(normalizeTitle(tmdbMovie.title), normalizeTitle(localMovie.title)),
        calculateSimilarity(normalizeTitle(tmdbMovie.original_title), normalizeTitle(localMovie.title))
    );
    score += titleSimilarity * 0.5;
    
    // Score por a√±o (m√°x 25 puntos)
    const tmdbYear = tmdbMovie.release_date ? parseInt(tmdbMovie.release_date.split('-')[0]) : null;
    if (tmdbYear && localMovie.year) {
        const yearDiff = Math.abs(tmdbYear - localMovie.year);
        if (yearDiff === 0) score += 25;
        else if (yearDiff === 1) score += 15;
        else if (yearDiff === 2) score += 5;
    }
    
    // Score por director (m√°x 25 puntos)
    if (tmdbDirector && localMovie.director_name) {
        // Match por tmdb_id del director
        if (localMovie.director_tmdb_id && localMovie.director_tmdb_id === tmdbDirector.id) {
            score += 25;
        } else {
            // Match por nombre del director
            const directorSimilarity = calculateSimilarity(
                normalizeTitle(tmdbDirector.name),
                normalizeTitle(localMovie.director_name)
            );
            score += directorSimilarity * 0.25;
        }
    }
    
    return Math.round(score);
}

// ============================================================================
// FUNCIONES DE TELEGRAM
// ============================================================================

async function sendTelegramMessage(
    text: string,
    buttons?: Array<Array<{ text: string; callback_data: string }>>
): Promise<number | null> {
    try {
        const body: Record<string, unknown> = {
            chat_id: config.telegramChatId,
            text,
            parse_mode: 'HTML',
        };
        
        if (buttons) {
            body.reply_markup = {
                inline_keyboard: buttons,
            };
        }
        
        const response = await fetch(
            `https://api.telegram.org/bot${config.telegramBotToken}/sendMessage`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            }
        );
        
        if (!response.ok) {
            const error = await response.text();
            console.log(`   ‚ö†Ô∏è Error enviando mensaje a Telegram: ${error}`);
            return null;
        }
        
        const data = await response.json();
        return data.result?.message_id || null;
    } catch (error) {
        console.log(`   ‚ö†Ô∏è Error enviando mensaje a Telegram: ${error}`);
        return null;
    }
}

/**
 * Traduce el status de TMDB a espa√±ol
 */
function translateStatus(status: string | null): string {
    if (!status) return '';
    const translations: Record<string, string> = {
        'Released': 'Estrenada',
        'Post Production': 'En postproducci√≥n',
        'In Production': 'En rodaje',
        'Planned': 'En desarrollo',
        'Canceled': 'Cancelada',
        'Rumored': 'Rumor',
    };
    return translations[status] || status;
}

function formatMovieMessage(pending: PendingMovie): string {
    let message = `üé¨ <b>Nueva pel√≠cula argentina en TMDB</b>\n\n`;
    message += `<b>T√≠tulo:</b> ${pending.tmdb_title}\n`;
    
    if (pending.tmdb_original_title && pending.tmdb_original_title !== pending.tmdb_title) {
        message += `<b>T√≠tulo original:</b> ${pending.tmdb_original_title}\n`;
    }
    
    if (pending.tmdb_year) {
        message += `<b>A√±o:</b> ${pending.tmdb_year}\n`;
    }
    
    if (pending.tmdb_release_date) {
        message += `<b>Estreno:</b> ${pending.tmdb_release_date}\n`;
    }
    
    if (pending.tmdb_director_name) {
        message += `<b>Director:</b> ${pending.tmdb_director_name}\n`;
    }
    
    if (pending.tmdb_runtime) {
        message += `<b>Duraci√≥n:</b> ${pending.tmdb_runtime} min\n`;
    }
    
    if (pending.tmdb_status && pending.tmdb_status !== 'Released') {
        message += `<b>Estado:</b> ${translateStatus(pending.tmdb_status)}\n`;
    }
    
    if (pending.tmdb_popularity) {
        message += `<b>Popularidad:</b> ${pending.tmdb_popularity.toFixed(1)}\n`;
    }
    
    message += `\nüîó <a href="https://www.themoviedb.org/movie/${pending.tmdb_id}">Ver en TMDB</a>\n`;
    
    if (pending.action_type === 'match_fuzzy' && pending.local_movie_id) {
        message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        message += `‚ö†Ô∏è <b>Posible match encontrado:</b>\n\n`;
        message += `<b>En tu BD:</b> ${pending.local_movie_title}`;
        if (pending.local_movie_year) {
            message += ` (${pending.local_movie_year})`;
        }
        message += `\n`;
        if (pending.local_director_name) {
            message += `<b>Director:</b> ${pending.local_director_name}\n`;
        }
        message += `<b>Score:</b> ${pending.match_score}%\n`;
        message += `\nüîó <a href="https://cinenacional.com/admin/movies?id=${pending.local_movie_id}">Ver en CineNacional</a>`;
    } else if (pending.action_type === 'no_match') {
        message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        message += `‚ùì <b>No se encontr√≥ en tu base de datos</b>`;
    }
    
    return message;
}

function getMessageButtons(pending: PendingMovie): Array<Array<{ text: string; callback_data: string }>> {
    if (pending.action_type === 'match_fuzzy') {
        return [
            [
                { text: '‚úÖ Es match - Asignar TMDB ID', callback_data: `confirm_match:${pending.tmdb_id}` },
            ],
            [
                { text: '‚ùå No es match', callback_data: `reject_match:${pending.tmdb_id}` },
            ],
            [
                { text: 'üì• Importar como nueva', callback_data: `import_new:${pending.tmdb_id}` },
            ],
        ];
    } else {
        // no_match
        return [
            [
                { text: '‚úÖ Importar pel√≠cula', callback_data: `import_new:${pending.tmdb_id}` },
            ],
            [
                { text: '‚ùå No importar', callback_data: `reject_import:${pending.tmdb_id}` },
            ],
        ];
    }
}

// ============================================================================
// FUNCIONES PRINCIPALES
// ============================================================================

async function savePendingMovie(pending: PendingMovie): Promise<number> {
    const pool = getPool();
    
    const result = await pool.query(`
        INSERT INTO tmdb_pending_movies (
            tmdb_id, tmdb_title, tmdb_original_title, tmdb_year, tmdb_release_date,
            tmdb_overview, tmdb_runtime, tmdb_popularity, tmdb_status,
            tmdb_director_name, tmdb_director_id,
            local_movie_id, local_movie_title, local_movie_year, local_director_name,
            action_type, match_score, status
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, 'pending')
        ON CONFLICT (tmdb_id) DO UPDATE SET
            tmdb_title = EXCLUDED.tmdb_title,
            tmdb_release_date = EXCLUDED.tmdb_release_date,
            tmdb_popularity = EXCLUDED.tmdb_popularity,
            tmdb_status = EXCLUDED.tmdb_status,
            local_movie_id = EXCLUDED.local_movie_id,
            match_score = EXCLUDED.match_score,
            action_type = EXCLUDED.action_type,
            status = 'pending'
        RETURNING id
    `, [
        pending.tmdb_id,
        pending.tmdb_title,
        pending.tmdb_original_title,
        pending.tmdb_year,
        pending.tmdb_release_date,
        pending.tmdb_overview,
        pending.tmdb_runtime,
        pending.tmdb_popularity,
        pending.tmdb_status,
        pending.tmdb_director_name,
        pending.tmdb_director_id,
        pending.local_movie_id,
        pending.local_movie_title,
        pending.local_movie_year,
        pending.local_director_name,
        pending.action_type,
        pending.match_score,
    ]);
    
    return result.rows[0].id;
}

async function updatePendingMessageId(pendingId: number, messageId: number): Promise<void> {
    const pool = getPool();
    await pool.query(
        'UPDATE tmdb_pending_movies SET telegram_message_id = $1 WHERE id = $2',
        [messageId, pendingId]
    );
}

async function assignTmdbId(localMovieId: number, tmdbId: number): Promise<void> {
    const pool = getPool();
    await pool.query(
        'UPDATE movies SET tmdb_id = $1, updated_at = NOW() WHERE id = $2',
        [tmdbId, localMovieId]
    );
    console.log(`   ‚úÖ Asignado TMDB ID ${tmdbId} a pel√≠cula local ${localMovieId}`);
}

async function processMovie(tmdbId: number, dryRun: boolean): Promise<'skipped' | 'not_found' | 'not_argentine' | 'processed'> {
    // Verificar si ya lo tenemos con este tmdb_id
    if (await movieExistsByTmdbId(tmdbId)) {
        return 'skipped';
    }
    
    // Verificar si ya est√° pendiente
    if (await isPendingMovie(tmdbId)) {
        return 'skipped';
    }
    
    // Obtener detalles de TMDB
    const movie = await getMovieDetails(tmdbId);
    if (!movie) {
        return 'not_found';
    }
    
    // Filtrar pel√≠culas para adultos
    if (movie.adult) {
        return 'skipped';
    }
    
    // Verificar si es argentina
    if (!isArgentineMovie(movie)) {
        return 'not_argentine';
    }
    
    const year = movie.release_date ? parseInt(movie.release_date.split('-')[0]) : null;
    const director = getDirector(movie);
    
    console.log(`\nüá¶üá∑ Pel√≠cula argentina: ${movie.title} (${year || 'sin a√±o'}) - TMDB ID: ${tmdbId}`);
    if (director) {
        console.log(`   Director: ${director.name}`);
    }
    if (movie.status && movie.status !== 'Released') {
        console.log(`   Estado: ${movie.status}`);
    }
    
    // Buscar matches potenciales
    const matches = await findPotentialMatches(movie.title, movie.original_title, year);
    
    let bestMatch: LocalMovie | null = null;
    let bestScore = 0;
    
    for (const match of matches) {
        const score = calculateMatchScore(movie, match, director);
        if (score > bestScore) {
            bestScore = score;
            bestMatch = match;
        }
    }
    
    // Determinar tipo de acci√≥n
    let actionType: 'match_exact' | 'match_fuzzy' | 'no_match';
    
    if (bestMatch && bestScore >= config.matching.exactMatchThreshold) {
        actionType = 'match_exact';
        console.log(`   üéØ Match exacto encontrado: "${bestMatch.title}" (score: ${bestScore}%)`);
        
        if (!dryRun) {
            // Asignar TMDB ID autom√°ticamente
            await assignTmdbId(bestMatch.id, tmdbId);
            
            // Notificar por Telegram
            await sendTelegramMessage(
                `‚úÖ <b>Match autom√°tico</b>\n\n` +
                `<b>TMDB:</b> ${movie.title} (${year})\n` +
                `<b>Local:</b> ${bestMatch.title} (${bestMatch.year})\n` +
                `<b>Score:</b> ${bestScore}%\n\n` +
                `Se asign√≥ TMDB ID ${tmdbId} autom√°ticamente.`
            );
        }
    } else if (bestMatch && bestScore >= config.matching.fuzzyMatchThreshold) {
        actionType = 'match_fuzzy';
        console.log(`   ‚ö†Ô∏è Match dudoso encontrado: "${bestMatch.title}" (score: ${bestScore}%)`);
    } else {
        actionType = 'no_match';
        console.log(`   ‚ùì Sin match en base de datos local`);
    }
    
    // Si no es match exacto, guardar para confirmaci√≥n
    if (actionType !== 'match_exact') {
        const pending: PendingMovie = {
            tmdb_id: tmdbId,
            tmdb_title: movie.title,
            tmdb_original_title: movie.original_title !== movie.title ? movie.original_title : null,
            tmdb_year: year,
            tmdb_release_date: movie.release_date || null,
            tmdb_overview: movie.overview || null,
            tmdb_runtime: movie.runtime,
            tmdb_popularity: movie.popularity || null,
            tmdb_status: movie.status || null,
            tmdb_director_name: director?.name || null,
            tmdb_director_id: director?.id || null,
            local_movie_id: bestMatch?.id || null,
            local_movie_title: bestMatch?.title || null,
            local_movie_year: bestMatch?.year || null,
            local_director_name: bestMatch?.director_name || null,
            action_type: actionType,
            match_score: bestMatch ? bestScore : null,
        };
        
        if (!dryRun) {
            // Guardar en BD
            const pendingId = await savePendingMovie(pending);
            
            // Enviar a Telegram
            const message = formatMovieMessage(pending);
            const buttons = getMessageButtons(pending);
            const messageId = await sendTelegramMessage(message, buttons);
            
            if (messageId) {
                await updatePendingMessageId(pendingId, messageId);
            }
        }
    }
    
    return 'processed';
}

// ============================================================================
// MAIN
// ============================================================================

async function main(): Promise<void> {
    console.log('üé¨ TMDB Daily Detector v2.1 (ID-based)');
    console.log('=======================================\n');
    
    const args = process.argv.slice(2);
    const fromIdIndex = args.indexOf('--from-id');
    const limitIndex = args.indexOf('--limit');
    const dryRun = args.includes('--dry-run');
    
    let startFromId: number | null = null;
    if (fromIdIndex !== -1 && args[fromIdIndex + 1]) {
        startFromId = parseInt(args[fromIdIndex + 1]);
    }
    
    let limit = config.defaultLimit;
    if (limitIndex !== -1 && args[limitIndex + 1]) {
        limit = parseInt(args[limitIndex + 1]) || limit;
    }
    
    if (dryRun) {
        console.log('üîç MODO DRY-RUN: No se guardar√°n cambios\n');
    }
    
    try {
        // Asegurar que existe la tabla de estado
        await ensureSyncStateTable();
        
        // Obtener √∫ltimo ID procesado
        let lastProcessedId = startFromId || await getLastProcessedId();
        
        if (!lastProcessedId) {
            console.log('‚ö†Ô∏è No hay ID inicial guardado.');
            console.log('   Usa --from-id XXXXXX para especificar desde d√≥nde empezar.');
            console.log('   Ejemplo: npx tsx scripts/tmdb-daily-detector.ts --from-id 1619544\n');
            return;
        }
        
        // Obtener √∫ltimo ID de TMDB
        console.log('üì° Obteniendo √∫ltimo ID de TMDB...');
        const latestTmdbId = await getLatestTMDBId();
        console.log(`   √öltimo ID en TMDB: ${latestTmdbId}`);
        console.log(`   √öltimo ID procesado: ${lastProcessedId}`);
        
        const idsToProcess = latestTmdbId - lastProcessedId;
        console.log(`   IDs por procesar: ${idsToProcess}\n`);
        
        if (idsToProcess <= 0) {
            console.log('‚úÖ Ya est√°s actualizado. No hay IDs nuevos para procesar.\n');
            return;
        }
        
        const actualLimit = Math.min(idsToProcess, limit);
        const endId = lastProcessedId + actualLimit;
        
        console.log(`üöÄ Procesando IDs del ${lastProcessedId + 1} al ${endId} (${actualLimit} IDs)...\n`);
        
        // Estad√≠sticas
        let stats = {
            processed: 0,
            notFound: 0,
            notArgentine: 0,
            skipped: 0,
            argentine: 0,
        };
        
        let lastSuccessfulId = lastProcessedId;
        
        for (let id = lastProcessedId + 1; id <= endId; id++) {
            // Progreso cada 100 IDs
            if ((id - lastProcessedId) % 100 === 0) {
                const percent = Math.round(((id - lastProcessedId) / actualLimit) * 100);
                console.log(`üìä Progreso: ${id - lastProcessedId}/${actualLimit} (${percent}%) - Argentinas: ${stats.argentine}`);
            }
            
            const result = await processMovie(id, dryRun);
            
            switch (result) {
                case 'not_found':
                    stats.notFound++;
                    break;
                case 'not_argentine':
                    stats.notArgentine++;
                    break;
                case 'skipped':
                    stats.skipped++;
                    break;
                case 'processed':
                    stats.argentine++;
                    break;
            }
            
            stats.processed++;
            lastSuccessfulId = id;
            
            await sleep(config.delayBetweenRequests);
        }
        
        // Guardar √∫ltimo ID procesado
        if (!dryRun) {
            await saveLastProcessedId(lastSuccessfulId);
            console.log(`\nüíæ Guardado √∫ltimo ID procesado: ${lastSuccessfulId}`);
        }
        
        // Resumen
        console.log('\n' + '‚ïê'.repeat(50));
        console.log('üìä RESUMEN');
        console.log('‚ïê'.repeat(50));
        console.log(`   IDs procesados: ${stats.processed}`);
        console.log(`   No encontrados (404): ${stats.notFound}`);
        console.log(`   No argentinas: ${stats.notArgentine}`);
        console.log(`   Ya en BD/Pendientes: ${stats.skipped}`);
        console.log(`   üá¶üá∑ Pel√≠culas argentinas: ${stats.argentine}`);
        console.log('‚ïê'.repeat(50));
        
        if (lastSuccessfulId < latestTmdbId) {
            console.log(`\n‚ö†Ô∏è Quedan ${latestTmdbId - lastSuccessfulId} IDs por procesar.`);
            console.log('   Ejecuta el script nuevamente para continuar.');
        } else {
            console.log('\n‚úÖ ¬°Completado! Todos los IDs procesados.');
        }
        
    } catch (error) {
        console.error('‚ùå Error:', error);
        
        // Notificar error por Telegram
        await sendTelegramMessage(
            `‚ùå <b>Error en TMDB Daily Detector</b>\n\n${error}`
        );
    } finally {
        await closePool();
    }
    
    console.log('\n‚ú® Proceso completado\n');
}

main().catch(error => {
    console.error('Error fatal:', error);
    process.exit(1);
});

// ==================================================
// src/app/(site)/buscar/loading.tsx
// ==================================================
import { Loader2 } from 'lucide-react'

export default function SearchLoading() {
  return (
    <div className="max-w-7xl mx-auto px-4 py-12">
      <div className="flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-gray-400 mr-3" />
        <span className="text-gray-600">Cargando resultados...</span>
      </div>
    </div>
  )
}

// ==================================================
// src/app/(site)/buscar/page.tsx
// ==================================================
// src/app/buscar/page.tsx

'use client'

import { useEffect, useState } from 'react'
import { useSearchParams } from 'next/navigation'
import Link from 'next/link'
import Image from 'next/image'
import { Film, User, Calendar, Search, Loader2 } from 'lucide-react'
import { formatPartialDate } from '@/lib/shared/dateUtils'
import DOMPurify from 'dompurify'

/**
 * Sanitiza HTML permitiendo solo tags de formato b√°sico.
 * √ötil para mostrar previews con it√°licas, negritas, etc.
 */
function sanitizeHtml(html: string): string {
  if (!html) return ''
  if (typeof window === 'undefined') {
    // Fallback para SSR: remover tags peligrosos pero mantener formato
    return html
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
      .replace(/on\w+="[^"]*"/gi, '')
  }
  return DOMPurify.sanitize(html, { 
    ALLOWED_TAGS: ['i', 'em', 'b', 'strong', 'br'],
    ALLOWED_ATTR: []
  })
}

interface SearchPageResult {
  movies: Array<{
    id: number
    slug: string
    title: string
    year?: number
    releaseYear?: number
    releaseMonth?: number
    releaseDay?: number
    posterUrl?: string
    synopsis?: string
    directors?: Array<{
      person: {
        firstName?: string
        lastName?: string
      }
    }>
  }>
  people: Array<{
    id: number
    slug: string
    firstName?: string
    lastName?: string
    photoUrl?: string
    birthYear?: number
    birthMonth?: number
    birthDay?: number
    deathYear?: number
    deathMonth?: number
    deathDay?: number
    biography?: string
    _count?: {
      castRoles: number
      crewRoles: number
    }
  }>
  totalMovies: number
  totalPeople: number
}

/**
 * Obtiene el a√±o a mostrar para una pel√≠cula.
 * Prioridad: a√±o de producci√≥n (year) > a√±o de estreno (releaseYear)
 * Retorna null si ambos est√°n vac√≠os o son 0
 */
function getDisplayYear(movie: { year?: number; releaseYear?: number }): number | null {
  // Prioridad 1: a√±o de producci√≥n
  if (movie.year && movie.year > 0) {
    return movie.year
  }
  
  // Prioridad 2: a√±o de estreno
  if (movie.releaseYear && movie.releaseYear > 0) {
    return movie.releaseYear
  }
  
  // Ninguno disponible
  return null
}

export default function SearchPage() {
  const searchParams = useSearchParams()
  const query = searchParams.get('q') || ''
  const [results, setResults] = useState<SearchPageResult | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [activeTab, setActiveTab] = useState<'all' | 'movies' | 'people'>('all')

  useEffect(() => {
    if (!query) return

    const searchFullResults = async () => {
      setLoading(true)
      setError(null)

      try {
        const response = await fetch(`/api/search/full?q=${encodeURIComponent(query)}`)
        
        if (!response.ok) {
          throw new Error('Error en la b√∫squeda')
        }

        const data = await response.json()
        setResults(data)
      } catch (err) {
        setError('Error al realizar la b√∫squeda. Por favor, intenta de nuevo.')
        console.error('Search error:', err)
      } finally {
        setLoading(false)
      }
    }

    searchFullResults()
  }, [query])

  const getDirectorName = (movie: any) => {
    const director = movie.directors?.[0]?.person
    if (!director) return null
    return `${director.firstName || ''} ${director.lastName || ''}`.trim()
  }

  const getPersonName = (person: any) => {
    return `${person.firstName || ''} ${person.lastName || ''}`.trim()
  }

  /**
   * Formatea las fechas de vida de una persona.
   * - Solo nacimiento: "n. 16 de enero de 1957"
   * - Nacimiento y muerte: "(19 de abril de 1922-12 de diciembre de 2012)"
   * - Solo muerte: "m. 26 de septiembre de 1943"
   */
  const getLifeDates = (person: any): string | null => {
    const hasBirth = !!person.birthYear
    const hasDeath = !!person.deathYear
    
    if (!hasBirth && !hasDeath) return null
    
    const formatDate = (year?: number, month?: number, day?: number): string => {
      return formatPartialDate(
        { year: year ?? null, month: month ?? null, day: day ?? null },
        { monthFormat: 'long' }
      )
    }
    
    if (hasBirth && hasDeath) {
      // Caso: nacimiento y muerte
      const birthStr = formatDate(person.birthYear, person.birthMonth, person.birthDay)
      const deathStr = formatDate(person.deathYear, person.deathMonth, person.deathDay)
      return `(${birthStr}-${deathStr})`
    } else if (hasBirth) {
      // Caso: solo nacimiento
      const birthStr = formatDate(person.birthYear, person.birthMonth, person.birthDay)
      return `n. ${birthStr}`
    } else {
      // Caso: solo muerte
      const deathStr = formatDate(person.deathYear, person.deathMonth, person.deathDay)
      return `m. ${deathStr}`
    }
  }

  const filteredMovies = results?.movies || []
  const filteredPeople = results?.people || []
  const showMovies = activeTab === 'all' || activeTab === 'movies'
  const showPeople = activeTab === 'all' || activeTab === 'people'

  if (!query) {
    return (
      <div className="max-w-7xl mx-auto px-4 py-12">
        <div className="text-center">
          <Search className="w-16 h-16 text-zinc-600 mx-auto mb-4" />
          <h1 className="text-2xl font-bold text-white mb-2">
            Ingresa un t√©rmino de b√∫squeda
          </h1>
          <p className="text-zinc-400">
            Busca pel√≠culas y personas del cine argentino
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-7xl mx-auto px-4 py-8">
      {/* Header de b√∫squeda */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-white mb-2">
          Resultados de b√∫squeda
        </h1>
        <p className="text-zinc-400">
          Buscando: <span className="font-medium text-white">"{query}"</span>
        </p>
        {results && (
          <p className="text-sm text-zinc-500 mt-1">
            {results.totalMovies + results.totalPeople} resultados encontrados
            ({results.totalMovies} pel√≠culas, {results.totalPeople} personas)
          </p>
        )}
      </div>

      {/* Tabs de filtrado */}
      <div className="border-b border-zinc-800 mb-6">
        <nav className="-mb-px flex space-x-8">
          <button
            onClick={() => setActiveTab('all')}
            className={`py-2 px-1 border-b-2 font-medium text-sm transition-colors ${
              activeTab === 'all'
                ? 'border-zinc-400 text-white'
                : 'border-transparent text-zinc-400 hover:text-white hover:border-zinc-600'
            }`}
          >
            Todos
            {results && (
              <span className="ml-2 text-xs">
                ({results.totalMovies + results.totalPeople})
              </span>
            )}
          </button>
          <button
            onClick={() => setActiveTab('movies')}
            className={`py-2 px-1 border-b-2 font-medium text-sm transition-colors ${
              activeTab === 'movies'
                ? 'border-zinc-400 text-white'
                : 'border-transparent text-zinc-400 hover:text-white hover:border-zinc-600'
            }`}
          >
            Pel√≠culas
            {results && (
              <span className="ml-2 text-xs">({results.totalMovies})</span>
            )}
          </button>
          <button
            onClick={() => setActiveTab('people')}
            className={`py-2 px-1 border-b-2 font-medium text-sm transition-colors ${
              activeTab === 'people'
                ? 'border-zinc-400 text-white'
                : 'border-transparent text-zinc-400 hover:text-white hover:border-zinc-600'
            }`}
          >
            Personas
            {results && (
              <span className="ml-2 text-xs">({results.totalPeople})</span>
            )}
          </button>
        </nav>
      </div>

      {/* Contenido */}
      {loading ? (
        <div className="flex items-center justify-center py-12">
          <Loader2 className="w-8 h-8 animate-spin text-zinc-600 mr-3" />
          <span className="text-zinc-400">Buscando...</span>
        </div>
      ) : error ? (
        <div className="text-center py-12">
          <p className="text-red-500">{error}</p>
        </div>
      ) : results && (results.totalMovies > 0 || results.totalPeople > 0) ? (
        <div className="space-y-8">
          {/* Pel√≠culas */}
          {showMovies && filteredMovies.length > 0 && (
            <div>
              {activeTab === 'all' && (
                <h2 className="text-xl font-bold text-white mb-4">
                  Pel√≠culas ({filteredMovies.length})
                </h2>
              )}
              <div className="grid gap-4">
                {filteredMovies.map((movie) => {
                  const displayYear = getDisplayYear(movie)
                  
                  return (
                    <Link
                      key={movie.id}
                      href={`/pelicula/${movie.slug}`}
                      className="bg-zinc-900 rounded-lg hover:bg-zinc-800 transition-colors p-4 flex gap-4 group"
                    >
                      <div className="flex-shrink-0 w-20 h-28 bg-zinc-800 rounded overflow-hidden">
                        {movie.posterUrl ? (
                          <Image
                            src={movie.posterUrl}
                            alt={movie.title}
                            width={80}
                            height={112}
                            className="object-cover w-full h-full"
                          />
                        ) : (
                          <div className="w-full h-full flex items-center justify-center">
                            <Film className="w-8 h-8 text-zinc-600" />
                          </div>
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <h3 className="text-lg font-semibold text-white mb-1 group-hover:text-zinc-300 transition-colors">
                          {movie.title}
                        </h3>
                        <div className="flex items-center gap-4 text-sm text-zinc-400 mb-2">
                          {displayYear && (
                            <span className="flex items-center gap-1">
                              <Calendar className="w-4 h-4" />
                              {displayYear}
                            </span>
                          )}
                          {getDirectorName(movie) && (
                            <span>Dir: {getDirectorName(movie)}</span>
                          )}
                        </div>
                        {movie.synopsis && (
                          <p 
                            className="text-sm text-zinc-400 line-clamp-2"
                            dangerouslySetInnerHTML={{ __html: sanitizeHtml(movie.synopsis) }}
                          />
                        )}
                      </div>
                    </Link>
                  )
                })}
              </div>
            </div>
          )}

          {/* Personas */}
          {showPeople && filteredPeople.length > 0 && (
            <div>
              {activeTab === 'all' && (
                <h2 className="text-xl font-bold text-white mb-4">
                  Personas ({filteredPeople.length})
                </h2>
              )}
              <div className="grid gap-4 md:grid-cols-2">
                {filteredPeople.map((person) => (
                  <Link
                    key={person.id}
                    href={`/persona/${person.slug}`}
                    className="bg-zinc-900 rounded-lg hover:bg-zinc-800 transition-colors p-4 flex gap-4 group"
                  >
                    <div className="flex-shrink-0 w-20 h-20 bg-zinc-800 rounded-full overflow-hidden">
                      {person.photoUrl ? (
                        <Image
                          src={person.photoUrl}
                          alt={getPersonName(person)}
                          width={80}
                          height={80}
                          className="object-cover w-full h-full"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center">
                          <User className="w-8 h-8 text-zinc-600" />
                        </div>
                      )}
                    </div>
                    <div className="flex-1 min-w-0">
                      <h3 className="text-lg font-semibold text-white mb-1 group-hover:text-zinc-300 transition-colors">
                        {getPersonName(person)}
                      </h3>
                      {getLifeDates(person) && (
                        <p className="text-sm text-zinc-400 mb-1">
                          {getLifeDates(person)}
                        </p>
                      )}
                      {person._count && (
                        <p className="text-xs text-zinc-500">
                          {person._count.castRoles > 0 && `${person._count.castRoles} actuaciones`}
                          {person._count.castRoles > 0 && person._count.crewRoles > 0 && ' ‚Ä¢ '}
                          {person._count.crewRoles > 0 && `${person._count.crewRoles} trabajos t√©cnicos`}
                        </p>
                      )}
                      {person.biography && (
                        <p 
                          className="text-sm text-zinc-400 line-clamp-2 mt-2"
                          dangerouslySetInnerHTML={{ __html: sanitizeHtml(person.biography) }}
                        />
                      )}
                    </div>
                  </Link>
                ))}
              </div>
            </div>
          )}
        </div>
      ) : (
        <div className="text-center py-12">
          <Search className="w-16 h-16 text-zinc-600 mx-auto mb-4" />
          <h2 className="text-xl font-semibold text-white mb-2">
            No se encontraron resultados
          </h2>
          <p className="text-zinc-400">
            No se encontraron pel√≠culas ni personas que coincidan con "{query}"
          </p>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/(site)/efemerides/[[...date]]/page.tsx
// ==================================================
// src/app/efemerides/[[...date]]/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { Calendar, Sparkles } from 'lucide-react';
import { Efemeride, DirectorInfo } from '@/types/home.types';

const MONTHS = [
  'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
  'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
];

export default function EfemeridesPage() {
  const router = useRouter();
  const params = useParams();
  
  // Parsear fecha desde URL o usar hoy
  const parseDateFromParams = () => {
    if (params.date && Array.isArray(params.date) && params.date.length > 0) {
      const dateStr = params.date[0]; // "10-18"
      const [month, day] = dateStr.split('-').map(Number);
      
      // Validar
      if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
        return { month, day };
      }
    }
    
    // Default: hoy
    const today = new Date();
    return {
      month: today.getMonth() + 1,
      day: today.getDate()
    };
  };

  const initialDate = parseDateFromParams();
  
  const [selectedDate, setSelectedDate] = useState<Date>(
    new Date(new Date().getFullYear(), initialDate.month - 1, initialDate.day)
  );
  const [tempMonth, setTempMonth] = useState<number>(initialDate.month);
  const [tempDay, setTempDay] = useState<number>(initialDate.day);
  const [efemerides, setEfemerides] = useState<Efemeride[]>([]);
  const [loading, setLoading] = useState(true);

  const month = selectedDate.getMonth() + 1;
  const day = selectedDate.getDate();

  // Fetch inicial y cuando cambia la URL
  useEffect(() => {
    const dateFromUrl = parseDateFromParams();
    fetchEfemerides(dateFromUrl.month, dateFromUrl.day);
  }, [params.date]);

  const fetchEfemerides = async (mes: number, dia: number) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/efemerides?month=${mes}&day=${dia}`);
      if (!response.ok) throw new Error('Error fetching data');
      const result = await response.json();
      setEfemerides(result.efemerides || []);
    } catch (error) {
      console.error('Error fetching efem√©rides:', error);
      setEfemerides([]);
    } finally {
      setLoading(false);
    }
  };

  const handleMonthChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newMonth = parseInt(e.target.value);
    setTempMonth(newMonth);
    
    const maxDay = new Date(selectedDate.getFullYear(), newMonth, 0).getDate();
    if (tempDay > maxDay) {
      setTempDay(maxDay);
    }
  };

  const handleDayChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newDay = parseInt(e.target.value);
    setTempDay(newDay);
  };

  const handleSearch = () => {
    const newDate = new Date(selectedDate.getFullYear(), tempMonth - 1, tempDay);
    setSelectedDate(newDate);
    
    // Formatear fecha para URL: MM-DD (con padding de ceros)
    const monthStr = String(tempMonth).padStart(2, '0');
    const dayStr = String(tempDay).padStart(2, '0');
    
    // Navegar a la nueva URL
    router.push(`/efemerides/${monthStr}-${dayStr}`);
  };

  const handleToday = () => {
    const today = new Date();
    const todayMonth = today.getMonth() + 1;
    const todayDay = today.getDate();
    
    setSelectedDate(today);
    setTempMonth(todayMonth);
    setTempDay(todayDay);
    
    // Navegar a /efemerides (sin par√°metros = hoy)
    router.push('/efemerides');
  };

  const getDaysInMonth = (month: number, year: number) => {
    return new Date(year, month, 0).getDate();
  };

  const daysInCurrentMonth = getDaysInMonth(tempMonth, selectedDate.getFullYear());
  const dayOptions = Array.from({ length: daysInCurrentMonth }, (_, i) => i + 1);

  // Ordenar efem√©rides por a√±os (m√°s antiguo primero = m√°s a√±os)
  const efemeridesOrdenadas = [...efemerides].sort((a, b) => {
    const a√±osA = parseInt(a.hace.match(/\d+/)?.[0] || '0');
    const a√±osB = parseInt(b.hace.match(/\d+/)?.[0] || '0');
    return a√±osB - a√±osA; // M√°s a√±os primero (m√°s antiguo)
  });

  const hasEvents = efemerides.length > 0;

  /**
   * Renderiza los links de directores
   * Si hay m√∫ltiples directores, los separa con comas y "y"
   */
  const renderDirectorLinks = (efemeride: Efemeride) => {
    // Usar el array de directors si est√° disponible
    const directors = efemeride.directors;
    
    if (!directors || directors.length === 0) {
      // Fallback al campo director/directorSlug √∫nico (compatibilidad)
      if (efemeride.director && efemeride.directorSlug) {
        return (
          <Link 
            href={`/persona/${efemeride.directorSlug}`}
            className="text-gray-400 text-sm hover:text-gray-300 transition-colors"
          >
            de {efemeride.director}
          </Link>
        );
      }
      return null;
    }

    // Renderizar m√∫ltiples directores
    if (directors.length === 1) {
      return (
        <span className="text-gray-400 text-sm">
          de{' '}
          <Link 
            href={`/persona/${directors[0].slug}`}
            className="hover:text-gray-300 transition-colors"
          >
            {directors[0].name}
          </Link>
        </span>
      );
    }

    if (directors.length === 2) {
      return (
        <span className="text-gray-400 text-sm">
          de{' '}
          <Link 
            href={`/persona/${directors[0].slug}`}
            className="hover:text-gray-300 transition-colors"
          >
            {directors[0].name}
          </Link>
          {' y '}
          <Link 
            href={`/persona/${directors[1].slug}`}
            className="hover:text-gray-300 transition-colors"
          >
            {directors[1].name}
          </Link>
        </span>
      );
    }

    // 3 o m√°s directores: "A, B y C"
    return (
      <span className="text-gray-400 text-sm">
        de{' '}
        {directors.slice(0, -1).map((director, index) => (
          <span key={director.slug}>
            <Link 
              href={`/persona/${director.slug}`}
              className="hover:text-gray-300 transition-colors"
            >
              {director.name}
            </Link>
            {index < directors.length - 2 ? ', ' : ' '}
          </span>
        ))}
        {'y '}
        <Link 
          href={`/persona/${directors[directors.length - 1].slug}`}
          className="hover:text-gray-300 transition-colors"
        >
          {directors[directors.length - 1].name}
        </Link>
      </span>
    );
  };

  const renderEfemeridesCard = (efemeride: Efemeride) => {
    const isPelicula = efemeride.tipo === 'pelicula';
    const imageUrl = isPelicula ? efemeride.posterUrl : efemeride.photoUrl;
    const linkHref = isPelicula ? `/pelicula/${efemeride.slug}` : `/persona/${efemeride.slug}`;
    
    // Determinar el verbo seg√∫n el tipo de evento
    let verbo = '';
    if (efemeride.tipoEvento === 'estreno') verbo = 'se estrenaba';
    else if (efemeride.tipoEvento === 'inicio_rodaje') verbo = 'empezaba el rodaje de';
    else if (efemeride.tipoEvento === 'fin_rodaje') verbo = 'terminaba el rodaje de';
    else if (efemeride.tipoEvento === 'nacimiento') verbo = 'nac√≠a';
    else if (efemeride.tipoEvento === 'muerte') verbo = 'mor√≠a';

    // Extraer el a√±o del evento
    const fechaObj = typeof efemeride.fecha === 'string' 
      ? new Date(efemeride.fecha) 
      : efemeride.fecha;
    const a√±oEvento = fechaObj.getFullYear();

    return (
      <div
        key={efemeride.id}
        className="flex gap-6 p-6 bg-gray-900/50 rounded-lg border border-gray-800 hover:border-gray-700 transition-all"
      >
        {/* Imagen */}
        <Link href={linkHref} className="flex-shrink-0 group">
          <div className={`relative ${isPelicula ? 'w-32 h-48 rounded-lg' : 'w-32 h-32 rounded-full'} bg-gray-800 overflow-hidden`}>
            {imageUrl ? (
              <Image
                src={imageUrl}
                alt={efemeride.titulo || 'Imagen'}
                fill
                className="object-cover transition-transform duration-300 group-hover:scale-105"
                sizes="128px"
              />
            ) : (
              <div className="w-full h-full flex items-center justify-center">
                <Calendar className="w-12 h-12 text-gray-600" />
              </div>
            )}
          </div>
        </Link>

        {/* Texto */}
        <div className="flex-1 min-w-0">
          {/* ... de YYYY verbo */}
          <p className="text-gray-400 text-sm mb-2">
            ... de {a√±oEvento} {verbo}
          </p>

          {/* T√≠tulo/Nombre */}
          <Link href={linkHref}>
            <h3 className="text-white text-xl font-semibold hover:text-blue-400 transition-colors mb-1">
              {efemeride.titulo}
            </h3>
          </Link>

          {/* Director(es) - solo para pel√≠culas */}
          {isPelicula && renderDirectorLinks(efemeride)}
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-black text-white">
      {/* Header */}
      <div className="bg-gray-900/50 backdrop-blur-sm border-b border-gray-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex flex-col gap-6">
            {/* T√≠tulo */}
            <div>
              <h1 className="text-3xl font-bold mb-2">
                Efem√©rides del {day} de {MONTHS[month - 1]}
              </h1>
            </div>

            {/* Selector de fecha */}
            <div className="flex flex-wrap gap-3 items-end">
              {/* D√≠a */}
              <div className="flex-shrink-0 w-20">
                <label className="block text-xs text-gray-400 mb-1.5">D√≠a</label>
                <select
                  value={tempDay}
                  onChange={handleDayChange}
                  className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all"
                >
                  {dayOptions.map(d => (
                    <option key={d} value={d}>
                      {d}
                    </option>
                  ))}
                </select>
              </div>

              {/* Mes */}
              <div className="flex-grow min-w-[140px] max-w-[200px]">
                <label className="block text-xs text-gray-400 mb-1.5">Mes</label>
                <select
                  value={tempMonth}
                  onChange={handleMonthChange}
                  className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all"
                >
                  {MONTHS.map((monthName, idx) => (
                    <option key={idx + 1} value={idx + 1}>
                      {monthName}
                    </option>
                  ))}
                </select>
              </div>

              {/* Botones */}
              <div className="flex gap-2">
                <button
                  onClick={handleSearch}
                  className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all font-medium flex items-center gap-2"
                >
                  <Calendar className="w-4 h-4" />
                  Buscar
                </button>

                <button
                  onClick={handleToday}
                  className="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition-all flex items-center gap-2"
                  title="Volver a la fecha de hoy"
                >
                  <Sparkles className="w-4 h-4" />
                  Hoy
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Lista de efem√©rides */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Encabezado "Un X de X..." */}
        {!loading && hasEvents && (
          <h2 className="text-2xl font-bold text-white mb-8">
            Un {day} de {MONTHS[month - 1]}...
          </h2>
        )}

        {loading ? (
          <div className="space-y-4">
            {Array.from({ length: 8 }).map((_, i) => (
              <div key={i} className="flex gap-6 p-6 bg-gray-900/50 rounded-lg border border-gray-800 animate-pulse">
                <div className="w-32 h-48 bg-gray-800 rounded-lg flex-shrink-0" />
                <div className="flex-1 space-y-3">
                  <div className="h-4 bg-gray-800 rounded w-1/4" />
                  <div className="h-6 bg-gray-800 rounded w-3/4" />
                  <div className="h-4 bg-gray-800 rounded w-1/3" />
                </div>
              </div>
            ))}
          </div>
        ) : !hasEvents ? (
          <div className="text-center py-16">
            <div className="text-gray-400 text-lg mb-2">
              No hay efem√©rides registradas para esta fecha
            </div>
            <p className="text-gray-500 text-sm">
              Prob√° con otra fecha o volv√© a hoy para ver si hay efem√©rides
            </p>
          </div>
        ) : (
          <div className="space-y-4 max-w-4xl mx-auto">
            {efemeridesOrdenadas.map(efemeride => renderEfemeridesCard(efemeride))}
          </div>
        )}
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/layout.tsx
// ==================================================
// /src/app/(site)/layout.tsx
import type { Metadata } from 'next'
import { Inter, Crimson_Text } from 'next/font/google'
import Script from 'next/script'
import '../globals.css'
import Header from '@/components/layout/Header'
import HeaderStats from '@/components/layout/HeaderStats'
import Footer from '@/components/layout/Footer'
import AdBanner from '@/components/ads/AdBanner'
import { Toaster } from 'react-hot-toast'

// Configurar las fuentes
const inter = Inter({ 
  subsets: ['latin'],
  weight: ['300', '400', '500', '600'],
  variable: '--font-inter',
  display: 'swap',
})

const crimsonText = Crimson_Text({ 
  subsets: ['latin'],
  weight: ['400', '600'],
  style: ['normal', 'italic'],
  variable: '--font-crimson',
  display: 'swap',
})

export const metadata: Metadata = {
  metadataBase: new URL('https://cinenacional.com'),
  title: 'cinenacional.com - Base de datos del cine argentino',
  description: 'La base de datos m√°s completa del cine argentino. Descubr√≠ pel√≠culas, directores, actores y toda la historia cinematogr√°fica de Argentina.',
  icons: {
    icon: [
      { url: '/favicon.ico', sizes: '48x48' },
      { url: '/favicon.svg', type: 'image/svg+xml' },
      { url: '/favicon-16x16.png', sizes: '16x16', type: 'image/png' },
      { url: '/favicon-32x32.png', sizes: '32x32', type: 'image/png' },
    ],
    apple: [
      { url: '/apple-touch-icon.png', sizes: '180x180', type: 'image/png' },
    ],
  },
  keywords: 'cine argentino, pel√≠culas argentinas, actores argentinos, directores argentinos, base de datos cine',
  openGraph: {
    title: 'cinenacional.com - Base de datos del cine argentino',
    description: 'La base de datos m√°s completa del cine argentino',
    url: 'https://cinenacional.com',
    siteName: 'cinenacional.com',
    images: [
      {
        url: '/og-image.jpg',
        width: 1200,
        height: 630,
        alt: 'cinenacional.com',
      },
    ],
    locale: 'es_AR',
    type: 'website',
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  other: {
    'google-adsense-account': 'ca-pub-4540700730503978',
  },
}

export default function SiteLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const GA_MEASUREMENT_ID = process.env.NEXT_PUBLIC_GA_ID || 'G-5SGTLPHYYX'
  
  return (
    <html lang="es" className={`h-full ${inter.variable} ${crimsonText.variable}`}>
      <head>
        <script
          async
          src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4540700730503978"
          crossOrigin="anonymous"
        />
      </head>
      <body className={`${inter.className} min-h-full flex flex-col bg-zinc-950 text-white`}>
        {/* Google Analytics */}
        {GA_MEASUREMENT_ID && (
          <>
            <Script
              src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
              strategy="afterInteractive"
            />
            <Script id="google-analytics" strategy="afterInteractive">
              {`
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', '${GA_MEASUREMENT_ID}', {
                  page_path: window.location.pathname,
                });
              `}
            </Script>
          </>
        )}
        
        <Header />
        <HeaderStats />
        <AdBanner />
        <main className="flex-grow">
          {children}
        </main>
        <Footer />
        <Toaster 
          position="top-right"
          toastOptions={{
            duration: 4000,
            style: {
              background: '#363636',
              color: '#fff',
            },
            success: {
              style: {
                background: '#10b981',
              },
            },
            error: {
              style: {
                background: '#ef4444',
              },
            },
          }}
        />
      </body>
    </html>
  )
}

// ==================================================
// src/app/(site)/listados/estrenos/EstrenosContent.tsx
// ==================================================
// src/app/listados/estrenos/EstrenosContent.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import EstrenosDecadeSelector from '@/components/listados/estrenos/EstrenosDecadeSelector';
import EstrenosYearBar from '@/components/listados/estrenos/EstrenosYearBar';
import EstrenosGrid from '@/components/listados/estrenos/EstrenosGrid';
import { DecadePeriod } from '@/lib/estrenos/estrenosTypes';
import {
    getCurrentYear,
    getCurrentDecade,
    formatPeriodLabel,
    periodToApiFilters
} from '@/lib/estrenos/estrenosUtils';
import { MovieWithRelease } from '@/types/home.types';

export default function EstrenosContent() {
    const router = useRouter();
    const searchParams = useSearchParams();

    // Estado
    const [period, setPeriod] = useState<DecadePeriod>('all');
    const [selectedYear, setSelectedYear] = useState<number | null>(null);
    const [movies, setMovies] = useState<MovieWithRelease[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isInitialized, setIsInitialized] = useState(false);
    const [pagination, setPagination] = useState({
        page: 1,
        totalPages: 1,
        total: 0
    });
    const [currentPage, setCurrentPage] = useState(1);

    // Inicializar desde URL params - SOLO UNA VEZ
    useEffect(() => {
        const periodParam = searchParams.get('period');
        const yearParam = searchParams.get('year');

        if (periodParam) {
            setPeriod(periodParam as DecadePeriod);
            if (yearParam) {
                setSelectedYear(parseInt(yearParam));
            }
        } else {
            // Por defecto: a√±o actual de la d√©cada actual
            const currentYear = getCurrentYear();
            const currentDecade = getCurrentDecade();
            setPeriod(currentDecade.id);
            setSelectedYear(currentYear);
        }

        // Marcar como inicializado
        setIsInitialized(true);
    }, []); // ‚úÖ Array vac√≠o - solo se ejecuta al montar

    // Resetear a p√°gina 1 cuando cambian los filtros
    useEffect(() => {
        if (!isInitialized) return;
        setCurrentPage(1);
    }, [period, selectedYear]);

    // Cargar pel√≠culas cuando cambian filtros o p√°gina
    useEffect(() => {
        if (!isInitialized) return;
        loadMovies();
    }, [period, selectedYear, currentPage, isInitialized]);

    // Actualizar URL cuando cambian los filtros
    useEffect(() => {
        if (!isInitialized) return;

        const params = new URLSearchParams();

        if (period !== 'all' && period !== 'upcoming') {
            params.set('period', period);
        }

        if (selectedYear !== null) {
            params.set('year', selectedYear.toString());
        }

        const queryString = params.toString();
        const newUrl = queryString ? `/listados/estrenos?${queryString}` : '/listados/estrenos';

        router.replace(newUrl, { scroll: false });
    }, [period, selectedYear, router, isInitialized]);

    const loadMovies = async () => {
        setIsLoading(true);

        try {
            // Construir filtros para la API
            const apiFilters = periodToApiFilters(period, selectedYear);

            const params = new URLSearchParams({
                page: currentPage.toString(),
                limit: period === 'upcoming' ? '1000' : '90',
                sortBy: 'releaseYear',
                sortOrder: 'asc',
                ...apiFilters
            });

            const response = await fetch(`/api/movies?${params}`);

            if (!response.ok) {
                throw new Error('Error al cargar estrenos');
            }

            const data = await response.json();

            // Filtrar pel√≠culas que tengan al menos releaseYear
            const filteredMovies = (data.movies || []).filter((m: any) => m.releaseYear);

            // Si es "upcoming", filtrar solo futuras
            let finalMovies = filteredMovies;
            if (period === 'upcoming') {
                const currentYear = getCurrentYear();
                finalMovies = filteredMovies.filter((m: any) => {
                    if (!m.releaseYear) return false;

                    // Si tiene fecha completa, verificar que sea futura
                    if (m.releaseMonth && m.releaseDay) {
                        const releaseDate = new Date(m.releaseYear, m.releaseMonth - 1, m.releaseDay);
                        return releaseDate > new Date();
                    }

                    // Si solo tiene a√±o o a√±o-mes, considerar futura si el a√±o es mayor
                    return m.releaseYear >= currentYear;
                });
            }

            setMovies(finalMovies);
            
            const actualTotal = period === 'upcoming' 
                ? finalMovies.length 
                : (data.pagination?.total || data.pagination?.totalItems || 0);

            setPagination({
                page: period === 'upcoming' ? 1 : (data.pagination?.page || 1),
                totalPages: period === 'upcoming' ? 1 : Math.ceil(actualTotal / 90),
                total: actualTotal
            });

        } catch (error) {
            console.error('Error loading movies:', error);
            setMovies([]);
        } finally {
            setIsLoading(false);
        }
    };

    const handlePeriodChange = (newPeriod: DecadePeriod) => {
        setPeriod(newPeriod);
        setSelectedYear(null);
    };

    const handleYearChange = (year: number | null) => {
        setSelectedYear(year);
    };

    const handlePreviousPage = () => {
        if (currentPage > 1) {
            setCurrentPage(currentPage - 1);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    };

    const handleNextPage = () => {
        if (currentPage < pagination.totalPages) {
            setCurrentPage(currentPage + 1);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    };

    return (
        <div className="min-h-screen bg-black text-white">
            {/* Header */}
            <div className="bg-gray-900/50 backdrop-blur-sm border-b border-gray-800 relative z-10">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
                        <div>
                            <h1 className="text-3xl font-bold mb-2">
                                {formatPeriodLabel(period, selectedYear)}
                            </h1>
                            {pagination.total > 0 && (
                                <p className="text-gray-400 text-sm">
                                    {pagination.total} pel√≠cula{pagination.total !== 1 ? 's' : ''}
                                </p>
                            )}
                        </div>

                        <EstrenosDecadeSelector
                            value={period}
                            onChange={handlePeriodChange}
                        />
                    </div>
                </div>
            </div>

            {/* Year Bar */}
            <EstrenosYearBar
                period={period}
                selectedYear={selectedYear}
                onYearChange={handleYearChange}
                onPeriodChange={handlePeriodChange}
            />

            {/* Grid de pel√≠culas */}
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <EstrenosGrid
                    movies={movies}
                    isLoading={isLoading}
                    dateType={period === 'upcoming' ? 'future' : 'past'}
                />

                {/* Paginaci√≥n */}
                {!isLoading && pagination.totalPages > 1 && (
                    <div className="flex items-center justify-center gap-4 mt-8">
                        <button
                            onClick={handlePreviousPage}
                            disabled={currentPage === 1}
                            className={`
                                px-4 py-2 rounded-lg font-medium transition-all
                                ${currentPage === 1
                                    ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                                    : 'bg-gray-800 text-white hover:bg-gray-700'
                                }
                            `}
                        >
                            ‚Üê Anterior
                        </button>

                        <span className="text-gray-400">
                            P√°gina {currentPage} de {pagination.totalPages}
                        </span>

                        <button
                            onClick={handleNextPage}
                            disabled={currentPage === pagination.totalPages}
                            className={`
                                px-4 py-2 rounded-lg font-medium transition-all
                                ${currentPage === pagination.totalPages
                                    ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                                    : 'bg-gray-800 text-white hover:bg-gray-700'
                                }
                            `}
                        >
                            Siguiente ‚Üí
                        </button>
                    </div>
                )}
            </div>
        </div>
    );
}

// ==================================================
// src/app/(site)/listados/estrenos/page.tsx
// ==================================================
// src/app/listados/estrenos/page.tsx
'use client';

import { Suspense } from 'react';
import EstrenosContent from './EstrenosContent';

export const dynamic = 'force-dynamic';

export default function EstrenosPage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-black text-white flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
          <p className="text-gray-400">Cargando estrenos...</p>
        </div>
      </div>
    }>
      <EstrenosContent />
    </Suspense>
  );
}

// ==================================================
// src/app/(site)/listados/obituarios/ObituariosContent.tsx
// ==================================================
// src/app/listados/obituarios/ObituariosContent.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import ObituariosYearSelector from '@/components/listados/obituarios/ObituariosYearSelector';
import ObituariosGrid from '@/app/(site)/listados/obituarios/ObituariosGrid';
import { PersonWithDeath, ObituariosPagination } from '@/lib/obituarios/obituariosTypes';
import { getCurrentYear, filtersToApiParams } from '@/lib/obituarios/obituariosUtils';

export default function ObituariosContent() {
  const router = useRouter();
  const searchParams = useSearchParams();

  // Estado
  const [selectedYear, setSelectedYear] = useState<number>(getCurrentYear());
  const [availableYears, setAvailableYears] = useState<number[]>([]);
  const [people, setPeople] = useState<PersonWithDeath[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const [pagination, setPagination] = useState<ObituariosPagination>({
    page: 1,
    totalPages: 1,
    total: 0
  });
  const [currentPage, setCurrentPage] = useState(1);

  // Cargar a√±os disponibles al montar
  useEffect(() => {
    loadAvailableYears();
  }, []);

  // Inicializar desde URL params - SOLO UNA VEZ
  useEffect(() => {
    const yearParam = searchParams.get('year');

    if (yearParam) {
      const year = parseInt(yearParam);
      if (!isNaN(year)) {
        setSelectedYear(year);
      }
    }

    // Marcar como inicializado
    setIsInitialized(true);
  }, []);

  // Resetear a p√°gina 1 cuando cambia el a√±o
  useEffect(() => {
    if (!isInitialized) return;
    setCurrentPage(1);
  }, [selectedYear]);

  // Cargar personas cuando cambian filtros o p√°gina
  useEffect(() => {
    if (!isInitialized) return;
    loadPeople();
  }, [selectedYear, currentPage, isInitialized]);

  // Actualizar URL cuando cambia el a√±o
  useEffect(() => {
    if (!isInitialized) return;

    const params = new URLSearchParams();
    params.set('year', selectedYear.toString());

    const queryString = params.toString();
    const newUrl = `/listados/obituarios?${queryString}`;

    router.replace(newUrl, { scroll: false });
  }, [selectedYear, router, isInitialized]);

  const loadAvailableYears = async () => {
    try {
      const response = await fetch('/api/people/death-years');
      
      if (!response.ok) {
        throw new Error('Error al cargar a√±os');
      }

      const data = await response.json();
      setAvailableYears(data.years || []);
    } catch (error) {
      console.error('Error loading death years:', error);
      setAvailableYears([]);
    }
  };

  const loadPeople = async () => {
    setIsLoading(true);

    try {
      const apiParams = filtersToApiParams(selectedYear, currentPage, 90);
      const params = new URLSearchParams(apiParams);

      const response = await fetch(`/api/people?${params}`);

      if (!response.ok) {
        throw new Error('Error al cargar obituarios');
      }

      const data = await response.json();

      setPeople(data.data || []);
      
      setPagination({
        page: data.page || 1,
        totalPages: data.totalPages || 1,
        total: data.totalCount || 0
      });

    } catch (error) {
      console.error('Error loading people:', error);
      setPeople([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleYearChange = (year: number) => {
    setSelectedYear(year);
  };

  const handlePreviousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  };

  const handleNextPage = () => {
    if (currentPage < pagination.totalPages) {
      setCurrentPage(currentPage + 1);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  };

  return (
    <div className="min-h-screen bg-black text-white">
      {/* Header */}
      <div className="bg-gray-900/50 backdrop-blur-sm border-b border-gray-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <div>
              <h1 className="text-3xl font-bold mb-2">
                Obituarios de {selectedYear}
              </h1>
              {pagination.total > 0 && (
                <p className="text-gray-400 text-sm">
                  {pagination.total} persona{pagination.total !== 1 ? 's' : ''} fallecida{pagination.total !== 1 ? 's' : ''}
                </p>
              )}
            </div>

            {availableYears.length > 0 && (
              <ObituariosYearSelector
                availableYears={availableYears}
                selectedYear={selectedYear}
                onChange={handleYearChange}
              />
            )}
          </div>
        </div>
      </div>

      {/* Grid de personas */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <ObituariosGrid
          people={people}
          isLoading={isLoading}
        />

        {/* Paginaci√≥n */}
        {!isLoading && pagination.totalPages > 1 && (
          <div className="flex items-center justify-center gap-4 mt-8">
            <button
              onClick={handlePreviousPage}
              disabled={currentPage === 1}
              className={`
                px-4 py-2 rounded-lg font-medium transition-all
                ${currentPage === 1
                  ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                  : 'bg-gray-800 text-white hover:bg-gray-700'
                }
              `}
            >
              ‚Üê Anterior
            </button>

            <span className="text-gray-400">
              P√°gina {currentPage} de {pagination.totalPages}
            </span>

            <button
              onClick={handleNextPage}
              disabled={currentPage === pagination.totalPages}
              className={`
                px-4 py-2 rounded-lg font-medium transition-all
                ${currentPage === pagination.totalPages
                  ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                  : 'bg-gray-800 text-white hover:bg-gray-700'
                }
              `}
            >
              Siguiente ‚Üí
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/listados/obituarios/ObituariosGrid.tsx
// ==================================================
// src/components/listados/obituarios/ObituariosGrid.tsx
'use client';

import PersonCard from '@/components/home/PersonCard';
import { PersonWithDeath } from '@/lib/obituarios/obituariosTypes';

interface ObituariosGridProps {
  people: PersonWithDeath[];
  isLoading: boolean;
}

export default function ObituariosGrid({ people, isLoading }: ObituariosGridProps) {
  
  if (isLoading) {
    return (
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
        {Array.from({ length: 12 }).map((_, i) => (
          <div key={i} className="animate-pulse">
            <div className="aspect-[2/3] bg-gray-800 rounded-lg mb-2" />
            <div className="h-4 bg-gray-800 rounded mb-1" />
            <div className="h-3 bg-gray-800 rounded w-2/3" />
          </div>
        ))}
      </div>
    );
  }
  
  if (people.length === 0) {
    return (
      <div className="text-center py-16">
        <div className="text-gray-400 text-lg mb-2">
          No se encontraron obituarios para este a√±o
        </div>
        <p className="text-gray-500 text-sm">
          Intenta seleccionar otro a√±o
        </p>
      </div>
    );
  }
  
  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
      {people.map((person) => (
        <PersonCard key={person.id} person={person} />
      ))}
    </div>
  );
}

// ==================================================
// src/app/(site)/listados/obituarios/page.tsx
// ==================================================
// src/app/listados/obituarios/page.tsx
'use client';

import { Suspense } from 'react';
import ObituariosContent from './ObituariosContent';

export const dynamic = 'force-dynamic';

export default function ObituariosPage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-black text-white flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
          <p className="text-gray-400">Cargando obituarios...</p>
        </div>
      </div>
    }>
      <ObituariosContent />
    </Suspense>
  );
}

// ==================================================
// src/app/(site)/listados/peliculas/page.tsx
// ==================================================
'use client';

import React, { useState, useEffect } from 'react';

export default function MovieListPage() {
  const [viewMode, setViewMode] = useState('compact');
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 10;
  const totalMovies = 847;
  const totalPages = Math.ceil(totalMovies / itemsPerPage);

  // Sample movie data
  const movies = [
    { id: 1, title: 'Relatos Salvajes', director: 'Dami√°n Szifron', year: 2014, genre: 'Comedia Negra, Drama', duration: 122, synopsis: 'Seis relatos que alternan la comedia negra y la tragedia. Sus personajes se ver√°n empujados hacia el abismo y hacia el innegable placer de perder el control al cruzar la delgada l√≠nea que separa la civilizaci√≥n de la barbarie.', rating: 8.1 },
    { id: 2, title: 'El Secreto de sus Ojos', director: 'Juan Jos√© Campanella', year: 2009, genre: 'Drama, Thriller', duration: 129, synopsis: 'Benjam√≠n Esp√≥sito es oficial de un Juzgado de Instrucci√≥n de Buenos Aires reci√©n retirado. Obsesionado por un brutal asesinato ocurrido veinticinco a√±os antes, decide escribir una novela sobre el caso, del cual fue testigo y protagonista.', rating: 8.2 },
    { id: 3, title: 'Nueve Reinas', director: 'Fabi√°n Bielinsky', year: 2000, genre: 'Thriller, Drama', duration: 114, synopsis: 'Dos estafadores, uno joven y otro veterano, se unen para realizar un negocio millonario. La venta de unos sellos falsos conocidos como las "nueve reinas" se convierte en una carrera contra el tiempo donde nada es lo que parece.', rating: 7.9 },
    { id: 4, title: 'La Historia Oficial', director: 'Luis Puenzo', year: 1985, genre: 'Drama', duration: 112, synopsis: 'Buenos Aires, d√©cada del 80. Alicia es una profesora de historia casada con Roberto, un empresario. La pareja tiene una hija adoptiva, Gaby. La vida de Alicia cambiar√° cuando comience a sospechar sobre el verdadero origen de su hija.', rating: 7.8 },
    { id: 5, title: 'El Hijo de la Novia', director: 'Juan Jos√© Campanella', year: 2001, genre: 'Drama, Comedia', duration: 123, synopsis: 'Rafael Belvedere est√° en crisis: a los 42 a√±os, sigue soltero, no tiene amigos y est√° agobiado por las responsabilidades. Su padre quiere casarse por la iglesia con su madre, que padece Alzheimer, para complacerla.', rating: 7.8 },
    { id: 6, title: 'Medianeras', director: 'Gustavo Taretto', year: 2011, genre: 'Drama, Romance', duration: 95, synopsis: 'Buenos Aires es una ciudad de departamentos. Mart√≠n y Mariana viven a metros de distancia, pero nunca se cruzaron. Mientras tanto, ambos buscan en Internet lo que no pueden encontrar afuera.', rating: 7.5 },
    { id: 7, title: 'Un Cuento Chino', director: 'Sebasti√°n Borensztein', year: 2011, genre: 'Comedia, Drama', duration: 93, synopsis: 'Roberto es un ferretero solitario que colecciona noticias ins√≥litas. Un d√≠a conoce a Jun, un chino que no habla espa√±ol. A pesar de la barrera del idioma, Roberto lo ayudar√° en su b√∫squeda.', rating: 7.7 },
    { id: 8, title: 'Pizza, Birra, Faso', director: 'Bruno Stagnaro, Adri√°n Caetano', year: 1998, genre: 'Drama, Crimen', duration: 92, synopsis: 'Cordob√©s y sus amigos sobreviven robando en las calles de Buenos Aires. Cuando su novia queda embarazada, Cordob√©s intenta conseguir dinero para un futuro mejor, pero la vida en la calle no perdona.', rating: 7.1 },
    { id: 9, title: 'Esperando la Carroza', director: 'Alejandro Doria', year: 1985, genre: 'Comedia', duration: 87, synopsis: 'Mam√° Cora tiene tres hijos que no quieren hacerse cargo de ella. Durante un almuerzo familiar, la anciana desaparece y todos creen que se suicid√≥ tir√°ndose al r√≠o, desatando un caos familiar lleno de hipocres√≠a.', rating: 8.1 },
    { id: 10, title: 'Comodines', director: 'Jorge Nisco', year: 1997, genre: 'Acci√≥n, Comedia', duration: 90, synopsis: 'Dos polic√≠as muy diferentes deben trabajar juntos para resolver un caso de corrupci√≥n policial. Entre persecuciones y tiroteos, desarrollar√°n una amistad mientras intentan sobrevivir a la investigaci√≥n.', rating: 6.5 }
  ];

  const getDisplayedMovies = () => {
    const start = (currentPage - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    return movies.slice(start, end);
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
    window.scrollTo(0, 0);
  };

  const renderPagination = () => {
    const pages = [];
    const maxVisible = 5;
    
    if (totalPages <= maxVisible) {
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      if (currentPage <= 3) {
        pages.push(1, 2, 3, '...', totalPages - 1, totalPages);
      } else if (currentPage >= totalPages - 2) {
        pages.push(1, 2, '...', totalPages - 2, totalPages - 1, totalPages);
      } else {
        pages.push(1, '...', currentPage - 1, currentPage, currentPage + 1, '...', totalPages);
      }
    }
    
    return pages;
  };

  // Add styles
  const styles = `
    @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600&display=swap');
    
    body {
      font-family: 'Inter', system-ui, sans-serif;
      font-weight: 300;
      letter-spacing: -0.01em;
      background-color: #0f1419;
      color: white;
    }
    
    .serif-heading {
      font-family: 'Crimson Text', Georgia, serif;
      font-weight: 600;
      letter-spacing: -0.02em;
    }
    
    .serif-body {
      font-family: 'Crimson Text', Georgia, serif;
      font-weight: 400;
      line-height: 1.7;
    }
    
    .poster-shadow {
      box-shadow: 0 20px 40px rgba(0,0,0,0.4);
    }
    
    .glass-effect {
      backdrop-filter: blur(10px);
      background: rgba(42, 42, 42, 0.8);
    }
    
    .gradient-text {
      background: linear-gradient(135deg, #3b82f6, #60a5fa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .movie-placeholder {
      background: linear-gradient(135deg, #1a2332, #0f1419);
      border: 1px solid #3b82f6;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem;
      position: relative;
      overflow: hidden;
    }
    
    .movie-placeholder::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(59, 130, 246, 0.1) 50%, transparent 70%);
      animation: shimmer 2s infinite;
    }
    
    .placeholder-small {
      background: linear-gradient(135deg, #1a2332, #0f1419);
      border: 1px solid #374151;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1rem;
    }
    
    .animate-fade-in {
      animation: fadeIn 0.5s ease-in-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .bg-cine-dark { background-color: #0f1419; }
    .bg-cine-gray { background-color: #1a2332; }
    .text-cine-accent { color: #3b82f6; }
    .bg-cine-accent { background-color: #3b82f6; }
    .border-cine-accent { border-color: #3b82f6; }
    .hover\\:bg-cine-accent:hover { background-color: #3b82f6; }
    .hover\\:text-cine-accent:hover { color: #3b82f6; }
    .hover\\:border-cine-accent:hover { border-color: #3b82f6; }
  `;

  return (
    <>
      <style>{styles}</style>
      <div className="bg-cine-dark text-white min-h-screen">
        {/* Main Content */}
        <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          {/* Page Header */}
          <div className="mb-8">
            <h2 className="serif-heading text-4xl text-white mb-2">Pel√≠culas Argentinas</h2>
            <p className="text-gray-400">Explor√° el cat√°logo completo del cine nacional</p>
          </div>

          {/* Filters and View Toggle */}
          <div className="glass-effect rounded-lg p-6 mb-8">
            <div className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-6">
              {/* Filters */}
              <div className="flex flex-wrap gap-3">
                <select className="bg-cine-dark border border-gray-600 rounded-lg px-4 py-2 text-sm focus:outline-none focus:border-cine-accent transition-colors text-white">
                  <option>Todos los g√©neros</option>
                  <option>Drama</option>
                  <option>Comedia</option>
                  <option>Thriller</option>
                  <option>Documental</option>
                  <option>Romance</option>
                  <option>Acci√≥n</option>
                </select>
                <select className="bg-cine-dark border border-gray-600 rounded-lg px-4 py-2 text-sm focus:outline-none focus:border-cine-accent transition-colors text-white">
                  <option>Todas las d√©cadas</option>
                  <option>2020s</option>
                  <option>2010s</option>
                  <option>2000s</option>
                  <option>1990s</option>
                  <option>1980s</option>
                </select>
                <select className="bg-cine-dark border border-gray-600 rounded-lg px-4 py-2 text-sm focus:outline-none focus:border-cine-accent transition-colors text-white">
                  <option>Ordenar por: M√°s recientes</option>
                  <option>T√≠tulo (A-Z)</option>
                  <option>T√≠tulo (Z-A)</option>
                  <option>A√±o (Ascendente)</option>
                  <option>A√±o (Descendente)</option>
                  <option>Calificaci√≥n</option>
                </select>
              </div>

              {/* View Toggle */}
              <div className="flex items-center bg-cine-dark rounded-lg p-1 border border-gray-600">
                <button 
                  onClick={() => setViewMode('compact')}
                  className={`px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 ${
                    viewMode === 'compact' 
                      ? 'bg-cine-accent text-white' 
                      : 'text-gray-400 hover:text-white'
                  }`}
                >
                  Vista Compacta
                </button>
                <button 
                  onClick={() => setViewMode('detail')}
                  className={`px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 ${
                    viewMode === 'detail' 
                      ? 'bg-cine-accent text-white' 
                      : 'text-gray-400 hover:text-white'
                  }`}
                >
                  Vista Detallada
                </button>
              </div>
            </div>
          </div>

          {/* Movies Display */}
          {viewMode === 'compact' ? (
            // Compact Grid View
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6 mb-12">
              {getDisplayedMovies().map((movie, index) => (
                <div 
                  key={movie.id} 
                  className="group cursor-pointer animate-fade-in"
                  style={{animationDelay: `${index * 0.05}s`}}
                >
                  <div className="relative aspect-[2/3] rounded-lg overflow-hidden poster-shadow transform group-hover:scale-105 transition-transform duration-300">
                    <div className="movie-placeholder w-full h-full">
                      <svg className="w-16 h-16 text-cine-accent mb-4 opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z"/>
                      </svg>
                      <p className="text-sm text-gray-400">Afiche</p>
                    </div>
                    <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/0 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
                    {movie.rating && (
                      <div className="absolute top-2 right-2 bg-black/70 backdrop-blur-sm px-2 py-1 rounded-md flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <svg className="w-3 h-3 text-yellow-400 fill-current" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                        <span className="text-xs font-medium text-white">{movie.rating}</span>
                      </div>
                    )}
                  </div>
                  <div className="mt-3">
                    <h3 className="font-medium text-white line-clamp-1 group-hover:text-cine-accent transition-colors">{movie.title}</h3>
                    <p className="text-sm text-gray-400">{movie.director}</p>
                    <p className="text-sm text-gray-500">{movie.year}</p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            // Detail List View
            <div className="space-y-4 mb-12">
              {getDisplayedMovies().map((movie, index) => (
                <div 
                  key={movie.id} 
                  className="glass-effect rounded-lg p-6 hover:border-cine-accent border border-transparent transition-all duration-300 cursor-pointer animate-fade-in"
                  style={{animationDelay: `${index * 0.05}s`}}
                >
                  <div className="flex flex-col md:flex-row gap-6">
                    <div className="w-full md:w-32 flex-shrink-0">
                      <div className="aspect-[2/3] md:aspect-auto md:h-48 rounded-lg overflow-hidden">
                        <div className="placeholder-small w-full h-full">
                          <svg className="w-8 h-8 text-gray-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z"/>
                          </svg>
                          <p className="text-xs text-gray-400 text-center">Sin imagen</p>
                        </div>
                      </div>
                    </div>
                    <div className="flex-1 space-y-3">
                      <div>
                        <div className="flex items-start justify-between">
                          <h3 className="text-xl font-medium text-white hover:text-cine-accent transition-colors">{movie.title}</h3>
                          {movie.rating && (
                            <div className="flex items-center space-x-1 bg-cine-dark px-2 py-1 rounded-md">
                              <svg className="w-4 h-4 text-yellow-400 fill-current" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                              </svg>
                              <span className="text-sm font-medium text-yellow-400">{movie.rating}</span>
                            </div>
                          )}
                        </div>
                        <div className="flex flex-wrap gap-4 mt-2 text-sm text-gray-400">
                          <span className="flex items-center gap-1">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            {movie.director}
                          </span>
                          <span className="flex items-center gap-1">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            {movie.year}
                          </span>
                          <span className="flex items-center gap-1">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 4v16M17 4v16M3 8h4m10 0h4M3 16h4m10 0h4"></path>
                            </svg>
                            {movie.genre}
                          </span>
                          <span className="flex items-center gap-1">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            {movie.duration} min
                          </span>
                        </div>
                      </div>
                      <p className="text-gray-300 serif-body line-clamp-3">{movie.synopsis}</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Pagination */}
          <div className="flex flex-col sm:flex-row justify-between items-center gap-6">
            <p className="text-sm text-gray-400">
              Mostrando <span className="font-medium text-white">{(currentPage - 1) * itemsPerPage + 1}</span> a{' '}
              <span className="font-medium text-white">
                {Math.min(currentPage * itemsPerPage, totalMovies)}
              </span>{' '}
              de <span className="font-medium text-white">{totalMovies}</span> pel√≠culas
            </p>
            <nav className="flex items-center space-x-2">
              <button 
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1}
                className="px-3 py-2 text-sm font-medium text-gray-400 bg-cine-gray border border-gray-700 rounded-lg hover:bg-cine-dark hover:border-cine-accent transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path>
                </svg>
              </button>
              
              {renderPagination().map((page, index) => (
                <React.Fragment key={index}>
                  {page === '...' ? (
                    <span className="px-2 text-gray-500">...</span>
                  ) : (
                    <button
                      onClick={() => handlePageChange(page as number)}
                      className={`px-4 py-2 text-sm font-medium rounded-lg transition-colors ${
                        currentPage === page
                          ? 'text-white bg-cine-accent'
                          : 'text-gray-300 bg-cine-gray border border-gray-700 hover:bg-cine-dark hover:border-cine-accent'
                      }`}
                    >
                      {page}
                    </button>
                  )}
                </React.Fragment>
              ))}
              
              <button 
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage === totalPages}
                className="px-3 py-2 text-sm font-medium text-gray-400 bg-cine-gray border border-gray-700 rounded-lg hover:bg-cine-dark hover:border-cine-accent transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path>
                </svg>
              </button>
            </nav>
          </div>
        </main>
      </div>
    </>
  );
}

// ==================================================
// src/app/(site)/listados/personas/page.tsx
// ==================================================
// src/app/(site)/listados/personas/page.tsx
'use client';

import { Suspense } from 'react';
import PersonasContent from './PersonasContent';

export default function PersonasPage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-black text-white flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
          <p className="text-gray-400">Cargando personas...</p>
        </div>
      </div>
    }>
      <PersonasContent />
    </Suspense>
  );
}


// ==================================================
// src/app/(site)/listados/personas/PersonasContent.tsx
// ==================================================
// src/app/(site)/listados/personas/PersonasContent.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import PersonasFilters from './PersonasFilters';
import PersonasGrid from './PersonasGrid';
import ViewToggle from './ViewToggle';
import { 
  PersonListFilters, 
  DEFAULT_PERSON_FILTERS,
  FiltersDataResponse,
  PersonWithMovie,
  ViewMode,
  SORT_OPTIONS
} from '@/lib/people/personListTypes';
import { 
  searchParamsToFilters, 
  filtersToSearchParams,
  filtersToApiParams,
  countActiveFilters,
  clearFilters
} from '@/lib/people/personListUtils';

interface PaginationState {
  page: number;
  totalPages: number;
  totalCount: number;
}

export default function PersonasContent() {
  const router = useRouter();
  const searchParams = useSearchParams();

  // Estado de filtros
  const [filters, setFilters] = useState<PersonListFilters>(DEFAULT_PERSON_FILTERS);
  const [filtersData, setFiltersData] = useState<FiltersDataResponse | null>(null);
  
  // Estado de datos
  const [people, setPeople] = useState<PersonWithMovie[]>([]);
  const [pagination, setPagination] = useState<PaginationState>({
    page: 1,
    totalPages: 1,
    totalCount: 0
  });
  
  // Estado de UI
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingFilters, setIsLoadingFilters] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const [viewMode, setViewMode] = useState<ViewMode>('compact');
  const [showFilters, setShowFilters] = useState(false);

  // Cargar opciones de filtros al montar
  useEffect(() => {
    loadFiltersData();
  }, []);

  // Inicializar filtros desde URL
  useEffect(() => {
    const urlFilters = searchParamsToFilters(searchParams);
    setFilters(urlFilters);
    setIsInitialized(true);
  }, []);

  // Cargar personas cuando cambian los filtros
  useEffect(() => {
    if (!isInitialized) return;
    loadPeople();
  }, [filters, isInitialized]);

  // Actualizar URL cuando cambian los filtros
  useEffect(() => {
    if (!isInitialized) return;
    
    const params = filtersToSearchParams(filters);
    const queryString = params.toString();
    const newUrl = queryString ? `/listados/personas?${queryString}` : '/listados/personas';
    
    router.replace(newUrl, { scroll: false });
  }, [filters, router, isInitialized]);

  const loadFiltersData = async () => {
    setIsLoadingFilters(true);
    try {
      const response = await fetch('/api/people/filters');
      if (!response.ok) throw new Error('Error al cargar filtros');
      const data = await response.json();
      setFiltersData(data);
    } catch (error) {
      console.error('Error loading filters:', error);
    } finally {
      setIsLoadingFilters(false);
    }
  };

  const loadPeople = async () => {
    setIsLoading(true);
    try {
      const apiParams = filtersToApiParams(filters);
      const params = new URLSearchParams(apiParams);
      
      const response = await fetch(`/api/people/list?${params}`);
      if (!response.ok) throw new Error('Error al cargar personas');
      
      const data = await response.json();
      
      setPeople(data.data || []);
      setPagination({
        page: data.page || 1,
        totalPages: data.totalPages || 1,
        totalCount: data.totalCount || 0
      });
    } catch (error) {
      console.error('Error loading people:', error);
      setPeople([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleFilterChange = useCallback(<K extends keyof PersonListFilters>(
    key: K, 
    value: PersonListFilters[K]
  ) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      page: 1 // Reset a p√°gina 1 cuando cambia un filtro
    }));
  }, []);

  const handleClearFilters = useCallback(() => {
    setFilters(clearFilters(filters));
  }, [filters]);

  const handleSortByChange = useCallback((sortBy: string) => {
    setFilters(prev => ({
      ...prev,
      sortBy: sortBy as PersonListFilters['sortBy'],
      page: 1
    }));
  }, []);

  const handleToggleSortOrder = useCallback(() => {
    setFilters(prev => ({
      ...prev,
      sortOrder: prev.sortOrder === 'desc' ? 'asc' : 'desc',
      page: 1
    }));
  }, []);

  const handlePageChange = useCallback((newPage: number) => {
    setFilters(prev => ({
      ...prev,
      page: newPage
    }));
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, []);

  const activeFiltersCount = countActiveFilters(filters);

  return (
    <div className="min-h-screen bg-black text-white">
      {/* Header */}
      <div className="bg-gray-900/50 backdrop-blur-sm border-b border-gray-800 sticky top-0 z-40">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex flex-col gap-4">
            {/* T√≠tulo y contador */}
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div>
                <h1 className="text-2xl sm:text-3xl font-bold">Personas</h1>
                {pagination.totalCount > 0 && (
                  <p className="text-gray-400 text-sm mt-1">
                    {pagination.totalCount.toLocaleString('es-AR')} persona{pagination.totalCount !== 1 ? 's' : ''}
                    {activeFiltersCount > 0 && ` (${activeFiltersCount} filtro${activeFiltersCount !== 1 ? 's' : ''} activo${activeFiltersCount !== 1 ? 's' : ''})`}
                  </p>
                )}
              </div>

              {/* Controles: Ordenar, Vista, Filtros */}
              <div className="flex items-center gap-3">
                {/* Ordenamiento */}
                <div className="flex items-center gap-2">
                  <label className="text-xs text-gray-400 hidden sm:block">Ordenar por:</label>
                  <select
                    value={filters.sortBy || 'id'}
                    onChange={(e) => handleSortByChange(e.target.value)}
                    className="px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                  >
                    {SORT_OPTIONS.map(option => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                  
                  {/* Bot√≥n para invertir orden */}
                  <button
                    onClick={handleToggleSortOrder}
                    className="p-2 bg-gray-800 border border-gray-700 rounded-lg text-white hover:bg-gray-700 transition-colors"
                    title={filters.sortOrder === 'desc' ? 'Mayor a menor' : 'Menor a mayor'}
                  >
                    {filters.sortOrder === 'desc' ? (
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                      </svg>
                    ) : (
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                      </svg>
                    )}
                  </button>
                </div>

                <ViewToggle 
                  viewMode={viewMode} 
                  onChange={setViewMode} 
                />
                
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className={`
                    flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all
                    ${showFilters 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-800 text-white hover:bg-gray-700'
                    }
                  `}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
                  </svg>
                  <span className="hidden sm:inline">Filtros</span>
                  {activeFiltersCount > 0 && (
                    <span className="bg-white text-orange-500 text-xs font-bold px-1.5 py-0.5 rounded-full">
                      {activeFiltersCount}
                    </span>
                  )}
                </button>
              </div>
            </div>

            {/* Panel de filtros */}
            {showFilters && (
              <PersonasFilters
                filters={filters}
                filtersData={filtersData}
                isLoading={isLoadingFilters}
                onFilterChange={handleFilterChange}
                onClearFilters={handleClearFilters}
              />
            )}
          </div>
        </div>
      </div>

      {/* Grid de personas */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <PersonasGrid
          people={people}
          isLoading={isLoading}
          viewMode={viewMode}
        />

        {/* Paginaci√≥n */}
        {!isLoading && pagination.totalPages > 1 && (
          <div className="flex items-center justify-center gap-4 mt-8">
            <button
              onClick={() => handlePageChange(pagination.page - 1)}
              disabled={pagination.page === 1}
              className={`
                px-4 py-2 rounded-lg font-medium transition-all
                ${pagination.page === 1
                  ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                  : 'bg-gray-800 text-white hover:bg-gray-700'
                }
              `}
            >
              ‚Üê Anterior
            </button>

            <span className="text-gray-400">
              P√°gina {pagination.page} de {pagination.totalPages}
            </span>

            <button
              onClick={() => handlePageChange(pagination.page + 1)}
              disabled={pagination.page === pagination.totalPages}
              className={`
                px-4 py-2 rounded-lg font-medium transition-all
                ${pagination.page === pagination.totalPages
                  ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                  : 'bg-gray-800 text-white hover:bg-gray-700'
                }
              `}
            >
              Siguiente ‚Üí
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/listados/personas/PersonasFilters.tsx
// ==================================================
// src/app/(site)/listados/personas/PersonasFilters.tsx
'use client';

import { useMemo } from 'react';
import { 
  PersonListFilters, 
  FiltersDataResponse,
  GENDER_OPTIONS
} from '@/lib/people/personListTypes';
import { generateYearOptions } from '@/lib/people/personListUtils';

interface PersonasFiltersProps {
  filters: PersonListFilters;
  filtersData: FiltersDataResponse | null;
  isLoading: boolean;
  onFilterChange: <K extends keyof PersonListFilters>(key: K, value: PersonListFilters[K]) => void;
  onClearFilters: () => void;
}

export default function PersonasFilters({
  filters,
  filtersData,
  isLoading,
  onFilterChange,
  onClearFilters
}: PersonasFiltersProps) {
  // Generar arrays de a√±os para los selectores
  const birthYears = useMemo(() => {
    if (!filtersData?.years.birthYearMin || !filtersData?.years.birthYearMax) return [];
    return generateYearOptions(filtersData.years.birthYearMin, filtersData.years.birthYearMax);
  }, [filtersData?.years]);

  const deathYears = useMemo(() => {
    if (!filtersData?.years.deathYearMin || !filtersData?.years.deathYearMax) return [];
    return generateYearOptions(filtersData.years.deathYearMin, filtersData.years.deathYearMax);
  }, [filtersData?.years]);

  if (isLoading) {
    return (
      <div className="animate-pulse space-y-4">
        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="h-16 bg-gray-800 rounded-lg" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4 py-4 border-t border-gray-800">
      {/* Fila 1: Filtros principales */}
      <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-4">
        {/* G√©nero */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">G√©nero</label>
          <select
            value={filters.gender || ''}
            onChange={(e) => onFilterChange('gender', e.target.value as PersonListFilters['gender'])}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {GENDER_OPTIONS.filter(o => o.value !== '').map(option => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        </div>

        {/* Nacionalidad */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Nacionalidad</label>
          <select
            value={filters.nationalityId || ''}
            onChange={(e) => onFilterChange('nationalityId', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {filtersData?.nationalities.map(nat => (
              <option key={nat.id} value={nat.id}>
                {nat.name} ({nat.count})
              </option>
            ))}
          </select>
        </div>

        {/* Lugar de nacimiento */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Lugar de nacimiento</label>
          <select
            value={filters.birthLocationId || ''}
            onChange={(e) => onFilterChange('birthLocationId', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {filtersData?.birthLocations.map(loc => (
              <option key={loc.id} value={loc.id}>
                {loc.fullPath} ({loc.count})
              </option>
            ))}
          </select>
        </div>

        {/* Lugar de muerte */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Lugar de muerte</label>
          <select
            value={filters.deathLocationId || ''}
            onChange={(e) => onFilterChange('deathLocationId', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {filtersData?.deathLocations.map(loc => (
              <option key={loc.id} value={loc.id}>
                {loc.fullPath} ({loc.count})
              </option>
            ))}
          </select>
        </div>

        {/* Rol */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Rol</label>
          <select
            value={filters.roleId || ''}
            onChange={(e) => {
              const value = e.target.value;
              // ACTOR y SELF son strings especiales, el resto son IDs num√©ricos
              if (value === 'ACTOR' || value === 'SELF') {
                onFilterChange('roleId', value);
              } else if (value) {
                onFilterChange('roleId', parseInt(value));
              } else {
                onFilterChange('roleId', '');
              }
            }}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {filtersData?.roles.map(role => (
              <option key={role.id} value={role.id}>
                {role.name} ({role.count})
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Fila 2: Rangos de a√±os */}
      <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
        {/* A√±o de nacimiento desde */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Naci√≥ desde el a√±o</label>
          <select
            value={filters.birthYearFrom || ''}
            onChange={(e) => onFilterChange('birthYearFrom', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {birthYears.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>

        {/* A√±o de nacimiento hasta */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Naci√≥ hasta el a√±o</label>
          <select
            value={filters.birthYearTo || ''}
            onChange={(e) => onFilterChange('birthYearTo', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {birthYears.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>

        {/* A√±o de muerte desde */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Muri√≥ desde el a√±o</label>
          <select
            value={filters.deathYearFrom || ''}
            onChange={(e) => onFilterChange('deathYearFrom', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {deathYears.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>

        {/* A√±o de muerte hasta */}
        <div className="space-y-1">
          <label className="block text-xs text-gray-400 font-medium">Muri√≥ hasta el a√±o</label>
          <select
            value={filters.deathYearTo || ''}
            onChange={(e) => onFilterChange('deathYearTo', e.target.value ? parseInt(e.target.value) : '')}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
          >
            <option value=""></option>
            {deathYears.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>
      </div>

      {/* Bot√≥n limpiar filtros */}
      <div className="flex justify-end">
        <button
          onClick={onClearFilters}
          className="px-4 py-2 text-sm text-gray-400 hover:text-white transition-colors"
        >
          Limpiar filtros
        </button>
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/listados/personas/PersonasGrid.tsx
// ==================================================
// src/app/(site)/listados/personas/PersonasGrid.tsx
'use client';

import PersonCardCompact from './PersonCardCompact';
import PersonCardDetailed from './PersonCardDetailed';
import { PersonWithMovie, ViewMode } from '@/lib/people/personListTypes';

interface PersonasGridProps {
  people: PersonWithMovie[];
  isLoading: boolean;
  viewMode: ViewMode;
}

export default function PersonasGrid({ people, isLoading, viewMode }: PersonasGridProps) {
  
  if (isLoading) {
    return (
      <div className={
        viewMode === 'compact'
          ? "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6"
          : "grid grid-cols-1 lg:grid-cols-2 gap-4"
      }>
        {Array.from({ length: 12 }).map((_, i) => (
          <div key={i} className="animate-pulse">
            {viewMode === 'compact' ? (
              <>
                <div className="aspect-[3/4] bg-gray-800 rounded-lg mb-2" />
                <div className="h-4 bg-gray-800 rounded mb-1" />
                <div className="h-3 bg-gray-800 rounded w-2/3" />
              </>
            ) : (
              <div className="flex gap-4 p-4 bg-gray-900 rounded-lg">
                <div className="w-28 h-36 bg-gray-800 rounded-lg flex-shrink-0" />
                <div className="flex-1 space-y-2">
                  <div className="h-5 bg-gray-800 rounded w-3/4" />
                  <div className="h-4 bg-gray-800 rounded w-1/2" />
                  <div className="h-4 bg-gray-800 rounded w-2/3" />
                  <div className="h-4 bg-gray-800 rounded w-1/3" />
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    );
  }
  
  if (people.length === 0) {
    return (
      <div className="text-center py-16">
        <div className="text-gray-400 text-lg mb-2">
          No se encontraron personas con los filtros seleccionados
        </div>
        <p className="text-gray-500 text-sm">
          Intenta ajustar los filtros o limpiarlos para ver m√°s resultados
        </p>
      </div>
    );
  }
  
  if (viewMode === 'compact') {
    return (
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
        {people.map((person) => (
          <PersonCardCompact key={person.id} person={person} />
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
      {people.map((person) => (
        <PersonCardDetailed key={person.id} person={person} />
      ))}
    </div>
  );
}

// ==================================================
// src/app/(site)/listados/personas/PersonCardCompact.tsx
// ==================================================
// src/app/(site)/listados/personas/PersonCardCompact.tsx
'use client';

import Link from 'next/link';
import { PersonWithMovie } from '@/lib/people/personListTypes';
import { formatPersonName, calculateAge } from '@/lib/people/personListUtils';

interface PersonCardCompactProps {
  person: PersonWithMovie;
}

export default function PersonCardCompact({ person }: PersonCardCompactProps) {
  const personName = formatPersonName(person);
  const photoUrl = person.photoUrl;
  
  // Calcular edad
  const age = calculateAge(
    person.birthYear,
    person.birthMonth,
    person.birthDay,
    person.deathYear,
    person.deathMonth,
    person.deathDay
  );

  // Determinar si est√° fallecida
  const isDeceased = !!person.deathYear;

  return (
    <Link 
      href={`/persona/${person.slug}`}
      className="group block"
    >
      {/* Imagen rectangular con aspect ratio 3:4 */}
      <div className="relative aspect-[3/4] rounded-lg overflow-hidden bg-gray-800 mb-3 transition-transform duration-300 group-hover:scale-[1.02] shadow-lg">
        {photoUrl ? (
          <img
            src={photoUrl}
            alt={personName}
            className="w-full h-full object-cover"
            loading="lazy"
          />
        ) : (
          // Placeholder SVG
          <div className="w-full h-full flex flex-col items-center justify-center">
            <svg 
              className="w-16 h-16 text-gray-600 mb-2" 
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth="1.5" 
                d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" 
              />
            </svg>
            <span className="text-xs text-gray-500">Sin foto</span>
          </div>
        )}
        
        {/* Overlay en hover */}
        <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-black/0 to-black/0 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />

      </div>

      {/* Informaci√≥n */}
      <div className="space-y-1">
        <h3 className="font-medium text-white group-hover:text-orange-400 transition-colors line-clamp-2">
          {personName}
        </h3>
        
        {/* Fechas: 1950 - 2024 (74 a√±os) o solo 1950 si vive */}
        {person.birthYear && (
          <p className="text-sm text-gray-400">
            {person.birthYear}
            {isDeceased && ` - ${person.deathYear}`}
            {age !== null && !person.hideAge && ` (${age} a√±os)`}
          </p>
        )}

        {/* Cantidad de pel√≠culas si tiene */}
        {person.movieCount !== undefined && person.movieCount > 0 && (
          <p className="text-xs text-gray-500">
            {person.movieCount} pel√≠cula{person.movieCount !== 1 ? 's' : ''}
          </p>
        )}
      </div>
    </Link>
  );
}

// ==================================================
// src/app/(site)/listados/personas/PersonCardDetailed.tsx
// ==================================================
// src/app/(site)/listados/personas/PersonCardDetailed.tsx
'use client';

import Link from 'next/link';
import { PersonWithMovie } from '@/lib/people/personListTypes';
import { formatPersonName, formatPartialDate } from '@/lib/people/personListUtils';

interface PersonCardDetailedProps {
  person: PersonWithMovie;
}

export default function PersonCardDetailed({ person }: PersonCardDetailedProps) {
  const personName = formatPersonName(person);
  const photoUrl = person.photoUrl;

  // Formatear fecha de nacimiento
  const birthDateFormatted = formatPartialDate(
    person.birthYear,
    person.birthMonth,
    person.birthDay
  );

  // Usar el path completo que viene de la API
  const birthLocationFormatted = (person as any).birthLocationPath || null;
  const deathLocationFormatted = (person as any).deathLocationPath || null;

  // Determinar si est√° fallecida
  const isDeceased = !!person.deathYear;

  // Determinar el rol a mostrar (Actor/Actriz seg√∫n g√©nero)
  const getActorLabel = () => {
    if (person.gender === 'FEMALE') return 'Actriz';
    if (person.gender === 'MALE') return 'Actor';
    return 'Actor/Actriz';
  };

  // Formatear rol de la pel√≠cula destacada
  const getFeaturedRole = () => {
    if (!person.featuredMovie) return null;
    if (person.featuredMovie.role === 'Actor') {
      return getActorLabel();
    }
    return person.featuredMovie.role;
  };

  return (
    <Link 
      href={`/persona/${person.slug}`}
      className="group block"
    >
      <div className="flex gap-4 p-4 bg-gray-900/50 rounded-lg border border-gray-800 hover:border-gray-700 transition-all hover:bg-gray-900">
        {/* Imagen */}
        <div className="relative w-28 h-36 flex-shrink-0 rounded-lg overflow-hidden bg-gray-800">
          {photoUrl ? (
            <img
              src={photoUrl}
              alt={personName}
              className="w-full h-full object-cover"
              loading="lazy"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <svg 
                className="w-12 h-12 text-gray-600" 
                fill="none" 
                stroke="currentColor" 
                viewBox="0 0 24 24"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth="1.5" 
                  d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" 
                />
              </svg>
            </div>
          )}
        </div>

        {/* Informaci√≥n */}
        <div className="flex-1 min-w-0">
          {/* Nombre */}
          <h3 className="font-semibold text-white group-hover:text-orange-400 transition-colors text-lg">
            {personName}
          </h3>

          {/* Fecha y lugar de nacimiento */}
          {(birthDateFormatted || birthLocationFormatted) && (
            <p className="text-sm text-gray-400 mt-1">
              {birthDateFormatted && <span>n. {birthDateFormatted}</span>}
              {birthDateFormatted && birthLocationFormatted && ' ¬∑ '}
              {birthLocationFormatted && <span>{birthLocationFormatted}</span>}
            </p>
          )}

          {/* Fecha y lugar de muerte si aplica */}
          {isDeceased && (
            <p className="text-sm text-gray-500 mt-0.5">
              m. {formatPartialDate(person.deathYear, person.deathMonth, person.deathDay)}
              {deathLocationFormatted && ` ¬∑ ${deathLocationFormatted}`}
            </p>
          )}

          {/* Pel√≠cula destacada */}
          {person.featuredMovie && (
            <p className="text-sm text-gray-500 mt-2">
              <span className="text-orange-400/80">{getFeaturedRole()}</span>
              {' en '}
              <span className="text-gray-300 italic">
                {person.featuredMovie.title}
              </span>
              {person.featuredMovie.year && (
                <span className="text-gray-500"> ({person.featuredMovie.year})</span>
              )}
            </p>
          )}

          {/* Cantidad de pel√≠culas */}
          {person.movieCount !== undefined && person.movieCount > 0 && (
            <p className="text-xs text-gray-600 mt-2">
              {person.movieCount} pel√≠cula{person.movieCount !== 1 ? 's' : ''} en el sitio
            </p>
          )}
        </div>

        {/* Flecha de navegaci√≥n */}
        <div className="flex items-center text-gray-600 group-hover:text-orange-400 transition-colors">
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </div>
      </div>
    </Link>
  );
}

// ==================================================
// src/app/(site)/listados/personas/ViewToggle.tsx
// ==================================================
// src/app/(site)/listados/personas/ViewToggle.tsx
'use client';

import { ViewMode } from '@/lib/people/personListTypes';

interface ViewToggleProps {
  viewMode: ViewMode;
  onChange: (mode: ViewMode) => void;
}

export default function ViewToggle({ viewMode, onChange }: ViewToggleProps) {
  return (
    <div className="flex bg-gray-800 rounded-lg p-1">
      {/* Vista compacta (grid) */}
      <button
        onClick={() => onChange('compact')}
        className={`
          p-2 rounded-md transition-all
          ${viewMode === 'compact' 
            ? 'bg-gray-700 text-white' 
            : 'text-gray-400 hover:text-white'
          }
        `}
        title="Vista compacta"
        aria-label="Vista compacta"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
        </svg>
      </button>

      {/* Vista detallada (lista) */}
      <button
        onClick={() => onChange('detailed')}
        className={`
          p-2 rounded-md transition-all
          ${viewMode === 'detailed' 
            ? 'bg-gray-700 text-white' 
            : 'text-gray-400 hover:text-white'
          }
        `}
        title="Vista detallada"
        aria-label="Vista detallada"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
        </svg>
      </button>
    </div>
  );
}


// ==================================================
// src/app/(site)/page.tsx
// ==================================================
// src/app/page.tsx
'use client';

import { useHomeData } from '@/hooks/useHomeData';
import HeroSection from '@/components/home/HeroSection';
import MoviesGrid from '@/components/home/MoviesGrid';
import RecentMoviesSection from '@/components/home/RecentMoviesSection';
import RecentPeopleSection from '@/components/home/RecentPeopleSection';
import ObituariosSection from '@/components/home/ObituariosSection';
import EfemeridesSection from '@/components/home/EfemeridesSection';
import ErrorMessage from '@/components/home/ErrorMessage';
import { HeroMovie, Efemeride } from '@/types/home.types';
import { formatPartialDate } from '@/lib/shared/dateUtils';
import HomeMiddleBanner from '@/components/ads/HomeMiddleBanner'
import HomeBottomBanner from '@/components/ads/HomeBottomBanner'
import { useState, useEffect } from 'react';
import Image from 'next/image';
import Link from 'next/link';

export default function HomePage() {
  const {
    ultimosEstrenos,
    proximosEstrenos,
    ultimasPeliculas,
    ultimasPersonas,
    loadingEstrenos,
    loadingProximos,
    loadingRecientes,
    error,
    retry
  } = useHomeData();

  const [obituarios, setObituarios] = useState<any[]>([]);
  const [loadingObituarios, setLoadingObituarios] = useState(true);
  const [efemerides, setEfemerides] = useState<Efemeride[]>([]);
  const [loadingEfemerides, setLoadingEfemerides] = useState(true);
  
  // Estado para im√°genes del hero
  const [heroImages, setHeroImages] = useState<any[]>([]);
  const [loadingHero, setLoadingHero] = useState(true);

  // Funci√≥n para calcular fecha efectiva de personas
  const calcularFechaEfectivaPersona = (person: any, type: 'birth' | 'death') => {
    const prefix = type === 'birth' ? 'birth' : 'death';
    const year = person[`${prefix}Year`];
    const month = person[`${prefix}Month`] || 12;
    const day = person[`${prefix}Day`] || new Date(year, month, 0).getDate();

    return new Date(year, month - 1, day);
  };

  // Fetch im√°genes del hero
  useEffect(() => {
    const fetchHeroImages = async () => {
      try {
        setLoadingHero(true);
        const response = await fetch('/api/images/hero');
        
        if (!response.ok) {
          throw new Error('Error al cargar im√°genes del hero');
        }
        
        const data = await response.json();
        setHeroImages(data.images || []);
      } catch (error) {
        console.error('Error fetching hero images:', error);
        setHeroImages([]);
      } finally {
        setLoadingHero(false);
      }
    };

    fetchHeroImages();
  }, []);

  // Fetch obituarios
  useEffect(() => {
    const fetchObituarios = async () => {
      try {
        setLoadingObituarios(true);

        const params = {
          limit: '50',
          hasDeathDate: 'true',
          sortBy: 'deathDate',
          sortOrder: 'desc'
        };

        const response = await fetch(`/api/people?${new URLSearchParams(params)}`);

        if (!response.ok) {
          throw new Error('Error al cargar obituarios');
        }

        const data = await response.json();

        const personasConFecha = data.data.filter((person: any) => person.deathYear);

        const personasOrdenadas = personasConFecha.sort((a: any, b: any) => {
          const dateA = calcularFechaEfectivaPersona(a, 'death');
          const dateB = calcularFechaEfectivaPersona(b, 'death');
          return dateB.getTime() - dateA.getTime();
        });

        setObituarios(personasOrdenadas.slice(0, 2));
      } catch (error) {
        console.error('Error fetching obituarios:', error);
        setObituarios([]);
      } finally {
        setLoadingObituarios(false);
      }
    };

    fetchObituarios();
  }, []);

  // Fetch efem√©rides
  useEffect(() => {
    const fetchEfemerides = async () => {
      try {
        setLoadingEfemerides(true);

        const response = await fetch('/api/efemerides');

        if (!response.ok) {
          const errorData = await response.text();
          console.error('Error response:', errorData);
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.efemerides && data.efemerides.length > 0) {
          if (data.efemerides.length <= 2) {
            setEfemerides(data.efemerides);
          } else {
            const shuffled = [...data.efemerides];
            for (let i = shuffled.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            const dosAleatorias = shuffled.slice(0, 2);
            setEfemerides(dosAleatorias);
          }
        } else {
          setEfemerides([]);
        }
      } catch (error) {
        console.error('Error fetching efem√©rides:', error);
        setEfemerides([]);
      } finally {
        setLoadingEfemerides(false);
      }
    };

    fetchEfemerides();
  }, []);


  // Formateador para fechas futuras (pr√≥ximos estrenos)
  const formatearFechaEstreno = (movie: any): string => {
    if (!movie.releaseYear) return 'Fecha por confirmar';

    if (!movie.releaseMonth) {
      return movie.releaseYear.toString();
    }

    const meses = [
      'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
      'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
    ];

    if (!movie.releaseDay) {
      return `${meses[movie.releaseMonth - 1]} ${movie.releaseYear}`;
    }

    return `${movie.releaseDay} de ${meses[movie.releaseMonth - 1].toLowerCase()} de ${movie.releaseYear}`;
  };

  return (
    <div className="bg-cine-dark text-white min-h-screen">
      {/* Hero Section con im√°genes din√°micas */}
      {!loadingHero && heroImages.length > 0 && (
        <HeroSection images={heroImages} />
      )}
      
      <div className="bg-cine-dark">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">

          {error && <ErrorMessage message={error} onRetry={retry} />}

          {/* Secci√≥n de √öltimos Estrenos */}
          <MoviesGrid
            title="√öltimos estrenos"
            movies={ultimosEstrenos}
            loading={loadingEstrenos}
            emptyMessage="No hay estrenos disponibles en este momento"
            showDate={true}
            dateType="past"
            dateFormatter={formatearFechaEstreno}
            ctaText="Ver m√°s estrenos"
            ctaHref="/listados/estrenos"
          />

          {/* Secci√≥n de Pr√≥ximos Estrenos */}
          <MoviesGrid
            title="Pr√≥ximos estrenos"
            movies={proximosEstrenos}
            loading={loadingProximos}
            emptyMessage="No hay pr√≥ximos estrenos confirmados"
            showDate={true}
            dateType="future"
            dateFormatter={formatearFechaEstreno}
            ctaText="Ver m√°s pr√≥ximos estrenos"
            ctaHref="/listados/estrenos?period=upcoming"
          />

          {/* Grid de Obituarios y Efem√©rides */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
            <ObituariosSection
              obituarios={obituarios}
              loading={loadingObituarios}
            />
            <EfemeridesSection efemerides={efemerides} />
          </div>

          <HomeMiddleBanner />

          <div className="w-full flex justify-center py-4 bg-cine-dark">
            <Link
              href="https://www.ucine.edu.ar"
              target="_blank"
              rel="noopener noreferrer"
              className="block max-w-[601px] w-full px-4"
            >
              <Image
                src="/fuc.png"
                alt="Programas de formaci√≥n UCINE"
                width={601}
                height={101}
                className="w-full h-auto"
                priority
              />
            </Link>
          </div>
          
          {/* √öltimas Pel√≠culas Ingresadas */}
          <RecentMoviesSection
            movies={ultimasPeliculas}
            loading={loadingRecientes}
          />
          
          <HomeBottomBanner />
          
          {/* √öltimas Personas Ingresadas */}
          <RecentPeopleSection
            people={ultimasPersonas}
            loading={loadingRecientes}
          />
        </div>
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/pelicula/[slug]/loading.tsx
// ==================================================
// src/app/pelicula/[slug]/loading.tsx
export default function Loading() {
  return (
    <div className="bg-gray-900 text-white min-h-screen flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400 mx-auto"></div>
        <p className="mt-4 text-gray-400">Cargando...</p>
      </div>
    </div>
  );
}

// ==================================================
// src/app/(site)/pelicula/[slug]/MoviePageClient.tsx
// ==================================================
// src/app/pelicula/[slug]/MoviePageClient.tsx

'use client';

import { TrailerSection } from "@/components/movies/TrailerSection";
import { MovieHero } from "@/components/movies/MovieHero";
import { CastSection } from "@/components/movies/CastSection";
import { CrewSection } from "@/components/movies/CrewSection";
import { MoviePoster } from "@/components/movies/MoviePoster";
import { MovieInfo } from "@/components/movies/MovieInfo";
import { MovieSidebar } from "@/components/movies/MovieSidebar";
import { ImageGallery } from "@/components/movies/ImageGallery";
import { SimilarMovies } from "@/components/movies/SimilarMovies";
import { usePageView } from '@/hooks/usePageView';

// Componente de anuncios
import AdBanner from "@/components/ads/AdBanner";

interface CastMember {
    name: string;
    character: string;
    image?: string;
    isPrincipal?: boolean;
    billingOrder?: number;
    personId?: number;
    personSlug?: string;
}

interface CrewMember {
    name: string;
    role: string;
    personSlug?: string;
}

interface CrewDepartment {
    [department: string]: CrewMember[];
}

// Tipo para las im√°genes de galer√≠a con datos para caption
interface GalleryImage {
    id: number;
    url: string;
    cloudinaryPublicId: string;
    type: string;
    eventName?: string | null;
    people: Array<{
        personId: number;
        position: number;
        person: {
            id: number;
            firstName?: string | null;
            lastName?: string | null;
        }
    }>;
    movie?: {
        id: number;
        title: string;
        releaseYear?: number | null;
    } | null;
}

interface MoviePageClientProps {
    movie: any;
    displayYear: number | null;
    totalDuration: number;
    durationSeconds?: number | null;
    genres: Array<{ id: number; name: string }>;
    themes: Array<{ id: number; name: string }>;
    countries: Array<{ id: number; name: string }>;
    rating?: { id: number; name: string; description?: string; abbreviation?: string | null } | null;
    colorType?: { id: number; name: string } | null;
    soundType?: string | null;
    mainCast: CastMember[];
    fullCast: CastMember[];
    basicCrew: CrewDepartment;
    fullCrew: CrewDepartment;
    premiereVenues: string;
    releaseDate?: {
        day: number | null;
        month: number | null;
        year: number | null;
    } | null;
    heroBackgroundImage?: string | null;
    galleryImages?: GalleryImage[];
}

// Slots de AdSense - Reemplazar con tus IDs reales
const AD_SLOTS = {
    // HERO: '1634150481',         // Ya est√° en el header global
    POST_INFO: '8509488902',    // Despu√©s de MovieInfo (in-article)
    SIDEBAR: '8621169545',      // Sidebar sticky
    CAST_CREW: '7432210959',    // Entre Cast y Crew (in-article)
    PRE_TRAILER: '7308087870',  // Antes del trailer (in-article)
    MULTIPLEX: '6191938018',    // Final de p√°gina (multiplex)
};

export function MoviePageClient({
    movie,
    displayYear,
    totalDuration,
    durationSeconds,
    genres,
    themes,
    countries,
    rating,
    colorType,
    soundType,
    mainCast,
    fullCast,
    basicCrew,
    fullCrew,
    premiereVenues,
    releaseDate,
    heroBackgroundImage,
    galleryImages = []
}: MoviePageClientProps) {
    usePageView({ pageType: 'MOVIE', movieId: movie.id });

    // Mostrar anuncio entre cast y crew solo si hay contenido suficiente
    const showCastCrewAd = mainCast.length > 3 || fullCast.length > 5;

    return (
        <div className="bg-cine-dark text-white min-h-screen">
            {/* Movie Hero Background - ACTUALIZADO CON DATOS REALES */}
            <MovieHero
                title={movie.title}
                year={displayYear}
                duration={totalDuration}
                genres={genres.map(g => g.name)}
                posterUrl={movie.posterUrl}
                releaseDate={releaseDate}
                premiereVenues={premiereVenues}
                rating={rating}
                heroBackgroundImage={heroBackgroundImage}
            />

            {/* Movie Content */}
            <div className="bg-cine-dark">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        {/* Poster */}
                        <div className="lg:col-span-1">
                            <MoviePoster
                                title={movie.title}
                                imageUrl={movie.posterUrl}
                            />
                        </div>

                        {/* Movie Info */}
                        <div className="lg:col-span-2">
                            <MovieInfo
                                movie={movie}
                                onTrailerClick={() => {
                                    const trailerSection = document.querySelector('#trailer-section');
                                    trailerSection?.scrollIntoView({ behavior: 'smooth' });
                                }}
                                onShareClick={() => {
                                    if (navigator.share) {
                                        navigator.share({
                                            title: movie.title,
                                            text: `Mira ${movie.title} - Pel√≠cula argentina`,
                                            url: window.location.href
                                        });
                                    }
                                }}
                            />
                        </div>
                    </div>
                </div>
            </div>

            {/* üì¢ AD #2: Despu√©s de MovieInfo - Transici√≥n natural */}
            <AdBanner slot={AD_SLOTS.POST_INFO} format="in-article" />

            {/* Technical Info */}
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    {/* Cast & Crew */}
                    <div className="lg:col-span-2">
                        <h2 className="serif-heading text-2xl mb-6 text-white">Reparto y Equipo</h2>

                        {/* Cast - AHORA CON DATOS REALES DE LA BD */}
                        <CastSection
                            mainCast={mainCast}
                            fullCast={fullCast}
                        />

                        {/* üì¢ AD #3: Entre Cast y Crew (condicional) */}
                        {/*showCastCrewAd && (
                            <AdBanner slot={AD_SLOTS.CAST_CREW} format="in-article" />
                        )*/}

                        {/* Crew - AHORA CON DATOS REALES DE LA BD */}
                        <CrewSection
                            basicCrew={basicCrew}
                            fullCrew={fullCrew}
                        />
                    </div>

                    {/* Sidebar Info */}
                    <div className="lg:col-span-1">
                        <MovieSidebar
                            year={movie.year}
                            releaseYear={movie.releaseYear}
                            duration={totalDuration}
                            durationSeconds={durationSeconds}
                            countries={countries}
                            rating={rating}
                            colorType={colorType}
                            soundType={soundType}
                            genres={genres}
                            themes={themes}
                        />

                        {/* üì¢ AD #4: Sidebar sticky - solo desktop */}
                      {/*  <div className="mt-8 hidden lg:block">
                            <AdBanner slot={AD_SLOTS.SIDEBAR} format="sidebar" />
                        </div>*/}
                    </div>
                </div>
            </div>

            {/* Image Gallery - Solo se muestra si hay im√°genes */}
            {galleryImages.length > 0 && (
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 border-t border-gray-800">
                    <h2 className="serif-heading text-2xl text-white mb-6">Galer√≠a de Im√°genes</h2>
                    <ImageGallery
                        images={galleryImages}
                        movieTitle={movie.title}
                    />
                </div>
            )}

            {/* Trailer - Solo se muestra si hay URL */}
            {movie.trailerUrl && (
                <>
                    {/* üì¢ AD #5: Antes del trailer - Alto engagement */}
                    <AdBanner slot={AD_SLOTS.PRE_TRAILER} format="in-article" />

                    <TrailerSection
                        trailerUrl={movie.trailerUrl}
                        movieTitle={movie.title}
                    />
                </>
            )}

            {/* üì¢ AD #6: Multiplex al final - Recomendaciones */}
            <div className="border-t border-gray-800">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                    <p className="text-sm text-gray-500 mb-4">Tambi√©n te puede interesar</p>
                    <AdBanner slot={AD_SLOTS.MULTIPLEX} format="multiplex" />
                </div>
            </div>

            {/* Similar Movies - TODO: Implementar con datos reales
            <SimilarMovies
                movies={[
                    {
                        title: 'El Secreto de sus Ojos',
                        year: '2009',
                        slug: 'el-secreto-de-sus-ojos'
                    },
                    {
                        title: 'Nueve Reinas',
                        year: '2000',
                        slug: 'nueve-reinas'
                    },
                    {
                        title: 'El Hijo de la Novia',
                        year: '2001',
                        slug: 'el-hijo-de-la-novia'
                    },
                    {
                        title: 'La Historia Oficial',
                        year: '1985',
                        slug: 'la-historia-oficial'
                    }
                ]}
            />
            */}
        </div>
    );
}

// ==================================================
// src/app/(site)/pelicula/[slug]/page.tsx
// ==================================================
// src/app/pelicula/[slug]/page.tsx - USAR PRISMA DIRECTO (mejor para SSR)
import { notFound } from 'next/navigation';
import { MoviePageClient } from './MoviePageClient';
import type { Metadata } from 'next';
import { prisma } from '@/lib/prisma';

interface PageProps {
  params: {
    slug: string;
  };
}

// Configuraci√≥n de p√°gina din√°mica
export const dynamic = 'force-dynamic';
export const revalidate = 3600; // 1 hora
export const dynamicParams = true;

export async function generateStaticParams() {
  return [];
}

// Funci√≥n para construir URL de Cloudinary - mismo formato que HeroSection
function buildCloudinaryUrl(publicId: string): string {
  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;
  return `https://res.cloudinary.com/${cloudName}/image/upload/w_1280,q_auto,f_auto/${publicId}`;
}

// Funci√≥n para obtener pel√≠cula directamente de Prisma (para SSR)
async function getMovieData(slug: string) {
  try {
    console.log(`üì° Fetching movie from database: ${slug}`);
    
    const movie = await prisma.movie.findFirst({
      where: { slug: slug },
      select: {
        // Campos b√°sicos - optimizado con select
        id: true,
        slug: true,
        title: true,
        year: true,
        releaseYear: true,
        releaseMonth: true,
        releaseDay: true,
        duration: true,
        durationSeconds: true,
        synopsis: true,
        posterUrl: true,
        trailerUrl: true,
        soundType: true,
        stage: true,
        dataCompleteness: true,
        notes: true,
        tagline: true,
        imdbId: true,
        metaDescription: true,
        metaKeywords: true,
        
        // Relaciones optimizadas
        genres: {
          select: {
            genre: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          }
        },
        
        cast: {
          select: {
            characterName: true,
            isPrincipal: true,
            billingOrder: true,
            alternativeNameId: true,  // üÜï ID del nombre alternativo usado
            alternativeName: {        // üÜï Datos del nombre alternativo
              select: {
                id: true,
                fullName: true
              }
            },
            person: {
              select: {
                id: true,
                slug: true,
                firstName: true,
                lastName: true,
                realName: true,
                photoUrl: true,
                gender: true  // üÜï G√©nero para "Acreditado/a"
              }
            }
          },
          orderBy: [
            { isPrincipal: 'desc' },
            { billingOrder: 'asc' }
          ],
          
        },
        
        crew: {
          select: {
            roleId: true,
            billingOrder: true,
            alternativeNameId: true,  // üÜï ID del nombre alternativo usado
            alternativeName: {        // üÜï Datos del nombre alternativo
              select: {
                id: true,
                fullName: true
              }
            },
            person: {
              select: {
                id: true,
                slug: true,
                firstName: true,
                lastName: true,
                realName: true,
                gender: true  // üÜï G√©nero para "Acreditado/a"
              }
            },
            role: {
              select: {
                id: true,
                name: true,
                department: true
              }
            }
          },
          orderBy: {
            billingOrder: 'asc'
          },
          
        },
        
        movieCountries: {
          select: {
            location: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          }
        },
        
        themes: {
          select: {
            theme: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          },
          take: 20
        },
        
        rating: {
          select: {
            id: true,
            name: true,
            description: true,
            abbreviation: true
          }
        },
        
        colorType: {
          select: {
            id: true,
            name: true,
            category: true
          }
        },
        
        productionCompanies: {
          select: {
            isPrimary: true,
            company: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          },
          take: 10
        },
        
        distributionCompanies: {
          select: {
            territory: true,
            company: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          },
          take: 10
        },
        
        screenings: {
          where: {
            isPremiere: true
          },
          select: {
            venue: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        
        // Im√°genes de la pel√≠cula para el hero y galer√≠a
        images: {
          select: {
            id: true,
            cloudinaryPublicId: true,
            type: true,
            eventName: true,
            people: {
              select: {
                personId: true,
                position: true,
                person: {
                  select: {
                    id: true,
                    firstName: true,
                    lastName: true
                  }
                }
              },
              orderBy: {
                position: 'asc'
              }
            }
          }
        },
        
        _count: {
          select: {
            images: true,
            videos: true,
            alternativeTitles: true,
            links: true,
            awards: true,
            screenings: true
          }
        }
      }
    });
    
    if (movie) {
      console.log(`‚úÖ Movie found: ${movie.title}`);
      console.log(`üñºÔ∏è Images found: ${movie.images?.length || 0}`);
    } else {
      console.log(`‚ùå Movie not found: ${slug}`);
    }
    
    return movie;
  } catch (error) {
    console.error('Error fetching movie:', error);
    return null;
  }
}

// Metadata din√°mica
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const movie = await getMovieData(params.slug);

  if (!movie) {
    return {
      title: 'Pel√≠cula no encontrada - cinenacional.com',
      description: 'La pel√≠cula que busc√°s no existe o fue eliminada.'
    };
  }

  const year = movie.year || movie.releaseYear;
  const genres = movie.genres?.map(g => g.genre.name).slice(0, 3).join(', ');
  const defaultDescription = `${movie.title}${year ? ` (${year})` : ''}${genres ? ` - ${genres}` : ''}. Pel√≠cula argentina.`;

  return {
    title: `${movie.title}${year ? ` (${year})` : ''} - cinenacional.com`,
    description: movie.metaDescription || movie.synopsis?.substring(0, 160) || defaultDescription,
    keywords: movie.metaKeywords?.join(', ') || `${movie.title}, cine argentino, pel√≠cula argentina${genres ? `, ${genres}` : ''}`,
    openGraph: {
      title: movie.title,
      description: movie.synopsis?.substring(0, 160) || defaultDescription,
      images: movie.posterUrl ? [movie.posterUrl] : [],
      type: 'video.movie',
    },
    twitter: {
      card: 'summary_large_image',
      title: movie.title,
      description: movie.synopsis?.substring(0, 160) || defaultDescription,
      images: movie.posterUrl ? [movie.posterUrl] : [],
    }
  };
}

// Funci√≥n helper para formatear el nombre completo de una persona
function formatPersonName(person: any): string {
  const parts = [];
  if (person.firstName) parts.push(person.firstName);
  if (person.lastName) parts.push(person.lastName);
  return parts.join(' ') || person.realName || 'Sin nombre';
}

// Funci√≥n helper para formatear las pantallas de estreno
function formatPremiereVenues(venues: any[]): string {
  if (!venues || venues.length === 0) return '';
  
  const venueNames = venues.map(v => v.venue.name);
  
  if (venueNames.length === 1) {
    return venueNames[0];
  } else if (venueNames.length === 2) {
    return `${venueNames[0]} y ${venueNames[1]}`;
  } else {
    // 3 o m√°s: "A, B y C"
    const lastVenue = venueNames[venueNames.length - 1];
    const otherVenues = venueNames.slice(0, -1).join(', ');
    return `${otherVenues} y ${lastVenue}`;
  }
}

// Tipo para las im√°genes que vienen de la BD
interface MovieImageFromDB {
  id: number;
  cloudinaryPublicId: string;
  type: string;
  eventName?: string | null;
  people: Array<{
    personId: number;
    position: number;
    person: {
      id: number;
      firstName?: string | null;
      lastName?: string | null;
    }
  }>;
}

// Tipo para las im√°genes de galer√≠a (para el cliente)
interface GalleryImage {
  id: number;
  url: string;
  cloudinaryPublicId: string;
  type: string;
  eventName?: string | null;
  people: Array<{
    personId: number;
    position: number;
    person: {
      id: number;
      firstName?: string | null;
      lastName?: string | null;
    }
  }>;
  movie?: {
    id: number;
    title: string;
    releaseYear?: number | null;
  } | null;
}

// Funci√≥n para seleccionar una imagen al azar para el hero
function getRandomHeroImage(images: MovieImageFromDB[]): string | null {
  if (!images || images.length === 0) {
    return null;
  }
  
  // Seleccionar una imagen al azar
  const randomIndex = Math.floor(Math.random() * images.length);
  const selectedImage = images[randomIndex];
  
  // Construir URL de Cloudinary optimizada para hero
  return buildCloudinaryUrl(selectedImage.cloudinaryPublicId);
}

// Funci√≥n para construir los datos de galer√≠a con informaci√≥n para captions
function buildGalleryImages(
  images: MovieImageFromDB[], 
  movie: { id: number; title: string; releaseYear?: number | null }
): GalleryImage[] {
  if (!images || images.length === 0) {
    return [];
  }
  
  return images.map(img => ({
    id: img.id,
    url: buildCloudinaryUrl(img.cloudinaryPublicId),
    cloudinaryPublicId: img.cloudinaryPublicId,
    type: img.type,
    eventName: img.eventName,
    people: img.people,
    movie: {
      id: movie.id,
      title: movie.title,
      releaseYear: movie.releaseYear
    }
  }));
}

export default async function MoviePage({ params }: PageProps) {
  const movie = await getMovieData(params.slug);

  if (!movie) {
    notFound();
  }

  // Formatear duraci√≥n total en minutos
  const totalDuration = movie.duration || 0;

  // Procesar g√©neros con estructura correcta
  const genres = movie.genres?.map((g: any) => ({
    id: g.genre.id,
    name: g.genre.name
  })).filter(Boolean) || [];

  // Procesar temas con estructura correcta
  const themes = movie.themes?.map((t: any) => ({
    id: t.theme.id,
    name: t.theme.name
  })).filter(Boolean) || [];

  // Procesar pa√≠ses coproductores (excluyendo Argentina si es el √∫nico)
  const countries = movie.movieCountries?.map((c: any) => ({
    id: c.location.id,
    name: c.location.name
  }))
    .filter((c: any) => c.name !== 'Argentina' || movie.movieCountries.length > 1) || [];

  // Procesar pantallas de estreno
  const premiereVenues = formatPremiereVenues(movie.screenings || []);

  const rating = movie.rating ? {
    id: movie.rating.id,
    name: movie.rating.name,
    description: movie.rating.description || undefined,
    abbreviation: movie.rating.abbreviation || undefined
  } : null; 

  const colorType = movie.colorType ? {
    id: movie.colorType.id,
    name: movie.colorType.name
  } : null;

  // Formatear a√±o - usar releaseYear si existe, sino year
  const displayYear = movie.year || movie.releaseYear;

  // Obtener imagen aleatoria para el hero
  const heroBackgroundImage = getRandomHeroImage(movie.images || []);

  // Obtener todas las im√°genes para la galer√≠a con datos para caption
  const galleryImages = buildGalleryImages(movie.images || [], {
    id: movie.id,
    title: movie.title,
    releaseYear: movie.releaseYear || movie.year
  });

  // PROCESAR CAST - üÜï Incluir alternativeName y gender
  const allCast = movie.cast?.map((c: any) => ({
    name: formatPersonName(c.person),
    character: c.characterName,
    isPrincipal: c.isPrincipal || false,
    billingOrder: c.billingOrder || 999,
    personId: c.person.id,
    personSlug: c.person.slug,
    image: c.person.photoUrl || undefined,
    // üÜï Campos para "Acreditado/a como"
    creditedAs: c.alternativeName?.fullName || null,
    gender: c.person.gender || null
  })) || [];

  // Log reducido en producci√≥n
  if (process.env.NODE_ENV === 'development') {
    console.log('Pel√≠cula:', movie.title);
    console.log('Total de actores:', allCast.length);
    console.log('Actores con isPrincipal:', allCast.filter((c: any) => c.isPrincipal).length);
    console.log('Hero background image:', heroBackgroundImage ? 'S√≠' : 'No (usando placeholder)');
  }

  // Separar cast principal del cast completo
  let mainCast: any[] = [];
  let fullCast: any[] = [];

  const principalActors = allCast.filter((c: any) => c.isPrincipal === true);

  if (principalActors.length > 0) {
    mainCast = principalActors;
    fullCast = allCast.filter((c: any) => !c.isPrincipal);
  } else if (allCast.length > 0) {
    mainCast = allCast.slice(0, Math.min(3, allCast.length));
    if (allCast.length > 3) {
      fullCast = allCast.slice(3);
    }
  }

  // PROCESAR CREW - üÜï Incluir alternativeName y gender
  const mainCrewRoleIds = [2, 3, 703, 526, 836, 636, 402, 641];

  const mainRoleDepartmentMap: { [key: number]: string } = {
    2: 'Direcci√≥n',
    3: 'Gui√≥n',
    703: 'Producci√≥n Ejecutiva',
    526: 'Direcci√≥n de Fotograf√≠a',
    836: 'Direcci√≥n de Arte',
    636: 'Montaje',
    402: 'Direcci√≥n de Sonido',
    641: 'M√∫sica'
  };

  const allCrew = movie.crew?.map((c: any) => ({
    name: formatPersonName(c.person),
    role: c.role?.name || 'Sin rol especificado',
    roleId: c.roleId,
    department: c.role?.department || 'Otros',
    billingOrder: c.billingOrder || 999,
    personId: c.person.id,
    personSlug: c.person.slug,
    // üÜï Campos para "Acreditado/a como"
    creditedAs: c.alternativeName?.fullName || null,
    gender: c.person.gender || null
  })) || [];

  const basicCrewMembers = allCrew.filter((c: any) => mainCrewRoleIds.includes(c.roleId));

  const basicCrewByDepartment: { [department: string]: Array<{ name: string; role: string; personSlug?: string; creditedAs?: string | null; gender?: string | null }> } = {};

  const mainDepartmentOrder = [
    'Direcci√≥n',
    'Gui√≥n',
    'Producci√≥n Ejecutiva',
    'Direcci√≥n de Fotograf√≠a',
    'Direcci√≥n de Arte',
    'Montaje',
    'Direcci√≥n de Sonido',
    'M√∫sica'
  ];

  mainDepartmentOrder.forEach(dept => {
    basicCrewByDepartment[dept] = [];
  });

  basicCrewMembers.forEach((member: any) => {
    const dept = mainRoleDepartmentMap[member.roleId] || member.department || 'Otros';
    if (!basicCrewByDepartment[dept]) {
      basicCrewByDepartment[dept] = [];
    }
    basicCrewByDepartment[dept].push({
      name: member.name,
      role: member.role,
      personSlug: member.personSlug,
      creditedAs: member.creditedAs,  // üÜï
      gender: member.gender           // üÜï
    });
  });

  Object.keys(basicCrewByDepartment).forEach(dept => {
    if (basicCrewByDepartment[dept].length === 0) {
      delete basicCrewByDepartment[dept];
    }
  });

  const fullCrewByDepartment: { [department: string]: Array<{ name: string; role: string; personSlug?: string; creditedAs?: string | null; gender?: string | null }> } = {};

  allCrew
    .sort((a: any, b: any) => {
      if (a.department !== b.department) {
        return (a.department || 'Otros').localeCompare(b.department || 'Otros');
      }
      return a.billingOrder - b.billingOrder;
    })
    .forEach((member: any) => {
      const dept = member.department || mainRoleDepartmentMap[member.roleId] || 'Otros';

      if (!fullCrewByDepartment[dept]) {
        fullCrewByDepartment[dept] = [];
      }

      fullCrewByDepartment[dept].push({
        name: member.name,
        role: member.role,
        personSlug: member.personSlug,
        creditedAs: member.creditedAs,  // üÜï
        gender: member.gender           // üÜï
      });
    });

  if (process.env.NODE_ENV === 'development') {
    console.log('Departamentos en crew principal:', Object.keys(basicCrewByDepartment));
    console.log('Departamentos en crew completo:', Object.keys(fullCrewByDepartment));
  }

  return (
    <MoviePageClient
      movie={{
        ...movie,
        hasImages: movie._count.images > 0,
        hasVideos: movie._count.videos > 0,
        hasAlternativeTitles: movie._count.alternativeTitles > 0,
        hasLinks: movie._count.links > 0,
        hasAwards: movie._count.awards > 0,
        imageCount: movie._count.images,
        videoCount: movie._count.videos
      }}
      displayYear={displayYear}
      totalDuration={totalDuration}
      durationSeconds={movie.durationSeconds}
      genres={genres}
      themes={themes}
      countries={countries}
      rating={rating}
      colorType={colorType}
      soundType={movie.soundType}
      mainCast={mainCast}
      fullCast={fullCast}
      basicCrew={basicCrewByDepartment}
      fullCrew={fullCrewByDepartment}
      premiereVenues={premiereVenues}
      releaseDate={
        movie.releaseDay && movie.releaseMonth && movie.releaseYear
          ? {
              day: movie.releaseDay,
              month: movie.releaseMonth,
              year: movie.releaseYear
            }
          : null
      }
      heroBackgroundImage={heroBackgroundImage}
      galleryImages={galleryImages}
    />
  );
}

// ==================================================
// src/app/(site)/persona/[slug]/page.tsx
// ==================================================
// src/app/persona/[slug]/page.tsx - VERSI√ìN CON 2 PESTA√ëAS: "Todos los roles" y "Por rol"
'use client';

import { useState, useEffect, useCallback } from 'react';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import { formatPartialDate, MONTHS } from '@/lib/shared/dateUtils';
import DOMPurify from 'isomorphic-dompurify';
import { trackPageView } from '@/hooks/usePageView';
import { ImageGallery } from '@/components/movies/ImageGallery';

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

// Funci√≥n helper para formatear ubicaci√≥n recursivamente (cualquier profundidad)
function formatLocationPath(location: any): string {
  if (!location) return '';

  const parts: string[] = [];
  let current = location;

  while (current) {
    parts.push(current.name);
    current = current.parent;
  }

  return parts.join(', ');
}

// Helper para obtener etiqueta de "acreditado/a" seg√∫n g√©nero
function getCreditedLabel(gender?: string | null): string {
  return gender === 'FEMALE' ? 'Tambi√©n acreditada como' : 'Tambi√©n acreditado como';
}

interface PersonPageProps {
  params: {
    slug: string;
  };
}


interface Movie {
  id: number;
  slug: string;
  title: string;
  year?: number;
  releaseYear?: number;
  releaseMonth?: number;
  releaseDay?: number;
  tipoDuracion?: 'largometraje' | 'mediometraje' | 'cortometraje';
  stage?: string;
}
interface Role {
  id: number;
  name: string;
  slug: string;
  department?: string;
}

interface CastRole {
  movie: Movie;
  characterName?: string;
  billingOrder?: number;
  isPrincipal?: boolean;
  isActor?: boolean; // true = actor, false = aparici√≥n como s√≠ mismo
}

interface CrewRole {
  movie: Movie;
  role: Role;
  roleId: number;
  department?: string;
  billingOrder?: number;
}

interface GroupedCrewRole {
  movie: Movie;
  roles: string[];
}

interface TabItem extends GroupedCrewRole {
  characterName?: string;
}

// Interfaz para "Todos los roles"
interface AllRolesItem {
  movie: Movie;
  rolesDisplay: string[]; // Array de roles formateados para mostrar
}

// Interfaz para secciones de "Por rol"
interface RoleSection {
  roleName: string;
  items: TabItem[];
}

// Interfaz para nombres alternativos
interface AlternativeName {
  id: number;
  fullName: string;
}

// Interfaz para im√°genes de galer√≠a
interface GalleryImage {
  id: number;
  url: string;
  cloudinaryPublicId: string;
  type: string;
  eventName?: string | null;
  people: Array<{
    personId: number;
    position: number;
    person: {
      id: number;
      firstName?: string | null;
      lastName?: string | null;
    }
  }>;
  movie?: {
    id: number;
    title: string;
    releaseYear?: number | null;
  } | null;
}

export default function PersonPage({ params }: PersonPageProps) {
  const [person, setPerson] = useState<any>(null);
  const [filmography, setFilmography] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<string>('Todos los roles');
  const [showAllFilmography, setShowAllFilmography] = useState(false);

  // ‚úÖ Agregar tracking cuando la persona est√© cargada
  useEffect(() => {
    if (person?.id) {
      trackPageView({ pageType: 'PERSON', personId: person.id });
    }
  }, [person?.id]);

  // Funci√≥n helper para generar URL de efem√©rides (formato: /efemerides/MM-DD)
  const getEfemeridesUrl = (month: number, day: number): string => {
    const monthStr = month.toString().padStart(2, '0');
    const dayStr = day.toString().padStart(2, '0');
    return `/efemerides/${monthStr}-${dayStr}`;
  };

  // Funci√≥n helper para generar URL de personas por a√±o de nacimiento
  const getBirthYearUrl = (year: number): string => {
    return `/listados/personas?birthYearFrom=${year}&birthYearTo=${year}&sortBy=lastName&sortOrder=asc`;
  };

  // Funci√≥n helper para generar URL de personas por a√±o de muerte
  const getDeathYearUrl = (year: number): string => {
    return `/listados/personas?deathYearFrom=${year}&deathYearTo=${year}&sortBy=deathDate&sortOrder=asc`;
  };

  // Funci√≥n helper para generar URL de personas por ubicaci√≥n de nacimiento
  const getBirthLocationUrl = (locationId: number): string => {
    return `/listados/personas?birthLocationId=${locationId}&sortBy=lastName&sortOrder=asc`;
  };

  // Funci√≥n helper para generar URL de personas por ubicaci√≥n de muerte
  const getDeathLocationUrl = (locationId: number): string => {
    return `/listados/personas?deathLocationId=${locationId}&sortBy=lastName&sortOrder=asc`;
  };

  // Funci√≥n helper para generar URL de personas por nacionalidad
  const getNationalityUrl = (locationId: number): string => {
    return `/listados/personas?nationalityId=${locationId}&sortBy=lastName&sortOrder=asc`;
  };

  // Funci√≥n para renderizar ubicaci√≥n con links (para nacimiento o muerte)
  const renderLocationWithLinks = (location: any, type: 'birth' | 'death') => {
    if (!location) return null;

    const parts: { id: number; name: string }[] = [];
    let current = location;

    while (current) {
      parts.push({ id: current.id, name: current.name });
      current = current.parent;
    }

    const getUrl = type === 'birth' ? getBirthLocationUrl : getDeathLocationUrl;

    return (
      <>
        {parts.map((part, index) => (
          <span key={part.id}>
            {index > 0 && ', '}
            <Link
              href={getUrl(part.id)}
              className="text-gray-300 hover:text-blue-400 transition-colors"
            >
              {part.name}
            </Link>
          </span>
        ))}
      </>
    );
  };

  // Funci√≥n helper para generar URL de obituarios (formato: /obituarios?year=YYYY) - DEPRECADA
  const getObituariosUrl = (year: number): string => {
    const yearStr = year.toString().padStart(4, '0');
    return `/listados/obituarios?year=${yearStr}`;
  };

  // Funci√≥n helper para obtener el a√±o efectivo para ordenamiento
  const getEffectiveYear = (movie: Movie): number => {
    if (movie.releaseYear) {
      return movie.releaseYear;
    }
    if (movie.year) {
      return movie.year;
    }
    return 0;
  };

  // Funci√≥n helper para obtener la fecha efectiva completa para ordenamiento m√°s preciso
  const getEffectiveDate = (movie: Movie): Date => {
    if (movie.releaseYear && movie.releaseMonth && movie.releaseDay) {
      return new Date(movie.releaseYear, movie.releaseMonth - 1, movie.releaseDay);
    }
    if (movie.releaseYear && movie.releaseMonth) {
      return new Date(movie.releaseYear, movie.releaseMonth - 1, 1);
    }
    if (movie.releaseYear) {
      return new Date(movie.releaseYear, 0, 1);
    }
    if (movie.year) {
      return new Date(movie.year, 0, 1);
    }
    return new Date(1900, 0, 1);
  };


  // ‚úÖ ACTUALIZADO: Funci√≥n para ordenar pel√≠culas cronol√≥gicamente con prioridad de stages
  const sortMoviesChronologically = (movies: any[], descending: boolean = true): any[] => {
    // Definir orden de prioridad para stages en desarrollo
    const stageOrder: Record<string, number> = {
      'EN_DESARROLLO': 1,
      'EN_PRODUCCION': 2,
      'EN_PREPRODUCCION': 3,
      'EN_RODAJE': 4,
      'EN_POSTPRODUCCION': 5
    };

    return [...movies].sort((a, b) => {
      const movieA = a.movie || a;
      const movieB = b.movie || b;
      const stageA = movieA.stage;
      const stageB = movieB.stage;

      // Verificar si son stages que van primero (no IN√âDITA ni INCONCLUSA ni COMPLETA)
      const isStageAPriority = stageA && stageOrder[stageA] !== undefined;
      const isStageBPriority = stageB && stageOrder[stageB] !== undefined;

      // Si ambas son priority stages, ordenar por el orden definido
      if (isStageAPriority && isStageBPriority) {
        return stageOrder[stageA] - stageOrder[stageB];
      }

      // Si solo A es priority, va primero
      if (isStageAPriority) return -1;

      // Si solo B es priority, va primero
      if (isStageBPriority) return 1;

      // Si ninguna es priority (incluyendo COMPLETA, IN√âDITA, INCONCLUSA), ordenar por fecha
      const dateA = getEffectiveDate(movieA);
      const dateB = getEffectiveDate(movieB);

      if (dateA.getTime() === dateB.getTime()) {
        const titleA = movieA.title.toLowerCase();
        const titleB = movieB.title.toLowerCase();
        return titleA.localeCompare(titleB);
      }

      return descending
        ? dateB.getTime() - dateA.getTime()
        : dateA.getTime() - dateB.getTime();
    });
  };

  // ‚úÖ NUEVA FUNCI√ìN: Construir la lista de "Todos los roles"
  const buildAllRolesList = useCallback((
    castRoles: CastRole[] | undefined,
    crewRoles: CrewRole[] | undefined,
    personGender?: string
  ): AllRolesItem[] => {
    const movieMap: { [movieId: number]: { movie: Movie; crewRoles: string[]; castRoles: { label: string; isActor: boolean }[] } } = {};

    // Procesar crew roles
    if (crewRoles) {
      crewRoles.forEach((item) => {
        const movieId = item.movie.id;
        const roleName = item.role?.name || 'Rol desconocido';

        if (!movieMap[movieId]) {
          movieMap[movieId] = {
            movie: item.movie,
            crewRoles: [],
            castRoles: []
          };
        }

        // Evitar duplicados en crew
        if (!movieMap[movieId].crewRoles.includes(roleName)) {
          movieMap[movieId].crewRoles.push(roleName);
        }
      });
    }

    // Procesar cast roles
    if (castRoles) {
      castRoles.forEach((item) => {
        const movieId = item.movie.id;

        if (!movieMap[movieId]) {
          movieMap[movieId] = {
            movie: item.movie,
            crewRoles: [],
            castRoles: []
          };
        }

        let label: string;
        if (item.isActor === false) {
          // Aparici√≥n como s√≠ mismo/a
          label = personGender === 'FEMALE' ? 'Como s√≠ misma' : 'Como s√≠ mismo';
        } else {
          // Actuaci√≥n con personaje
          const actorLabel = personGender === 'FEMALE' ? 'Actriz' : 'Actor';
          if (item.characterName) {
            label = `${actorLabel} [${item.characterName}]`;
          } else {
            label = actorLabel;
          }
        }

        // Evitar duplicados exactos en cast
        const exists = movieMap[movieId].castRoles.some(c => c.label === label);
        if (!exists) {
          movieMap[movieId].castRoles.push({ label, isActor: item.isActor !== false });
        }
      });
    }

    // Construir la lista final con roles ordenados por importancia (crew primero, luego cast)
    const result: AllRolesItem[] = Object.values(movieMap).map(({ movie, crewRoles, castRoles }) => {
      // Ordenar: crew primero (alfab√©tico), luego cast (actores primero, luego "como s√≠ mismo")
      const sortedCrewRoles = [...crewRoles].sort((a, b) => a.localeCompare(b));
      const sortedCastRoles = [...castRoles].sort((a, b) => {
        // Actores van antes que "como s√≠ mismo"
        if (a.isActor && !b.isActor) return -1;
        if (!a.isActor && b.isActor) return 1;
        return a.label.localeCompare(b.label);
      });

      const rolesDisplay = [
        ...sortedCrewRoles,
        ...sortedCastRoles.map(c => c.label)
      ];

      return { movie, rolesDisplay };
    });

    // Ordenar pel√≠culas cronol√≥gicamente
    return sortMoviesChronologically(result, true);
  }, []);

  // ‚úÖ NUEVA FUNCI√ìN: Construir las secciones para "Por rol"
  const buildRoleSections = useCallback((
    castRoles: CastRole[] | undefined,
    crewRoles: CrewRole[] | undefined,
    personGender?: string
  ): RoleSection[] => {
    const sections: { [roleName: string]: TabItem[] } = {};

    // Procesar crew roles
    if (crewRoles) {
      // Agrupar pel√≠culas por rol, guardando todos los roles de cada pel√≠cula
      const movieRolesMap: { [movieId: number]: { movie: Movie; roles: Set<string> } } = {};

      crewRoles.forEach((item) => {
        const movieId = item.movie.id;
        const roleName = item.role?.name || 'Rol desconocido';

        if (!movieRolesMap[movieId]) {
          movieRolesMap[movieId] = {
            movie: item.movie,
            roles: new Set()
          };
        }
        movieRolesMap[movieId].roles.add(roleName);
      });

      // Crear secciones por rol
      crewRoles.forEach((item) => {
        const roleName = item.role?.name || 'Rol desconocido';

        if (!sections[roleName]) {
          sections[roleName] = [];

          // Obtener todas las pel√≠culas que tienen este rol
          const moviesWithThisRole = crewRoles
            .filter(cr => cr.role?.name === roleName)
            .map(cr => cr.movie.id);

          const uniqueMovieIds = [...new Set(moviesWithThisRole)];

          uniqueMovieIds.forEach(movieId => {
            const movieData = movieRolesMap[movieId];
            sections[roleName].push({
              movie: movieData.movie,
              roles: Array.from(movieData.roles)
            });
          });
        }
      });
    }

    // Procesar cast roles - Actuaci√≥n
    if (castRoles) {
      const actingRoles = castRoles.filter((r: CastRole) => r.isActor !== false);
      const selfRoles = castRoles.filter((r: CastRole) => r.isActor === false);

      if (actingRoles.length > 0) {
        const actingLabel = 'Actuaci√≥n';
        sections[actingLabel] = sortMoviesChronologically(actingRoles.map(r => ({
          movie: r.movie,
          roles: [actingLabel],
          characterName: r.characterName
        })), true);
      }

      if (selfRoles.length > 0) {
        const selfLabel = personGender === 'FEMALE' ? 'Como s√≠ misma' : 'Como s√≠ mismo';
        sections[selfLabel] = sortMoviesChronologically(selfRoles.map(r => ({
          movie: r.movie,
          roles: [selfLabel]
        })), true);
      }
    }

    // Ordenar pel√≠culas dentro de cada secci√≥n
    Object.keys(sections).forEach(roleName => {
      if (roleName !== 'Actuaci√≥n' && !roleName.startsWith('Como s√≠')) {
        sections[roleName] = sortMoviesChronologically(sections[roleName], true);
      }
    });

    // Convertir a array y ordenar secciones por cantidad de pel√≠culas
    const sectionsArray: RoleSection[] = Object.entries(sections)
      .map(([roleName, items]) => ({ roleName, items }))
      .sort((a, b) => b.items.length - a.items.length);

    return sectionsArray;
  }, []);

  const fetchPersonData = useCallback(async () => {
    try {
      const personResponse = await fetch(`/api/people/slug/${params.slug}`);
      if (!personResponse.ok) {
        setLoading(false);
        return;
      }
      const personData = await personResponse.json();
      setPerson(personData);

      const filmographyResponse = await fetch(`/api/people/${personData.id}/filmography`);
      if (filmographyResponse.ok) {
        const filmographyData = await filmographyResponse.json();

        if (filmographyData.castRoles) {
          filmographyData.castRoles = sortMoviesChronologically(filmographyData.castRoles, true);
        }

        setFilmography(filmographyData);
        setActiveTab('Todos los roles');
      }
    } catch (error) {
      console.error('Error fetching person data:', error);
    } finally {
      setLoading(false);
    }
  }, [params.slug]);

  useEffect(() => {
    fetchPersonData();
  }, [fetchPersonData]);

  if (loading) {
    return (
      <div className="bg-gray-900 text-white min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400 mx-auto"></div>
          <p className="mt-4 text-gray-400">Cargando...</p>
        </div>
      </div>
    );
  }

  if (!person) {
    notFound();
  }

  const fullName = [person.firstName, person.lastName].filter(Boolean).join(' ');

  const birthDateFormatted = person.birthYear ? formatPartialDate({
    year: person.birthYear,
    month: person.birthMonth,
    day: person.birthDay
  }, { monthFormat: 'long', includeDay: true }) : null;

  const deathDateFormatted = person.deathYear ? formatPartialDate({
    year: person.deathYear,
    month: person.deathMonth,
    day: person.deathDay
  }, { monthFormat: 'long', includeDay: true }) : null;

  // ‚úÖ Construir la lista de "Todos los roles"
  const allRolesList = buildAllRolesList(
    filmography?.castRoles,
    filmography?.crewRoles,
    person.gender
  );

  // ‚úÖ Construir las secciones de "Por rol"
  const roleSections = buildRoleSections(
    filmography?.castRoles,
    filmography?.crewRoles,
    person.gender
  );

  // ‚úÖ Solo 2 pesta√±as
  const hasTabs = allRolesList.length > 0;
  const tabs = hasTabs ? ['Todos los roles', 'Por rol'] : [];

  // Calcular stats separando actuaciones de apariciones como s√≠ mismo
  const actingRolesForStats = filmography?.castRoles?.filter((r: CastRole) => r.isActor !== false) || [];
  const selfRolesForStats = filmography?.castRoles?.filter((r: CastRole) => r.isActor === false) || [];

  const uniqueMoviesAsActor = new Set(actingRolesForStats.map((r: CastRole) => r.movie.id));
  const uniqueMoviesAsSelf = new Set(selfRolesForStats.map((r: CastRole) => r.movie.id));
  const uniqueMoviesAsCrew = new Set(filmography?.crewRoles?.map((r: CrewRole) => r.movie.id) || []);
  const allUniqueMovies = new Set([...uniqueMoviesAsActor, ...uniqueMoviesAsSelf, ...uniqueMoviesAsCrew]);

  const stats = {
    totalMovies: allUniqueMovies.size,
    asActor: uniqueMoviesAsActor.size,
    asSelf: uniqueMoviesAsSelf.size,
    asCrew: uniqueMoviesAsCrew.size
  };

  // ‚úÖ ACTUALIZADO: Determinar el badge a mostrar (incluyendo stages en desarrollo)
  const getMovieBadge = (movie: Movie): { text: string; color: string } | null => {
    const isUnreleased = !movie.releaseYear;

    // ‚úÖ NUEVO: Badges para stages en desarrollo (excepto IN√âDITA e INCONCLUSA)
    if (movie.stage === 'EN_DESARROLLO') {
      return {
        text: 'En desarrollo',
        color: 'bg-orange-500/20 text-orange-300 border border-orange-500/30'
      };
    }

    if (movie.stage === 'EN_PRODUCCION') {
      return {
        text: 'En producci√≥n',
        color: 'bg-green-500/20 text-green-300 border border-green-500/30'
      };
    }

    if (movie.stage === 'EN_PREPRODUCCION') {
      return {
        text: 'En preproducci√≥n',
        color: 'bg-yellow-500/20 text-yellow-300 border border-yellow-500/30'
      };
    }

    if (movie.stage === 'EN_RODAJE') {
      return {
        text: 'En rodaje',
        color: 'bg-blue-500/20 text-blue-300 border border-blue-500/30'
      };
    }

    if (movie.stage === 'EN_POSTPRODUCCION') {
      return {
        text: 'En postproducci√≥n',
        color: 'bg-purple-500/20 text-purple-300 border border-purple-500/30'
      };
    }

    // ‚úÖ NUEVO: Badge para INCONCLUSA (tiene prioridad sobre "no estrenada")
    if (movie.stage === 'INCONCLUSA') {
      return {
        text: 'Inconclusa',
        color: 'bg-red-500/20 text-red-300 border border-red-500/30'
      };
    }

    // Cortometraje
    if (movie.tipoDuracion === 'cortometraje') {
      return {
        text: 'Cortometraje',
        color: 'bg-purple-500/20 text-purple-300 border border-purple-500/30'
      };
    }

    // Mediometraje
    if (movie.tipoDuracion === 'mediometraje') {
      return {
        text: 'Mediometraje',
        color: 'bg-blue-500/20 text-blue-300 border border-blue-500/30'
      };
    }

    // Largometraje no estrenado (solo si NO es INCONCLUSA ni IN√âDITA)
    if (movie.tipoDuracion === 'largometraje' && isUnreleased && movie.stage !== 'INCONCLUSA' && movie.stage !== 'INEDITA') {
      return {
        text: 'No estrenada',
        color: 'bg-amber-500/20 text-amber-300 border border-amber-500/30'
      };
    }

    return null;
  };

  // ‚úÖ Renderizar una pel√≠cula individual
  const renderMovieItem = (item: any, index: number, showRoles: boolean = false, showCharacter: boolean = false) => {
    const movie = item.movie;
    const year = getEffectiveYear(movie);
    const displayYear = year > 0 ? year : '‚Äî';
    const badge = getMovieBadge(movie);

    return (
      <div key={`${movie.id}-${index}`} className="py-4 hover:bg-gray-800/30 transition-colors group">
        <div className="flex items-center gap-4">
          <span className="text-sm w-12 text-left text-gray-500">
            {displayYear}
          </span>
          <div className="flex-grow">
            <div className="flex items-center gap-2 flex-wrap">
              <Link
                href={`/pelicula/${movie.slug}`}
                className="text-lg text-white hover:text-blue-400 transition-colors inline-block"
              >
                {movie.title}
              </Link>

              {/* BADGE */}
              {badge && (
                <span className={`text-xs px-2 py-0.5 rounded-full ${badge.color}`}>
                  {badge.text}
                </span>
              )}

              {/* Roles para "Todos los roles" */}
              {showRoles && item.rolesDisplay && item.rolesDisplay.length > 0 && (
                <span className="text-sm text-gray-500">
                  ({item.rolesDisplay.join('; ')})
                </span>
              )}

              {/* Personaje para Actuaci√≥n */}
              {showCharacter && item.characterName && (
                <span className="text-sm text-gray-500">
                  ‚Äî {item.characterName}
                </span>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="bg-gray-900 text-white min-h-screen">
      {/* Person Header Section */}
      <section className="relative bg-gradient-to-b from-gray-800 to-gray-900 py-12">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex flex-col md:flex-row gap-8 items-start">
            {/* Portrait */}
            <div className="flex-shrink-0">
              <div className="relative">
                <div className="w-48 h-64 md:w-64 md:h-80 rounded-lg overflow-hidden shadow-2xl">
                  {person.photoUrl ? (
                    <img
                      src={person.photoUrl}
                      alt={fullName}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full bg-gray-800 flex flex-col justify-center items-center">
                      <svg className="w-16 h-16 text-gray-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                      <p className="text-sm text-gray-500">Foto no disponible</p>
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* Person Info */}
            <div className="flex-grow">
              <h1 className="text-5xl md:text-6xl font-bold mb-4">{fullName}</h1>

              {person.realName && person.realName !== fullName && (
                <p className="text-gray-400 mb-2">
                  <span className="text-gray-500">Nombre real: </span>
                  {person.realName}
                </p>
              )}

              {/* ‚úÖ NUEVO: Mostrar nombres alternativos */}
              {person.alternativeNames && person.alternativeNames.length > 0 && (
                <p className="text-gray-400 mb-2">
                  <span className="text-gray-500">{getCreditedLabel(person.gender)}: </span>
                  {person.alternativeNames.map((alt: AlternativeName) => alt.fullName).join(', ')}
                </p>
              )}

              <div className="space-y-3 text-gray-300">
                {birthDateFormatted && (
                  <div className="text-sm">
                    <span className="text-gray-500">
                      {person.birthDay ? 'Naci√≥ el ' : 'Naci√≥ en '}
                    </span>
                    {person.birthDay && person.birthMonth ? (
                      <>
                        <Link
                          href={getEfemeridesUrl(person.birthMonth, person.birthDay)}
                          className="text-gray-300 hover:text-blue-400 transition-colors decoration-gray-600 hover:decoration-blue-400"
                        >
                          {person.birthDay} de {MONTHS[person.birthMonth - 1].label.toLowerCase()}
                        </Link>
                        <span className="text-gray-500"> de </span>
                        <Link
                          href={getBirthYearUrl(person.birthYear)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {person.birthYear}
                        </Link>
                      </>
                    ) : person.birthMonth ? (
                      <>
                        <Link
                          href={getEfemeridesUrl(person.birthMonth, 1)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {MONTHS[person.birthMonth - 1].label.toLowerCase()}
                        </Link>
                        <span className="text-gray-500"> de </span>
                        <Link
                          href={getBirthYearUrl(person.birthYear)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {person.birthYear}
                        </Link>
                      </>
                    ) : (
                      <Link
                        href={getBirthYearUrl(person.birthYear)}
                        className="text-gray-300 hover:text-blue-400 transition-colors"
                      >
                        {person.birthYear}
                      </Link>
                    )}
                    {person.birthLocation && (
                      <>
                        <span className="text-gray-500"> en </span>
                        {renderLocationWithLinks(person.birthLocation, 'birth')}
                      </>
                    )}
                  </div>
                )}

                {deathDateFormatted && (
                  <div className="text-sm">
                    <span className="text-gray-500">
                      {person.deathDay ? 'Muri√≥ el ' : 'Muri√≥ en '}
                    </span>
                    {person.deathDay && person.deathMonth ? (
                      <>
                        <Link
                          href={getEfemeridesUrl(person.deathMonth, person.deathDay)}
                          className="text-gray-300 hover:text-blue-400 transition-colors decoration-gray-600 hover:decoration-blue-400"
                        >
                          {person.deathDay} de {MONTHS[person.deathMonth - 1].label.toLowerCase()}
                        </Link>
                        <span className="text-gray-500"> de </span>
                        <Link
                          href={getDeathYearUrl(person.deathYear)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {person.deathYear}
                        </Link>
                      </>
                    ) : person.deathMonth ? (
                      <>
                        <Link
                          href={getEfemeridesUrl(person.deathMonth, 1)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {MONTHS[person.deathMonth - 1].label.toLowerCase()}
                        </Link>
                        <span className="text-gray-500"> de </span>
                        <Link
                          href={getDeathYearUrl(person.deathYear)}
                          className="text-gray-300 hover:text-blue-400 transition-colors"
                        >
                          {person.deathYear}
                        </Link>
                      </>
                    ) : (
                      <Link
                        href={getDeathYearUrl(person.deathYear)}
                        className="text-gray-300 hover:text-blue-400 transition-colors"
                      >
                        {person.deathYear}
                      </Link>
                    )}
                    {person.deathLocation && (
                      <>
                        <span className="text-gray-500"> en </span>
                        {renderLocationWithLinks(person.deathLocation, 'death')}
                      </>
                    )}
                  </div>
                )}

                {person.nationalities && person.nationalities.length > 0 && (
                  <div className="text-sm mb-4">
                    <span className="text-gray-500">Nacionalidad: </span>
                    {person.nationalities
                      .map((nat: any, index: number) => {
                        const display = nat.location?.gentilicio || nat.location?.name;
                        const locationId = nat.location?.id || nat.locationId;
                        if (!display) return null;

                        return (
                          <span key={locationId || index}>
                            {index > 0 && ', '}
                            <Link
                              href={getNationalityUrl(locationId)}
                              className="text-white hover:text-blue-400 transition-colors"
                            >
                              {display}
                            </Link>
                          </span>
                        );
                      })
                      .filter(Boolean)}
                  </div>
                )}

                {person.biography && (
                  <div
                    className="mt-6 text-gray-300 leading-relaxed max-w-3xl serif-body"
                    dangerouslySetInnerHTML={{
                      __html: DOMPurify.sanitize(person.biography, {
                        ALLOWED_TAGS: ['p', 'a', 'strong', 'em', 'br', 'ul', 'ol', 'li', 'b', 'i', 'span'],
                        ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
                        ADD_ATTR: ['target'],
                      })
                    }}
                  />
                )}

                {/* Quick Stats */}
                <div className="flex gap-8 mt-8">
                  <div className="text-center">
                    <div className="text-3xl font-light text-blue-400">{stats.totalMovies}</div>
                    <div className="text-xs text-gray-500 uppercase tracking-wider mt-1">Pel√≠culas</div>
                  </div>
                  {stats.asActor > 0 && (
                    <div className="text-center">
                      <div className="text-3xl font-light text-blue-400">{stats.asActor}</div>
                      <div className="text-xs text-gray-500 uppercase tracking-wider mt-1">
                        {person.gender === 'FEMALE' ? 'Como Actriz' : 'Como Actor'}
                      </div>
                    </div>
                  )}
                  {stats.asSelf > 0 && (
                    <div className="text-center">
                      <div className="text-3xl font-light text-blue-400">{stats.asSelf}</div>
                      <div className="text-xs text-gray-500 uppercase tracking-wider mt-1">
                        {person.gender === 'FEMALE' ? 'Como s√≠ misma' : 'Como s√≠ mismo'}
                      </div>
                    </div>
                  )}
                  {stats.asCrew > 0 && (
                    <div className="text-center">
                      <div className="text-3xl font-light text-blue-400">{stats.asCrew}</div>
                      <div className="text-xs text-gray-500 uppercase tracking-wider mt-1">Equipo T√©cnico</div>
                    </div>
                  )}
                </div>

                {/* Links externos si existen */}
                {person.links && person.links.length > 0 && (
                  <div className="flex gap-4 mt-6">
                    {person.links.map((link: any) => (
                      <a
                        key={link.id}
                        href={link.url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-gray-400 hover:text-white transition-colors"
                        title={link.type}
                      >
                        {link.type === 'IMDB' ? 'IMDb' :
                          link.type === 'WIKIPEDIA' ? 'Wikipedia' :
                            link.type === 'OFFICIAL_WEBSITE' ? 'Sitio Web' :
                              link.type === 'INSTAGRAM' ? 'Instagram' :
                                link.type === 'TWITTER' ? 'Twitter' : link.type}
                      </a>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Filmography Section */}
      {hasTabs && (
        <section className="py-12">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            {/* Navigation Tabs - Solo 2 pesta√±as */}
            <div className="border-b border-gray-700 mb-8">
              <nav className="flex space-x-8">
                {tabs.map((tabName) => (
                  <button
                    key={tabName}
                    onClick={() => {
                      setActiveTab(tabName);
                      setShowAllFilmography(false);
                    }}
                    className={`pb-4 px-1 border-b-2 font-medium text-sm whitespace-nowrap transition-colors ${activeTab === tabName
                      ? 'border-blue-400 text-white'
                      : 'border-transparent text-gray-400 hover:text-white'
                      }`}
                  >
                    {tabName === 'Todos los roles' 
                      ? `${tabName} (${allRolesList.length})`
                      : `${tabName} (${roleSections.length})`
                    }
                  </button>
                ))}
              </nav>
            </div>

            {/* Contenido seg√∫n pesta√±a activa */}
            {activeTab === 'Todos los roles' ? (
              // ‚úÖ PESTA√ëA "TODOS LOS ROLES"
              <div className="space-y-1">
                <h2 className="text-2xl font-light mb-6 text-white flex items-center gap-2">
                  Filmograf√≠a en Argentina
                  <div className="relative group">
                    <button
                      type="button"
                      className="w-5 h-5 rounded-full bg-gray-700 hover:bg-gray-600 text-gray-400 hover:text-white text-xs flex items-center justify-center transition-colors"
                      aria-label="M√°s informaci√≥n"
                    >
                      ?
                    </button>
                    <div className="absolute left-0 top-full mt-2 w-72 p-3 bg-gray-800 border border-gray-700 rounded-lg shadow-xl text-sm text-gray-300 font-normal opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                      Esta filmograf√≠a incluye √∫nicamente pel√≠culas argentinas o coproducciones con participaci√≥n de Argentina. Los trabajos realizados exclusivamente en el exterior no est√°n incluidos.
                    </div>
                  </div>
                </h2>
                <div className="divide-y divide-gray-800/50">
                  {(showAllFilmography ? allRolesList : allRolesList.slice(0, 10)).map((item, index) => 
                    renderMovieItem(item, index, true, false)
                  )}
                </div>
                
                {/* Show More Button */}
                {allRolesList.length > 10 && (
                  <div className="mt-8 text-center">
                    <button
                      onClick={() => setShowAllFilmography(!showAllFilmography)}
                      className="text-blue-400 hover:text-blue-300 text-sm font-medium transition-colors flex items-center space-x-2 mx-auto"
                    >
                      <span>{showAllFilmography ? 'Ver menos' : 'Ver filmograf√≠a completa'}</span>
                      <svg
                        className={`w-4 h-4 transition-transform duration-200 ${showAllFilmography ? 'rotate-180' : ''}`}
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
                      </svg>
                    </button>
                  </div>
                )}
              </div>
            ) : (
              // ‚úÖ PESTA√ëA "POR ROL" - Secciones agrupadas
              <div className="space-y-1">
                <h2 className="text-2xl font-light mb-6 text-white flex items-center gap-2">
                  Filmograf√≠a en Argentina
                  <div className="relative group">
                    <button
                      type="button"
                      className="w-5 h-5 rounded-full bg-gray-700 hover:bg-gray-600 text-gray-400 hover:text-white text-xs flex items-center justify-center transition-colors"
                      aria-label="M√°s informaci√≥n"
                    >
                      ?
                    </button>
                    <div className="absolute left-0 top-full mt-2 w-72 p-3 bg-gray-800 border border-gray-700 rounded-lg shadow-xl text-sm text-gray-300 font-normal opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                      Esta filmograf√≠a incluye √∫nicamente pel√≠culas argentinas o coproducciones con participaci√≥n de Argentina. Los trabajos realizados exclusivamente en el exterior no est√°n incluidos.
                    </div>
                  </div>
                </h2>
                <div className="space-y-10">
                  {roleSections.map((section, sectionIndex) => (
                    <div key={section.roleName} className="space-y-1">
                      <h3 className="text-xl font-light text-white mb-4">
                        {section.roleName}
                        <span className="text-gray-500 ml-2">({section.items.length})</span>
                      </h3>
                      <div className="divide-y divide-gray-800/50">
                        {section.items.map((item, index) => 
                          renderMovieItem(
                            item, 
                            index, 
                            false, 
                            section.roleName === 'Actuaci√≥n' // Solo mostrar personaje en Actuaci√≥n
                          )
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </section>
      )}

      {/* Image Gallery - Solo se muestra si hay im√°genes */}
      {person.galleryImages && person.galleryImages.length > 0 && (
        <section className="py-12 border-t border-gray-800">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 className="serif-heading text-2xl text-white mb-6">Galer√≠a de Im√°genes</h2>
            <ImageGallery
              images={person.galleryImages}
              movieTitle={fullName}
            />
          </div>
        </section>
      )}
    </div>
  );
}

// ==================================================
// src/app/admin/calificaciones/page.tsx
// ==================================================
'use client'

import { useState, useEffect } from 'react'
import {
  Plus,
  Search,
  Edit,
  Trash2,
  Shield,
  X,
  Save,
  Loader2
} from 'lucide-react'
import { toast } from 'react-hot-toast'

interface Calificacion {
  id: number
  slug: string
  name: string
  abbreviation?: string | null
  description?: string | null
  createdAt: string
  _count?: {
    movies: number
  }
}

export default function AdminCalificacionesPage() {
  const [calificaciones, setCalificaciones] = useState<Calificacion[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [showModal, setShowModal] = useState(false)
  const [editingCalif, setEditingCalif] = useState<Calificacion | null>(null)
  const [deletingCalifId, setDeletingCalifId] = useState<number | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Estado del formulario
  const [formData, setFormData] = useState({
    name: '',
    abbreviation: '',
    description: ''
  })
  const [formErrors, setFormErrors] = useState({
    name: '',
    abbreviation: ''
  })

  // Cargar calificaciones
  const fetchCalif = async () => {
    try {
      setLoading(true)
      const response = await fetch('/api/calificaciones')
      
      if (!response.ok) {
        throw new Error('Error al cargar las calificaciones')
      }
      
      const data = await response.json()
      setCalificaciones(Array.isArray(data) ? data : [])
    } catch (error) {
      toast.error('Error al cargar las calificaciones')
      setCalificaciones([])
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchCalif()
  }, [])

  // Filtrar calificaciones
  const filteredCalif = calificaciones.filter(calificacion =>
    calificacion.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (calificacion.abbreviation && calificacion.abbreviation.toLowerCase().includes(searchTerm.toLowerCase())) ||
    (calificacion.description && calificacion.description.toLowerCase().includes(searchTerm.toLowerCase()))
  )

  // Validar formulario
  const validateForm = () => {
    const errors = { name: '', abbreviation: '' }
    
    if (!formData.name.trim()) {
      errors.name = 'El nombre es requerido'
    } else if (formData.name.length > 100) {
      errors.name = 'El nombre no puede exceder 100 caracteres'
    }
    
    if (formData.abbreviation && formData.abbreviation.length > 10) {
      errors.abbreviation = 'La abreviatura no puede exceder 10 caracteres'
    }
    
    setFormErrors(errors)
    return !errors.name && !errors.abbreviation
  }

  // Crear o actualizar calificaci√≥n
  const handleSubmit = async () => {
    if (!validateForm()) return

    try {
      setIsSubmitting(true)
      const url = editingCalif
        ? `/api/calificaciones/${editingCalif.id}`
        : '/api/calificaciones'
      
      const method = editingCalif ? 'PUT' : 'POST'
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: formData.name.trim(),
          abbreviation: formData.abbreviation.trim() || undefined,
          description: formData.description.trim() || undefined
        })
      })

      if (!response.ok) {
        let errorMessage = 'Error al guardar la calificaci√≥n'
        try {
          const error = await response.json()
          errorMessage = error.error || error.message || errorMessage
        } catch (e) {}
        throw new Error(errorMessage)
      }

      toast.success(editingCalif ? 'Calificaci√≥n actualizada' : 'Calificaci√≥n creada')
      setShowModal(false)
      resetForm()
      fetchCalif()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Error al guardar')
    } finally {
      setIsSubmitting(false)
    }
  }

  // Resetear formulario
  const resetForm = () => {
    setFormData({ name: '', abbreviation: '', description: '' })
    setFormErrors({ name: '', abbreviation: '' })
    setEditingCalif(null)
  }

  // Editar calificaci√≥n
  const handleEdit = (calificacion: Calificacion) => {
    setEditingCalif(calificacion)
    setFormData({
      name: calificacion.name,
      abbreviation: calificacion.abbreviation || '',
      description: calificacion.description || ''
    })
    setShowModal(true)
  }

  // Eliminar calificaci√≥n
  const handleDelete = async (id: number) => {
    if (!confirm('¬øEst√°s seguro de eliminar esta calificaci√≥n? Esta acci√≥n no se puede deshacer.')) return

    try {
      setDeletingCalifId(id)
      const response = await fetch(`/api/calificaciones/${id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        throw new Error('Error al eliminar')
      }

      toast.success('Calificaci√≥n eliminada')
      fetchCalif()
    } catch (error) {
      toast.error('Error al eliminar la calificaci√≥n')
    } finally {
      setDeletingCalifId(null)
    }
  }

  // Abrir modal para nueva calificaci√≥n
  const handleNewCalif = () => {
    resetForm()
    setShowModal(true)
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Administraci√≥n de Calificaciones
            </h1>
          </div>
        </div>
      </div>

      {/* Contenido principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Filtros y acciones */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            {/* B√∫squeda */}
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                type="text"
                placeholder="Buscar calificaciones..."
                className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>

            {/* Bot√≥n nueva calificaci√≥n */}
            <button
              onClick={handleNewCalif}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
            >
              <Plus className="w-5 h-5" />
              Nueva Calificaci√≥n
            </button>
          </div>
        </div>

        {/* Lista de calificaciones */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          {loading ? (
            <div className="flex items-center justify-center h-64">
              <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
            </div>
          ) : filteredCalif.length === 0 ? (
            <div className="text-center py-12">
              <Shield className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-gray-500">No se encontraron calificaciones</p>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Calificaci√≥n
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Abreviatura
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Descripci√≥n
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Slug
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Pel√≠culas
                    </th>
                    <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredCalif.map((calificacion) => (
                    <tr key={calificacion.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900">
                          {calificacion.name}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-700">
                          {calificacion.abbreviation ? (
                            <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded-md">
                              {calificacion.abbreviation}
                            </span>
                          ) : (
                            <span className="text-gray-400">-</span>
                          )}
                        </div>
                      </td>
                      <td className="px-6 py-4">
                        <div className="text-sm text-gray-500 max-w-xs truncate">
                          {calificacion.description || '-'}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-400">
                          {calificacion.slug}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {calificacion._count?.movies || 0}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex items-center justify-end gap-2">
                          <button
                            onClick={() => handleEdit(calificacion)}
                            className="text-blue-600 hover:text-blue-900 transition-colors"
                            title="Editar"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDelete(calificacion.id)}
                            disabled={deletingCalifId === calificacion.id}
                            className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50"
                            title="Eliminar"
                          >
                            {deletingCalifId === calificacion.id ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>

      {/* Modal de creaci√≥n/edici√≥n */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full">
            <div className="bg-gray-50 px-6 py-4 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h2 className="text-xl font-semibold text-gray-900">
                  {editingCalif ? 'Editar Calificaci√≥n' : 'Nueva Calificaci√≥n'}
                </h2>
                <button
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                  }}
                  className="text-gray-400 hover:text-gray-500"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>

            <div className="p-6">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Nombre de la Calificaci√≥n *
                  </label>
                  <input
                    type="text"
                    value={formData.name}
                    onChange={(e) => {
                      setFormData({ ...formData, name: e.target.value })
                      if (formErrors.name) {
                        setFormErrors({ ...formErrors, name: '' })
                      }
                    }}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    placeholder="Ej: Apta para todo p√∫blico"
                  />
                  {formErrors.name && (
                    <p className="mt-1 text-sm text-red-600">{formErrors.name}</p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Abreviatura
                  </label>
                  <input
                    type="text"
                    value={formData.abbreviation}
                    onChange={(e) => {
                      setFormData({ ...formData, abbreviation: e.target.value })
                      if (formErrors.abbreviation) {
                        setFormErrors({ ...formErrors, abbreviation: '' })
                      }
                    }}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    placeholder="Ej: ATP"
                    maxLength={10}
                  />
                  {formErrors.abbreviation && (
                    <p className="mt-1 text-sm text-red-600">{formErrors.abbreviation}</p>
                  )}
                  <p className="mt-1 text-xs text-gray-500">
                    M√°ximo 10 caracteres. Se mostrar√° como etiqueta en las listas.
                  </p>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Descripci√≥n
                  </label>
                  <textarea
                    value={formData.description}
                    onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                    rows={3}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    placeholder="Breve descripci√≥n de la calificaci√≥n (opcional)"
                  />
                </div>
              </div>

              {/* Botones de acci√≥n */}
              <div className="mt-6 flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                  }}
                  className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Cancelar
                </button>
                <button
                  type="button"
                  onClick={handleSubmit}
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Guardando...
                    </>
                  ) : (
                    <>
                      <Save className="w-4 h-4" />
                      {editingCalif ? 'Actualizar' : 'Crear'} Calificaci√≥n
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/admin/genres/page.tsx
// ==================================================
// src/app/admin/genres/page.tsx
'use client'

import { useState, useEffect } from 'react'
import {
  Plus,
  Search,
  Edit,
  Trash2,
  Hash,
  X,
  Save,
  Loader2
} from 'lucide-react'
import { toast } from 'react-hot-toast'

interface Genre {
  id: number
  slug: string
  name: string
  description?: string | null
  createdAt: string
  _count?: {
    movies: number
  }
}

export default function AdminGenresPage() {
  const [genres, setGenres] = useState<Genre[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [showModal, setShowModal] = useState(false)
  const [editingGenre, setEditingGenre] = useState<Genre | null>(null)
  const [deletingGenreId, setDeletingGenreId] = useState<number | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Estado del formulario
  const [formData, setFormData] = useState({
    name: '',
    description: ''
  })
  const [formErrors, setFormErrors] = useState({
    name: ''
  })

  // Cargar g√©neros
  const fetchGenres = async () => {
    try {
      setLoading(true)
      const response = await fetch('/api/genres')
      
      if (!response.ok) {
        throw new Error('Error al cargar los g√©neros')
      }
      
      const data = await response.json()
      setGenres(Array.isArray(data) ? data : [])
    } catch (error) {
      toast.error('Error al cargar los g√©neros')
      setGenres([])
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchGenres()
  }, [])

  // Filtrar g√©neros
  const filteredGenres = genres.filter(genre =>
    genre.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (genre.description && genre.description.toLowerCase().includes(searchTerm.toLowerCase()))
  )

  // Validar formulario
  const validateForm = () => {
    const errors = { name: '' }
    
    if (!formData.name.trim()) {
      errors.name = 'El nombre es requerido'
    } else if (formData.name.length > 100) {
      errors.name = 'El nombre no puede exceder 100 caracteres'
    }
    
    setFormErrors(errors)
    return !errors.name
  }

  // Crear o actualizar g√©nero
  const handleSubmit = async () => {
    if (!validateForm()) return

    try {
      setIsSubmitting(true)
      const url = editingGenre
        ? `/api/genres/${editingGenre.id}`
        : '/api/genres'
      
      const method = editingGenre ? 'PUT' : 'POST'
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: formData.name.trim(),
          description: formData.description.trim() || undefined
        })
      })

      if (!response.ok) {
        let errorMessage = 'Error al guardar el g√©nero'
        try {
          const error = await response.json()
          errorMessage = error.error || error.message || errorMessage
        } catch (e) {}
        throw new Error(errorMessage)
      }

      toast.success(editingGenre ? 'G√©nero actualizado' : 'G√©nero creado')
      setShowModal(false)
      resetForm()
      fetchGenres()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Error al guardar')
    } finally {
      setIsSubmitting(false)
    }
  }

  // Resetear formulario
  const resetForm = () => {
    setFormData({ name: '', description: '' })
    setFormErrors({ name: '' })
    setEditingGenre(null)
  }

  // Editar g√©nero
  const handleEdit = (genre: Genre) => {
    setEditingGenre(genre)
    setFormData({
      name: genre.name,
      description: genre.description || ''
    })
    setShowModal(true)
  }

  // Eliminar g√©nero
  const handleDelete = async (id: number) => {
    if (!confirm('¬øEst√°s seguro de eliminar este g√©nero? Esta acci√≥n no se puede deshacer.')) return

    try {
      setDeletingGenreId(id)
      const response = await fetch(`/api/genres/${id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        throw new Error('Error al eliminar')
      }

      toast.success('G√©nero eliminado')
      fetchGenres()
    } catch (error) {
      toast.error('Error al eliminar el g√©nero')
    } finally {
      setDeletingGenreId(null)
    }
  }

  // Abrir modal para nuevo g√©nero
  const handleNewGenre = () => {
    resetForm()
    setShowModal(true)
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Administraci√≥n de G√©neros
            </h1>
          </div>
        </div>
      </div>

      {/* Contenido principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Filtros y acciones */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            {/* B√∫squeda */}
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                type="text"
                placeholder="Buscar g√©neros..."
                className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>

            {/* Bot√≥n nuevo g√©nero */}
            <button
              onClick={handleNewGenre}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
            >
              <Plus className="w-5 h-5" />
              Nuevo G√©nero
            </button>
          </div>
        </div>

        {/* Lista de g√©neros */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          {loading ? (
            <div className="flex items-center justify-center h-64">
              <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
            </div>
          ) : filteredGenres.length === 0 ? (
            <div className="text-center py-12">
              <Hash className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-gray-500">No se encontraron g√©neros</p>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      G√©nero
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Descripci√≥n
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Slug
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Pel√≠culas
                    </th>
                    <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredGenres.map((genre) => (
                    <tr key={genre.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900">
                          {genre.name}
                        </div>
                      </td>
                      <td className="px-6 py-4">
                        <div className="text-sm text-gray-500 max-w-xs truncate">
                          {genre.description || '-'}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-400">
                          {genre.slug}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {genre._count?.movies || 0}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex items-center justify-end gap-2">
                          <button
                            onClick={() => handleEdit(genre)}
                            className="text-blue-600 hover:text-blue-900 transition-colors"
                            title="Editar"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDelete(genre.id)}
                            disabled={deletingGenreId === genre.id}
                            className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50"
                            title="Eliminar"
                          >
                            {deletingGenreId === genre.id ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>

      {/* Modal de creaci√≥n/edici√≥n */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full">
            <div className="bg-gray-50 px-6 py-4 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h2 className="text-xl font-semibold text-gray-900">
                  {editingGenre ? 'Editar G√©nero' : 'Nuevo G√©nero'}
                </h2>
                <button
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                  }}
                  className="text-gray-400 hover:text-gray-500"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>

            <div className="p-6">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Nombre del G√©nero *
                  </label>
                  <input
                    type="text"
                    value={formData.name}
                    onChange={(e) => {
                      setFormData({ ...formData, name: e.target.value })
                      if (formErrors.name) {
                        setFormErrors({ ...formErrors, name: '' })
                      }
                    }}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    placeholder="Ej: Drama, Comedia, Thriller"
                  />
                  {formErrors.name && (
                    <p className="mt-1 text-sm text-red-600">{formErrors.name}</p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Descripci√≥n
                  </label>
                  <textarea
                    value={formData.description}
                    onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                    rows={3}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    placeholder="Breve descripci√≥n del g√©nero (opcional)"
                  />
                </div>
              </div>

              {/* Botones de acci√≥n */}
              <div className="mt-6 flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                  }}
                  className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Cancelar
                </button>
                <button
                  type="button"
                  onClick={handleSubmit}
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Guardando...
                    </>
                  ) : (
                    <>
                      <Save className="w-4 h-4" />
                      {editingGenre ? 'Actualizar' : 'Crear'} G√©nero
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/admin/layout.tsx
// ==================================================
// src/app/admin/layout.tsx
'use client'

import './admin.css'

import Link from 'next/link'
import { 
  Film, 
  Users, 
  Building2, 
  Award, 
  Globe, 
  Tv,
  Clapperboard,
  Home,
  Menu,
  X,
  Tag,
  Hash,
  BarChart3
} from 'lucide-react'
import { ReactNode, useState } from 'react'

interface AdminLayoutProps {
  children: ReactNode
}

export default function AdminLayout({ children }: AdminLayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false)

  const navigation = [
    { name: 'Dashboard', href: '/admin', icon: Home },
    { name: 'Estad√≠sticas', href: '/admin/stats', icon: BarChart3 },
    { name: 'Pel√≠culas', href: '/admin/movies', icon: Film },
    { name: 'Personas', href: '/admin/people', icon: Users },
    { name: 'G√©neros', href: '/admin/genres', icon: Hash },
    { name: 'Productoras', href: '/admin/companies/production', icon: Building2 },
    { name: 'Distribuidoras', href: '/admin/companies/distribution', icon: Building2 },
    { name: 'Pantallas de Estreno', href: '/admin/screening-venues', icon: Tv },
    { name: 'Roles', href: '/admin/roles', icon: Clapperboard },
    { name: 'Premios', href: '/admin/awards', icon: Award },
    { name: 'Lugares', href: '/admin/locations', icon: Globe },
    { name: 'Temas', href: '/admin/themes', icon: Tag },
    { name: 'Calificaciones', href: '/admin/calificaciones', icon: Tag }
  ]

  return (
    <div className="min-h-screen bg-gray-100" data-admin="true">
      {/* Sidebar m√≥vil */}
      <div className={`fixed inset-0 z-40 md:hidden ${sidebarOpen ? '' : 'hidden'}`}>
        <div className="fixed inset-0 bg-gray-600 bg-opacity-75" onClick={() => setSidebarOpen(false)} />
        <nav className="fixed top-0 left-0 bottom-0 flex flex-col w-64 bg-white">
          <div className="flex items-center justify-between h-16 px-4 border-b border-gray-200">
            <h2 className="text-xl font-semibold text-gray-900">cinenacional.com admin</h2>
            <button
              onClick={() => setSidebarOpen(false)}
              className="text-gray-500 hover:text-gray-700"
            >
              <X className="w-6 h-6" />
            </button>
          </div>
          <div className="flex-1 px-4 py-4 space-y-1">
            {navigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className="flex items-center px-3 py-2 text-sm font-medium rounded-lg hover:bg-gray-100 text-gray-700"
              >
                <item.icon className="w-5 h-5 mr-3 text-gray-600" />
                {item.name}
              </Link>
            ))}
          </div>
        </nav>
      </div>

      {/* Sidebar desktop */}
      <div className="hidden md:flex md:w-64 md:flex-col md:fixed md:inset-y-0">
        <nav className="flex-1 flex flex-col bg-white border-r border-gray-200">
          <div className="flex items-center h-16 px-4 border-b border-gray-200">
            <h2 className="text-xl font-semibold text-gray-900">cinenacional.com admin</h2>
          </div>
          <div className="flex-1 px-4 py-4 space-y-1">
            {navigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className="flex items-center px-3 py-2 text-sm font-medium rounded-lg hover:bg-gray-100 text-gray-700"
              >
                <item.icon className="w-5 h-5 mr-3 text-gray-600" />
                {item.name}
              </Link>
            ))}
          </div>
          <div className="p-4 border-t border-gray-200">
            <Link
              href="/"
              className="flex items-center px-3 py-2 text-sm font-medium rounded-lg hover:bg-gray-100 text-gray-700"
            >
              Volver al sitio
            </Link>
          </div>
        </nav>
      </div>

      {/* Contenido principal */}
      <div className="md:pl-64">
        {/* Header m√≥vil */}
        <div className="sticky top-0 z-10 md:hidden bg-white shadow">
          <div className="px-4 py-3">
            <button
              onClick={() => setSidebarOpen(true)}
              className="text-gray-500 hover:text-gray-700"
            >
              <Menu className="w-6 h-6" />
            </button>
          </div>
        </div>

        {/* Contenido */}
        <main className="text-gray-900">{children}</main>
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/locations/new/page.tsx
// ==================================================
// src/app/admin/locations/new/page.tsx

import { Suspense } from 'react'
import LocationForm from '@/components/admin/locations/LocationForm'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'

export const metadata = {
  title: 'Nuevo Lugar - Admin',
  description: 'Crear nuevo lugar'
}

export default function NewLocationPage() {
  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <div className="mb-8">
        <Link
          href="/admin/locations"
          className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 mb-4"
        >
          <ArrowLeft className="w-4 h-4" />
          Volver a lugares
        </Link>
        
        <h1 className="text-3xl font-bold text-gray-900">Nuevo Lugar</h1>
        <p className="mt-2 text-gray-600">
          Agrega un nuevo pa√≠s, provincia, estado o ciudad
        </p>
      </div>

      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <Suspense fallback={<div>Cargando formulario...</div>}>
          <LocationForm />
        </Suspense>
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/locations/page.tsx
// ==================================================
// src/app/admin/locations/page.tsx

import Link from 'next/link'
import { Plus } from 'lucide-react'
import LocationTree from '@/components/admin/locations/LocationTree'

export const metadata = {
  title: 'Lugares - Admin',
  description: 'Administraci√≥n de lugares'
}

// Revalidar cada 0 segundos (sin cach√©)
export const revalidate = 0

export default function LocationsAdminPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Lugares</h1>
          <p className="mt-2 text-gray-600">
            Gestiona la estructura jer√°rquica de pa√≠ses, provincias, estados y ciudades
          </p>
        </div>
        
        <Link
          href="/admin/locations/new"
          className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
        >
          <Plus className="w-5 h-5" />
          Nuevo Lugar
        </Link>
      </div>

      <LocationTree />
    </div>
  )
}

// ==================================================
// src/app/admin/locations/[id]/edit/page.tsx
// ==================================================
// src/app/admin/locations/[id]/edit/page.tsx

import { notFound } from 'next/navigation'
import LocationForm from '@/components/admin/locations/LocationForm'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'
import { prisma } from '@/lib/prisma'

export const metadata = {
  title: 'Editar Lugar - Admin',
  description: 'Editar lugar existente'
}

interface EditLocationPageProps {
  params: {
    id: string
  }
}

async function getLocation(id: number) {
  const location = await prisma.location.findUnique({
    where: { id },
    include: {
      parent: true
    }
  })
  
  return location
}

export default async function EditLocationPage({ params }: EditLocationPageProps) {
  const id = parseInt(params.id)
  
  if (isNaN(id)) {
    notFound()
  }
  
  const location = await getLocation(id)
  
  if (!location) {
    notFound()
  }

  // Convertir Decimal a string y simplificar el objeto para el formulario
  const locationData = {
    id: location.id,
    name: location.name,
    slug: location.slug,
    parentId: location.parentId,
    parent: location.parent ? {
      id: location.parent.id,
      name: location.parent.name
    } : undefined,
    latitude: location.latitude?.toString() || null,
    longitude: location.longitude?.toString() || null
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <div className="mb-8">
        <Link
          href="/admin/locations"
          className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 mb-4"
        >
          <ArrowLeft className="w-4 h-4" />
          Volver a lugares
        </Link>
        
        <h1 className="text-3xl font-bold text-gray-900">Editar Lugar</h1>
        <p className="mt-2 text-gray-600">
          Modifica la informaci√≥n de {location.name}
        </p>
      </div>

      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <LocationForm location={locationData} />
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/login/page.tsx
// ==================================================
'use client'

import { Suspense } from 'react'
import { useState } from 'react'
import { signIn } from 'next-auth/react'
import { useRouter, useSearchParams } from 'next/navigation'
import { toast } from 'react-hot-toast'

function LoginForm() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const callbackUrl = searchParams.get('callbackUrl') || '/admin'
  
  const [loading, setLoading] = useState(false)
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  })
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    
    try {
      const result = await signIn('credentials', {
        email: formData.email,
        password: formData.password,
        redirect: false
      })
      
      if (result?.error) {
        toast.error('Credenciales inv√°lidas')
      } else {
        toast.success('¬°Bienvenido!')
        window.location.href = callbackUrl
      }
    } catch (error) {
      toast.error('Error al iniciar sesi√≥n')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
      <div className="rounded-md shadow-sm -space-y-px">
        <div>
          <label htmlFor="email" className="sr-only">
            Email
          </label>
          <input
            id="email"
            name="email"
            type="email"
            autoComplete="email"
            required
            className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
            placeholder="Email"
            value={formData.email}
            onChange={(e) => setFormData({...formData, email: e.target.value})}
          />
        </div>
        <div>
          <label htmlFor="password" className="sr-only">
            Contrase√±a
          </label>
          <input
            id="password"
            name="password"
            type="password"
            autoComplete="current-password"
            required
            className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
            placeholder="Contrase√±a"
            value={formData.password}
            onChange={(e) => setFormData({...formData, password: e.target.value})}
          />
        </div>
      </div>
      
      <div>
        <button
          type="submit"
          disabled={loading}
          className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {loading ? 'Ingresando...' : 'Ingresar'}
        </button>
      </div>
    </form>
  )
}

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Acceso Administrativo
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            cinenacional.com admin panel
          </p>
        </div>
        
        <Suspense fallback={<div>Cargando...</div>}>
          <LoginForm />
        </Suspense>
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/maintenance/review-names/page.tsx
// ==================================================
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

interface CaseToReview {
  id: number;
  firstName: string;
  lastName: string;
  slug: string;
  totalRoles: number;
  firstNameWords: number;
  lastNameWords: number;
}

export default function ReviewNamesPage() {
  const router = useRouter();
  const [cases, setCases] = useState<CaseToReview[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  
  // Form state
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // Cargar casos al montar
  useEffect(() => {
    loadCases();
  }, []);

  // Actualizar form cuando cambia el caso actual
  useEffect(() => {
    if (cases.length > 0 && cases[currentIndex]) {
      const currentCase = cases[currentIndex];
      setFirstName(currentCase.firstName);
      setLastName(currentCase.lastName);
    }
  }, [currentIndex, cases]);

  const loadCases = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/people/review-names');
      const data = await response.json();
      
      if (data.cases) {
        setCases(data.cases);
        if (data.cases.length === 0) {
          toast.success('¬°No hay casos para revisar!');
        }
      }
    } catch (error) {
      console.error('Error loading cases:', error);
      toast.error('Error al cargar casos');
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    if (!cases[currentIndex]) return;
    
    try {
      setSaving(true);
      
      const response = await fetch('/api/people/review-names', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          id: cases[currentIndex].id,
          firstName: firstName.trim(),
          lastName: lastName.trim()
        })
      });

      if (!response.ok) {
        throw new Error('Error al guardar');
      }

      toast.success('Cambios guardados');
      
      // Remover caso actual de la lista
      const newCases = cases.filter((_, index) => index !== currentIndex);
      setCases(newCases);
      
      // Ajustar √≠ndice si es necesario
      if (currentIndex >= newCases.length && newCases.length > 0) {
        setCurrentIndex(newCases.length - 1);
      }

      // Si no quedan m√°s casos
      if (newCases.length === 0) {
        toast.success('¬°Todos los casos revisados!');
      }

    } catch (error) {
      console.error('Error saving:', error);
      toast.error('Error al guardar cambios');
    } finally {
      setSaving(false);
    }
  };

  const handleSkip = () => {
    // Remover caso actual (marcarlo como correcto)
    const newCases = cases.filter((_, index) => index !== currentIndex);
    setCases(newCases);
    
    // Ajustar √≠ndice
    if (currentIndex >= newCases.length && newCases.length > 0) {
      setCurrentIndex(newCases.length - 1);
    }

    toast.success('Caso marcado como correcto');

    if (newCases.length === 0) {
      toast.success('¬°Todos los casos revisados!');
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const handleNext = () => {
    if (currentIndex < cases.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Cargando casos...</p>
        </div>
      </div>
    );
  }

  if (cases.length === 0) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="text-6xl mb-4">‚úÖ</div>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">
            ¬°Todos los casos revisados!
          </h2>
          <p className="text-gray-600 mb-6">
            No hay m√°s nombres para revisar
          </p>
          <button
            onClick={() => router.push('/admin/people')}
            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
          >
            Volver a Personas
          </button>
        </div>
      </div>
    );
  }

  const currentCase = cases[currentIndex];

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Header */}
        <div className="mb-8">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold text-gray-900">
                Revisar Nombres
              </h1>
              <p className="mt-2 text-sm text-gray-600">
                Casos con m√°s de 3 palabras en nombre o apellido
              </p>
            </div>
            <button
              onClick={() => router.push('/admin/people')}
              className="text-gray-600 hover:text-gray-900"
            >
              ‚Üê Volver
            </button>
          </div>
        </div>

        {/* Progress */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-gray-700">
              Caso {currentIndex + 1} de {cases.length}
            </span>
            <span className="text-sm text-gray-500">
              {Math.round(((currentIndex + 1) / cases.length) * 100)}% completado
            </span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className="bg-indigo-600 h-2 rounded-full transition-all duration-300"
              style={{ width: `${((currentIndex + 1) / cases.length) * 100}%` }}
            />
          </div>
        </div>

        {/* Current Case */}
        <div className="bg-white rounded-lg shadow">
          {/* Case Info */}
          <div className="p-6 border-b border-gray-200">
            <div className="flex items-start justify-between">
              <div>
                <h2 className="text-lg font-medium text-gray-900 mb-2">
                  ID: {currentCase.id}
                </h2>
                <div className="space-y-1 text-sm text-gray-600">
                  <p>Slug: <span className="font-mono">{currentCase.slug}</span></p>
                  <p>Roles en pel√≠culas: <span className="font-semibold">{currentCase.totalRoles}</span></p>
                  <p>
                    Palabras: {currentCase.firstNameWords} (nombre) / {currentCase.lastNameWords} (apellido)
                  </p>
                </div>
              </div>
            </div>
          </div>

          {/* Form */}
          <div className="p-6">
            <div className="space-y-6">
              {/* First Name */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Nombre
                  <span className="ml-2 text-xs text-gray-500">
                    ({firstName.trim().split(/\s+/).length} palabra{firstName.trim().split(/\s+/).length !== 1 ? 's' : ''})
                  </span>
                </label>
                <input
                  type="text"
                  value={firstName}
                  onChange={(e) => setFirstName(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500"
                  placeholder="Nombre"
                />
              </div>

              {/* Last Name */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Apellido
                  <span className="ml-2 text-xs text-gray-500">
                    ({lastName.trim().split(/\s+/).length} palabra{lastName.trim().split(/\s+/).length !== 1 ? 's' : ''})
                  </span>
                </label>
                <input
                  type="text"
                  value={lastName}
                  onChange={(e) => setLastName(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500"
                  placeholder="Apellido"
                />
              </div>

              {/* Preview */}
              <div className="bg-gray-50 p-4 rounded-md">
                <p className="text-sm text-gray-600 mb-1">Vista previa:</p>
                <p className="text-lg font-medium text-gray-900">
                  {firstName.trim()} {lastName.trim()}
                </p>
              </div>
            </div>
          </div>

          {/* Actions */}
          <div className="p-6 bg-gray-50 border-t border-gray-200 flex items-center justify-between">
            <button
              onClick={handleSkip}
              disabled={saving}
              className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50"
            >
              Marcar como Correcto
            </button>

            <button
              onClick={handleSave}
              disabled={saving || (!firstName.trim() && !lastName.trim())}
              className="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {saving ? 'Guardando...' : 'Guardar Cambios'}
            </button>
          </div>
        </div>

        {/* Navigation */}
        <div className="mt-6 flex items-center justify-between">
          <button
            onClick={handlePrevious}
            disabled={currentIndex === 0}
            className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            ‚Üê Anterior
          </button>

          <span className="text-sm text-gray-600">
            Caso {currentIndex + 1} de {cases.length}
          </span>

          <button
            onClick={handleNext}
            disabled={currentIndex === cases.length - 1}
            className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Siguiente ‚Üí
          </button>
        </div>

        {/* Help Text */}
        <div className="mt-8 bg-blue-50 border border-blue-200 rounded-lg p-4">
          <h3 className="text-sm font-medium text-blue-900 mb-2">üí° Consejos</h3>
          <ul className="text-sm text-blue-800 space-y-1">
            <li>‚Ä¢ Si el nombre est√° correcto, haz clic en "Marcar como Correcto"</li>
            <li>‚Ä¢ Los apellidos compuestos (ej: "de la Cruz") son correctos</li>
            <li>‚Ä¢ Las bandas y grupos pueden tener nombres largos</li>
            <li>‚Ä¢ Los cambios se guardan autom√°ticamente</li>
          </ul>
        </div>
      </div>
    </div>
  );
}

// ==================================================
// src/app/admin/movies/page.tsx
// ==================================================
// src/app/admin/movies/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { toast } from 'react-hot-toast'
import MoviesFilters, { type MovieFilters } from '@/components/admin/movies/MoviesFilters'
import MoviesPagination from '@/components/admin/movies/MoviesPagination'
import MoviesTable from '@/components/admin/movies/MoviesTable'
import MovieModal from '@/components/admin/movies/MovieModal'
import { MovieModalProvider } from '@/contexts/MovieModalContext'
import { moviesService } from '@/services'
import { type Movie } from '@/lib/movies/movieTypes'

export default function AdminMoviesPage() {
  const [movies, setMovies] = useState<Movie[]>([])
  const [loading, setLoading] = useState(true)
  const [totalPages, setTotalPages] = useState(1)
  const [showModal, setShowModal] = useState(false)
  const [editingMovie, setEditingMovie] = useState<Movie | null>(null)

  // Estados de filtros
  const [filters, setFilters] = useState<MovieFilters>({
    searchTerm: '',
    selectedStage: '',
    selectedYear: '',
    currentPage: 1
  })

  const handleFiltersChange = (newFilters: Partial<MovieFilters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }))
  }

  // Cargar pel√≠culas
  const fetchMovies = async () => {
    try {
      setLoading(true)
      const { movies, pagination } = await moviesService.getAll(filters)
      setMovies(movies)
      setTotalPages(pagination.totalPages)
    } catch (error) {
      toast.error('Error al cargar las pel√≠culas')
      setMovies([])
      setTotalPages(1)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchMovies()
  }, [filters])

  // Editar pel√≠cula
  const handleEdit = async (movie: Movie) => {
    setEditingMovie(movie)
    setShowModal(true)
  }

  // Eliminar pel√≠cula
  const handleDelete = async (id: number) => {
    await moviesService.delete(id)
    fetchMovies()
  }

  // Abrir modal para nueva pel√≠cula
  const handleNewMovie = () => {
    setEditingMovie(null)
    setShowModal(true)
  }

  // Callbacks para el context
  const handleMovieSuccess = (movie: Movie) => {
    setShowModal(false)
    setEditingMovie(null)
    fetchMovies()
    
    // Toast espec√≠fico seg√∫n la acci√≥n
    if (editingMovie) {
      toast.success(`Pel√≠cula "${movie.title}" actualizada exitosamente`)
    } else {
      toast.success(`Pel√≠cula "${movie.title}" creada exitosamente`)
    }
  }

  const handleMovieError = (error: Error) => {
    console.error('Error en operaci√≥n de pel√≠cula:', error)
    toast.error(error.message || 'Error al procesar la pel√≠cula')
  }

  const handleCloseModal = () => {
    setShowModal(false)
    setEditingMovie(null)
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Administraci√≥n de Pel√≠culas
            </h1>
          </div>
        </div>
      </div>

      {/* Contenido principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Filtros y acciones */}
        <MoviesFilters
          filters={filters}
          onFiltersChange={handleFiltersChange}
          onNewMovie={handleNewMovie}
        />

        {/* Lista de pel√≠culas */}
        <MoviesTable
          movies={movies}
          loading={loading}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />

        {/* Paginaci√≥n */}
        {totalPages > 1 && (
          <MoviesPagination
            currentPage={filters.currentPage}
            totalPages={totalPages}
            onPageChange={(page) => handleFiltersChange({ currentPage: page })}
          />
        )}

        {/* Modal envuelto en el Provider */}
        <MovieModalProvider
          editingMovie={editingMovie}
          onSuccess={handleMovieSuccess}
          onError={handleMovieError}
        >
          <MovieModal
            isOpen={showModal}
            onClose={handleCloseModal}
          />
        </MovieModalProvider>
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/page.tsx
// ==================================================
export const dynamic = 'force-dynamic'

export default function AdminDashboard() {
  return (
    <div className="p-8">
      <h1 className="text-3xl font-bold mb-6">Panel de Administraci√≥n</h1>
      
      <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
        <a href="/admin/stats" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Estad√≠sticas</h2>
          <p className="text-gray-600">Ver visitas y popularidad</p>
        </a>
        
        <a href="/admin/movies" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Pel√≠culas</h2>
          <p className="text-gray-600">Gestionar pel√≠culas</p>
        </a>
        
        <a href="/admin/people" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Personas</h2>
          <p className="text-gray-600">Gestionar personas</p>
        </a>
        
        <a href="/admin/genres" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">G√©neros</h2>
          <p className="text-gray-600">Gestionar g√©neros</p>
        </a>
        
        <a href="/admin/locations" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Ubicaciones</h2>
          <p className="text-gray-600">Gestionar ubicaciones</p>
        </a>
        
        <a href="/admin/themes" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Temas</h2>
          <p className="text-gray-600">Gestionar temas</p>
        </a>
        
        <a href="/admin/roles" className="p-6 bg-white rounded-lg shadow hover:shadow-lg">
          <h2 className="text-xl font-semibold">Roles</h2>
          <p className="text-gray-600">Gestionar roles</p>
        </a>
      </div>
    </div>
  )
}

// ==================================================
// src/app/admin/people/new/page.tsx
// ==================================================
// src/app/admin/people/new/page.tsx

import { Metadata } from 'next';
import Link from 'next/link';
import { PersonForm } from '@/components/admin/people/PersonForm';
import { ArrowLeft, UserPlus } from 'lucide-react';

export const metadata: Metadata = {
  title: 'Nueva Persona | Admin',
  description: 'Crear nueva persona en el sistema',
};

export default function NewPersonPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-5xl">
        {/* Header */}
        <div className="mb-6">
          <Link 
            href="/admin/people"
            className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 transition-colors mb-4"
          >
            <ArrowLeft className="w-4 h-4" />
            Volver al listado
          </Link>
          
          <div className="flex items-center gap-3">
            <UserPlus className="h-8 w-8 text-gray-700" />
            <div>
              <h1 className="text-3xl font-bold text-gray-900">Nueva Persona</h1>
              <p className="text-gray-600 mt-1">
                Complete los datos para agregar una nueva persona al sistema
              </p>
            </div>
          </div>
        </div>

        {/* Formulario */}
        <PersonForm />
      </div>
    </div>
  );
}

// ==================================================
// src/app/admin/people/page.tsx
// ==================================================
// src/app/admin/people/page.tsx

import { Suspense } from 'react';
import { Metadata } from 'next';
import { PeopleTable } from '@/components/admin/people/PeopleTable';
import Link from 'next/link';
import { Plus, Users, Loader2 } from 'lucide-react';

export const metadata: Metadata = {
  title: 'Gesti√≥n de Personas | Admin',
  description: 'Administraci√≥n de personas del cine argentino',
};

export default function PeoplePage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8">
        {/* Header */}
        <div className="mb-8">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
            <div>
              <h1 className="text-3xl font-bold text-gray-900 flex items-center gap-3">
                <Users className="h-8 w-8 text-gray-700" />
                Gesti√≥n de Personas
              </h1>
              <p className="mt-2 text-gray-600">
                Administra el registro de actores, directores y personal t√©cnico del cine argentino
              </p>
            </div>
            
            <div className="mt-4 sm:mt-0">
              <Link 
                href="/admin/people/new"
                className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                <Plus className="w-5 h-5" />
                Nueva Persona
              </Link>
            </div>
          </div>
        </div>

        {/* Stats Cards (opcional - comentado por ahora) */}
        {/* 
        <div className="grid gap-4 md:grid-cols-3 mb-8">
          <div className="bg-white rounded-lg shadow p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Total Personas</p>
                <p className="text-2xl font-bold text-gray-900">-</p>
              </div>
              <Users className="h-8 w-8 text-gray-400" />
            </div>
          </div>
          
          <div className="bg-white rounded-lg shadow p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Actores</p>
                <p className="text-2xl font-bold text-gray-900">-</p>
              </div>
              <Users className="h-8 w-8 text-gray-400" />
            </div>
          </div>
          
          <div className="bg-white rounded-lg shadow p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Directores</p>
                <p className="text-2xl font-bold text-gray-900">-</p>
              </div>
              <Users className="h-8 w-8 text-gray-400" />
            </div>
          </div>
        </div>
        */}
        
        {/* Tabla */}
        <Suspense fallback={
          <div className="bg-white rounded-lg shadow overflow-hidden">
            <div className="flex items-center justify-center h-64">
              <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
            </div>
          </div>
        }>
          <PeopleTable />
        </Suspense>
      </div>
    </div>
  );
}

// ==================================================
// src/app/admin/people/[id]/edit/page.tsx
// ==================================================
// src/app/admin/people/[id]/edit/page.tsx

'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';
import { useRouter, useParams } from 'next/navigation';
import { PersonForm } from '@/components/admin/people/PersonForm';
import { ArrowLeft, Edit, Loader2, AlertCircle } from 'lucide-react';
import { usePerson } from '@/hooks/usePeople';

export default function EditPersonPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;
  const { person, loading, error } = usePerson(id);

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-5xl">
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
          </div>
        </div>
      </div>
    );
  }

  if (error || !person) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-5xl">
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
            <div className="flex">
              <AlertCircle className="h-5 w-5 text-red-400" />
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {error?.message || 'No se pudo cargar la informaci√≥n de la persona'}
                </h3>
              </div>
            </div>
          </div>
          <Link 
            href="/admin/people"
            className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
          >
            <ArrowLeft className="w-4 h-4" />
            Volver al listado
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-5xl">
        {/* Header */}
        <div className="mb-6">
          <Link 
            href="/admin/people"
            className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 transition-colors mb-4"
          >
            <ArrowLeft className="w-4 h-4" />
            Volver al listado
          </Link>
          
          <div className="flex items-center gap-3">
            <Edit className="h-8 w-8 text-gray-700" />
            <div>
              <h1 className="text-3xl font-bold text-gray-900">
                Editar Persona
              </h1>
              <p className="text-gray-600 mt-1">
                Modificando: {person.firstName} {person.lastName}
              </p>
            </div>
          </div>
        </div>

        {/* Formulario */}
        <PersonForm 
          personId={parseInt(id)} 
          initialData={person}
          onSuccess={() => router.push('/admin/people')}
        />
      </div>
    </div>
  );
}

// ==================================================
// src/app/admin/people/[id]/page.tsx
// ==================================================
// src/app/admin/people/[id]/page.tsx

'use client';

import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { 
  ArrowLeft, 
  Edit, 
  ExternalLink, 
  Calendar,
  MapPin,
  Film,
  Award,
  Loader2,
  AlertCircle,
  User
} from 'lucide-react';
import { usePerson } from '@/hooks/usePeople';
import { formatPersonName, formatGender, formatBirthInfo } from '@/lib/people/peopleUtils';
import { PERSON_LINK_TYPES } from '@/lib/people/peopleConstants';

export default function PersonDetailPage() {
  const params = useParams();
  const id = params.id as string;
  const { person, loading, error } = usePerson(id);

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-6xl">
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
          </div>
        </div>
      </div>
    );
  }

  if (error || !person) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-6xl">
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
            <div className="flex">
              <AlertCircle className="h-5 w-5 text-red-400" />
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {error?.message || 'No se pudo cargar la informaci√≥n de la persona'}
                </h3>
              </div>
            </div>
          </div>
          <Link 
            href="/admin/people"
            className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
          >
            <ArrowLeft className="w-4 h-4" />
            Volver al listado
          </Link>
        </div>
      </div>
    );
  }

  const fullName = formatPersonName(person);

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6 px-4 sm:px-6 lg:px-8 max-w-6xl">
        {/* Header */}
        <div className="mb-6 flex items-center justify-between">
          <Link 
            href="/admin/people"
            className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 transition-colors"
          >
            <ArrowLeft className="w-4 h-4" />
            Volver al listado
          </Link>
          
          <Link 
            href={`/admin/people/${id}/edit`}
            className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            <Edit className="w-4 h-4" />
            Editar
          </Link>
        </div>

        {/* Info principal */}
        <div className="grid gap-6 md:grid-cols-3">
          {/* Columna izquierda - Foto y datos b√°sicos */}
          <div className="space-y-6">
            <div className="bg-white rounded-lg shadow p-6">
              <div className="space-y-4">
                {/* Foto */}
                <div className="relative aspect-[3/4] w-full overflow-hidden rounded-lg bg-gray-100">
                  {person.photoUrl ? (
                    <Image
                      src={person.photoUrl}
                      alt={fullName}
                      fill
                      className="object-cover"
                      sizes="(max-width: 768px) 100vw, 33vw"
                    />
                  ) : (
                    <div className="flex h-full items-center justify-center">
                      <User className="h-16 w-16 text-gray-400" />
                    </div>
                  )}
                </div>

                {/* Nombre y estado */}
                <div className="text-center">
                  <h1 className="text-2xl font-bold text-gray-900">{fullName}</h1>
                  {person.realName && (
                    <p className="text-sm text-gray-500 mt-1">
                      {person.realName}
                    </p>
                  )}
                  <div className="mt-3">
                    <span className={`inline-flex items-center px-3 py-1 rounded-full text-xs font-medium ${
                      person.isActive 
                        ? 'bg-green-100 text-green-800' 
                        : 'bg-gray-100 text-gray-800'
                    }`}>
                      {person.isActive ? 'Activo' : 'Inactivo'}
                    </span>
                  </div>
                </div>

                {/* Datos b√°sicos */}
                <div className="space-y-3 text-sm">
                  {person.gender && (
                    <div className="flex items-center gap-2">
                      <User className="h-4 w-4 text-gray-400" />
                      <span className="text-gray-700">{formatGender(person.gender)}</span>
                    </div>
                  )}
                  
                  {person.birthDate && (
                    <div className="flex items-center gap-2">
                      <Calendar className="h-4 w-4 text-gray-400" />
                      <span className="text-gray-700">{formatBirthInfo(person)}</span>
                    </div>
                  )}
                  
                  {person.birthLocation && (
                    <div className="flex items-center gap-2">
                      <MapPin className="h-4 w-4 text-gray-400" />
                      <span className="text-gray-700">Nacido en {person.birthLocation.name}</span>
                    </div>
                  )}
                  
                  {person.deathDate && (
                    <>
                      <div className="flex items-center gap-2">
                        <Calendar className="h-4 w-4 text-gray-400" />
                        <span className="text-gray-700">
                          Fallecido el {new Date(person.deathDate).toLocaleDateString('es-AR')}
                        </span>
                      </div>
                      {person.deathLocation && (
                        <div className="flex items-center gap-2">
                          <MapPin className="h-4 w-4 text-gray-400" />
                          <span className="text-gray-700">en {person.deathLocation.name}</span>
                        </div>
                      )}
                    </>
                  )}
                </div>

                {/* Estad√≠sticas */}
                <div className="grid grid-cols-2 gap-4 pt-4 border-t">
                  <div className="text-center">
                    <p className="text-2xl font-bold text-gray-900">
                      {(person._count?.castRoles || 0) + (person._count?.crewRoles || 0)}
                    </p>
                    <p className="text-xs text-gray-500">Pel√≠culas</p>
                  </div>
                  <div className="text-center">
                    <p className="text-2xl font-bold text-gray-900">{person._count?.awards || 0}</p>
                    <p className="text-xs text-gray-500">Premios</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Enlaces */}
            {person.links && person.links.length > 0 && (
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-4">Enlaces</h3>
                <div className="space-y-2">
                  {person.links
                    .filter(link => link.isActive)
                    .map((link) => (
                      <a
                        key={link.id}
                        href={link.url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 transition-colors"
                      >
                        <ExternalLink className="h-3 w-3" />
                        {link.title || PERSON_LINK_TYPES[link.type] || link.type}
                        {link.isVerified && (
                          <span className="ml-auto px-2 py-0.5 text-xs bg-green-100 text-green-800 rounded-full">
                            Verificado
                          </span>
                        )}
                      </a>
                    ))}
                </div>
              </div>
            )}
          </div>

          {/* Columna derecha - Contenido principal */}
          <div className="md:col-span-2 space-y-6">
            {/* Biograf√≠a */}
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="text-lg font-medium text-gray-900 mb-4">Biograf√≠a</h3>
              {person.biography ? (
                <div className="prose prose-sm max-w-none">
                  {person.biography.split('\n').map((paragraph, index) => (
                    <p key={index} className="mb-4 text-gray-700">{paragraph}</p>
                  ))}
                </div>
              ) : (
                <p className="text-gray-500">
                  No hay biograf√≠a disponible
                </p>
              )}
            </div>

            {/* Filmograf√≠a */}
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
                <Film className="h-5 w-5" />
                Filmograf√≠a
              </h3>
              <div className="space-y-4">
                {person._count?.castRoles && person._count.castRoles > 0 && (
                  <div>
                    <h4 className="font-medium text-gray-900 mb-2">Como Actor/Actriz</h4>
                    <p className="text-gray-600">
                      {person._count.castRoles} pel√≠culas
                    </p>
                  </div>
                )}
                
                {person._count?.crewRoles && person._count.crewRoles > 0 && (
                  <div>
                    <h4 className="font-medium text-gray-900 mb-2">Como Equipo T√©cnico</h4>
                    <p className="text-gray-600">
                      {person._count.crewRoles} pel√≠culas
                    </p>
                  </div>
                )}
                
                {(!person._count?.castRoles && !person._count?.crewRoles) && (
                  <p className="text-gray-500">
                    No hay pel√≠culas asociadas
                  </p>
                )}
              </div>
            </div>

            {/* Premios */}
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
                <Award className="h-5 w-5" />
                Premios y Reconocimientos
              </h3>
              {person._count?.awards && person._count.awards > 0 ? (
                <p className="text-gray-600">
                  {person._count.awards} premios registrados
                </p>
              ) : (
                <p className="text-gray-500">
                  No hay premios registrados
                </p>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ==================================================
// src/app/admin/roles/page.tsx
// ==================================================
// src/app/admin/roles/page.tsx

'use client';

import React, { useState } from 'react';
import { Plus, Search, Download, Filter } from 'lucide-react';
import { useRoles } from '@/hooks/useRoles';
import { RoleModal } from '@/components/admin/roles/RoleModal';
import { RoleCard } from '@/components/admin/roles/RoleCard';
import { useDebounce } from '@/hooks/useDebounce';
import { Department, getDepartmentOptions } from '@/lib/roles/rolesTypes';
import toast from 'react-hot-toast';

export default function RolesPage() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingRole, setEditingRole] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [departmentFilter, setDepartmentFilter] = useState<'all' | Department>('all');
  const [activeFilter, setActiveFilter] = useState<'all' | 'active' | 'inactive'>('all');
  const [mainRoleFilter, setMainRoleFilter] = useState<'all' | 'main' | 'regular'>('all');

  const debouncedSearch = useDebounce(searchTerm, 300);

  const {
    roles,
    totalCount,
    totalPages,
    currentPage,
    loading,
    error,
    filters,
    updateFilter,
    goToPage,
    goToNextPage,
    goToPreviousPage,
    canGoNext,
    canGoPrevious,
    deleteRole,
    exportToCSV,
    seedDefault
  } = useRoles();

  // Aplicar filtros cuando cambien los valores
  React.useEffect(() => {
    updateFilter('search', debouncedSearch);
  }, [debouncedSearch, updateFilter]);

  React.useEffect(() => {
    const deptValue = departmentFilter === 'all' ? '' : departmentFilter;
    updateFilter('department', deptValue);
  }, [departmentFilter, updateFilter]);

  React.useEffect(() => {
    const isActiveValue = activeFilter === 'all' ? '' : activeFilter === 'active';
    updateFilter('isActive', isActiveValue);
  }, [activeFilter, updateFilter]);

  React.useEffect(() => {
    const isMainValue = mainRoleFilter === 'all' ? '' : mainRoleFilter === 'main';
    updateFilter('isMainRole', isMainValue);
  }, [mainRoleFilter, updateFilter]);

  const handleCreateNew = () => {
    setEditingRole(null);
    setIsModalOpen(true);
  };

  const handleEdit = (role: any) => {
    setEditingRole(role);
    setIsModalOpen(true);
  };

  const handleDelete = async (id: number) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este rol?')) {
      try {
        await deleteRole(id);
        toast.success('Rol eliminado correctamente');
      } catch (error) {
        toast.error('Error al eliminar el rol');
      }
    }
  };

  const handleExport = async () => {
    try {
      await exportToCSV();
      toast.success('Exportaci√≥n iniciada');
    } catch (error) {
      toast.error('Error al exportar');
    }
  };

  const handleSeedDefault = async () => {
    if (window.confirm('¬øQuieres crear los roles por defecto? Esto no eliminar√° los existentes.')) {
      try {
        const result = await seedDefault();
        toast.success(`Se crearon ${result.created} roles nuevos (${result.skipped} ya exist√≠an)`);
      } catch (error) {
        toast.error('Error al crear roles por defecto');
      }
    }
  };

  const handleModalSuccess = () => {
    setIsModalOpen(false);
    setEditingRole(null);
  };

  const departmentOptions = getDepartmentOptions();

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="text-center">
          <p className="text-red-600 mb-4">Error al cargar roles</p>
          <button 
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Intentar de nuevo
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Roles</h1>
          <p className="text-gray-600">
            Gestiona los roles del equipo t√©cnico y art√≠stico
          </p>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={handleSeedDefault}
            className="hidden sm:flex px-3 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50"
          >
            Crear por defecto
          </button>
          <button
            onClick={handleExport}
            className="hidden sm:flex items-center gap-2 px-3 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50"
          >
            <Download className="w-4 h-4" />
            Exportar
          </button>
          <button
            onClick={handleCreateNew}
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700"
          >
            <Plus className="w-4 h-4" />
            Nuevo Rol
          </button>
        </div>
      </div>

      {/* Filtros */}
      <div className="flex flex-col gap-4">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
          <input
            type="text"
            placeholder="Buscar roles..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
        </div>
        
        <div className="flex flex-wrap items-center gap-4">
          <div className="flex items-center gap-2">
            <Filter className="w-4 h-4 text-gray-400" />
            <span className="text-sm text-gray-600">Filtros:</span>
          </div>
          
          <select
            value={departmentFilter}
            onChange={(e) => setDepartmentFilter(e.target.value as any)}
            className="px-3 py-2 border border-gray-300 rounded-md text-sm"
          >
            <option value="all">Todos los departamentos</option>
            {departmentOptions.map(dept => (
              <option key={dept.value} value={dept.value}>
                {dept.label}
              </option>
            ))}
          </select>

          <select
            value={activeFilter}
            onChange={(e) => setActiveFilter(e.target.value as any)}
            className="px-3 py-2 border border-gray-300 rounded-md text-sm"
          >
            <option value="all">Todos</option>
            <option value="active">Activos</option>
            <option value="inactive">Inactivos</option>
          </select>

          <select
            value={mainRoleFilter}
            onChange={(e) => setMainRoleFilter(e.target.value as any)}
            className="px-3 py-2 border border-gray-300 rounded-md text-sm"
          >
            <option value="all">Todos los tipos</option>
            <option value="main">Roles principales</option>
            <option value="regular">Roles regulares</option>
          </select>
        </div>
      </div>

      {/* Estad√≠sticas */}
      <div className="grid grid-cols-1 sm:grid-cols-4 gap-4">
        <div className="bg-white p-4 rounded-lg border">
          <p className="text-sm text-gray-600">Total</p>
          <p className="text-2xl font-bold">{totalCount}</p>
        </div>
        <div className="bg-white p-4 rounded-lg border">
          <p className="text-sm text-gray-600">P√°gina</p>
          <p className="text-2xl font-bold">{currentPage} de {totalPages}</p>
        </div>
        <div className="bg-white p-4 rounded-lg border">
          <p className="text-sm text-gray-600">Resultados</p>
          <p className="text-2xl font-bold">{roles.length}</p>
        </div>
        <div className="bg-white p-4 rounded-lg border">
          <p className="text-sm text-gray-600">Departamento</p>
          <p className="text-sm font-medium">
            {departmentFilter === 'all' ? 'Todos' : 
             departmentOptions.find(d => d.value === departmentFilter)?.label}
          </p>
        </div>
      </div>

      {/* Lista de roles */}
      {loading ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[...Array(6)].map((_, i) => (
            <div key={i} className="bg-white p-6 rounded-lg border animate-pulse">
              <div className="h-4 bg-gray-200 rounded mb-2"></div>
              <div className="h-3 bg-gray-200 rounded mb-4 w-2/3"></div>
              <div className="h-8 bg-gray-200 rounded"></div>
            </div>
          ))}
        </div>
      ) : roles.length === 0 ? (
        <div className="text-center py-12">
          <p className="text-gray-500 mb-4">No se encontraron roles</p>
          <button
            onClick={handleCreateNew}
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 mx-auto"
          >
            <Plus className="w-4 h-4" />
            Crear primer rol
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {roles.map((role) => (
            <RoleCard
              key={role.id}
              role={role}
              onEdit={handleEdit}
              onDelete={handleDelete}
            />
          ))}
        </div>
      )}

      {/* Paginaci√≥n */}
      {totalPages > 1 && (
        <div className="flex items-center justify-center gap-2">
          <button
            onClick={goToPreviousPage}
            disabled={!canGoPrevious}
            className="px-3 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Anterior
          </button>
          <span className="text-sm text-gray-600">
            P√°gina {currentPage} de {totalPages}
          </span>
          <button
            onClick={goToNextPage}
            disabled={!canGoNext}
            className="px-3 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Siguiente
          </button>
        </div>
      )}

      {/* Modal */}
      <RoleModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        role={editingRole}
        onSuccess={handleModalSuccess}
      />
    </div>
  );
}

// ==================================================
// src/app/admin/screening-venues/page.tsx
// ==================================================
// src/app/admin/screening-venues/page.tsx
'use client'

import { useState, useEffect } from 'react'
import {
  Plus,
  Search,
  Edit,
  Trash2,
  Film,
  Tv,
  Globe,
  MapPin,
  X,
  Save,
  Loader2,
  Building,
  ExternalLink
} from 'lucide-react'

interface ScreeningVenue {
  id: number
  slug: string
  name: string
  type: string
  description?: string
  logoUrl?: string
  website?: string
  address?: string
  city?: string
  province?: string
  country?: string
  isActive: boolean
  _count: {
    screenings: number
  }
}

const venueTypeLabels = {
  CINEMA: 'Cine',
  STREAMING: 'Streaming',
  TV_CHANNEL: 'Canal de TV',
  OTHER: 'Otro'
}

const venueTypeIcons = {
  CINEMA: Building,
  STREAMING: Globe,
  TV_CHANNEL: Tv,
  OTHER: Film
}

export default function AdminScreeningVenuesPage() {
  const [venues, setVenues] = useState<ScreeningVenue[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [filterType, setFilterType] = useState('')
  const [filterActive, setFilterActive] = useState('')
  const [currentPage, setCurrentPage] = useState(1)
  const [totalPages, setTotalPages] = useState(1)
  const [showModal, setShowModal] = useState(false)
  const [editingVenue, setEditingVenue] = useState<ScreeningVenue | null>(null)
  const [deletingVenueId, setDeletingVenueId] = useState<number | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Form state
  const [formData, setFormData] = useState({
    name: '',
    type: 'CINEMA',
    description: '',
    logoUrl: '',
    website: '',
    address: '',
    city: '',
    province: '',
    country: 'Argentina',
    latitude: '',
    longitude: '',
    isActive: true
  })

  const [formErrors, setFormErrors] = useState<Record<string, string>>({})

  // Toast state
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null)

  const showToast = (message: string, type: 'success' | 'error') => {
    setToast({ message, type })
    setTimeout(() => setToast(null), 3000)
  }

  // Cargar pantallas
  const fetchVenues = async () => {
    try {
      setLoading(true)
      const params = new URLSearchParams({
        page: currentPage.toString(),
        limit: '20',
        search: searchTerm,
        type: filterType,
        isActive: filterActive
      })

      const response = await fetch(`/api/screening-venues?${params}`)

      if (!response.ok) {
        throw new Error('Error al cargar las pantallas de estreno')
      }

      const data = await response.json()
      setVenues(data.venues || [])
      setTotalPages(data.pagination?.totalPages || 1)
    } catch (error) {
      showToast('Error al cargar las pantallas de estreno', 'error')
      setVenues([])
      setTotalPages(1)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchVenues()
  }, [currentPage, searchTerm, filterType, filterActive])

  // Validar formulario
  const validateForm = () => {
    const errors: Record<string, string> = {}
    
    if (!formData.name.trim()) {
      errors.name = 'El nombre es requerido'
    }
    
    if (!formData.type) {
      errors.type = 'El tipo es requerido'
    }
    
    if (formData.logoUrl && !isValidUrl(formData.logoUrl)) {
      errors.logoUrl = 'URL inv√°lida'
    }
    
    if (formData.website && !isValidUrl(formData.website)) {
      errors.website = 'URL inv√°lida'
    }
    
    setFormErrors(errors)
    return Object.keys(errors).length === 0
  }

  const isValidUrl = (url: string) => {
    try {
      new URL(url)
      return true
    } catch {
      return false
    }
  }

  // Crear o actualizar pantalla
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!validateForm()) return
    
    setIsSubmitting(true)
    
    try {
      const processedData = {
        ...formData,
        latitude: formData.latitude ? parseFloat(formData.latitude) : undefined,
        longitude: formData.longitude ? parseFloat(formData.longitude) : undefined,
        logoUrl: formData.logoUrl || undefined,
        website: formData.website || undefined
      }

      const url = editingVenue
        ? `/api/screening-venues/${editingVenue.id}`
        : '/api/screening-venues'

      const method = editingVenue ? 'PUT' : 'POST'
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(processedData)
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Error al guardar')
      }

      showToast(editingVenue ? 'Pantalla actualizada' : 'Pantalla creada', 'success')
      setShowModal(false)
      resetForm()
      setEditingVenue(null)
      fetchVenues()
    } catch (error) {
      showToast(error instanceof Error ? error.message : 'Error al guardar', 'error')
    } finally {
      setIsSubmitting(false)
    }
  }

  // Reset form
  const resetForm = () => {
    setFormData({
      name: '',
      type: 'CINEMA',
      description: '',
      logoUrl: '',
      website: '',
      address: '',
      city: '',
      province: '',
      country: 'Argentina',
      latitude: '',
      longitude: '',
      isActive: true
    })
    setFormErrors({})
  }

  // Editar pantalla
  const handleEdit = (venue: ScreeningVenue) => {
    setEditingVenue(venue)
    
    setFormData({
      name: venue.name,
      type: venue.type,
      description: venue.description || '',
      logoUrl: venue.logoUrl || '',
      website: venue.website || '',
      address: venue.address || '',
      city: venue.city || '',
      province: venue.province || '',
      country: venue.country || 'Argentina',
      latitude: '',
      longitude: '',
      isActive: venue.isActive
    })
    
    setShowModal(true)
  }

  // Eliminar pantalla
  const handleDelete = async (id: number) => {
    if (!confirm('¬øEst√°s seguro de eliminar esta pantalla de estreno?')) return

    try {
      setDeletingVenueId(id)
      const response = await fetch(`/api/screening-venues/${id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Error al eliminar')
      }

      showToast('Pantalla eliminada', 'success')
      fetchVenues()
    } catch (error) {
      showToast(error instanceof Error ? error.message : 'Error al eliminar', 'error')
    } finally {
      setDeletingVenueId(null)
    }
  }

  // Abrir modal para nueva pantalla
  const handleNewVenue = () => {
    setEditingVenue(null)
    resetForm()
    setShowModal(true)
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Toast Notification */}
      {toast && (
        <div className={`fixed top-4 right-4 z-50 px-4 py-2 rounded-lg text-white ${
          toast.type === 'success' ? 'bg-green-500' : 'bg-red-500'
        }`}>
          {toast.message}
        </div>
      )}

      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Administraci√≥n de Pantallas de Estreno
            </h1>
          </div>
        </div>
      </div>

      {/* Contenido principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Filtros y acciones */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
            {/* B√∫squeda */}
            <div className="relative md:col-span-2">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                type="text"
                placeholder="Buscar pantallas..."
                className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>

            {/* Filtro por tipo */}
            <select
              className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              value={filterType}
              onChange={(e) => setFilterType(e.target.value)}
            >
              <option value="">Todos los tipos</option>
              <option value="CINEMA">Cines</option>
              <option value="STREAMING">Streaming</option>
              <option value="TV_CHANNEL">Canales de TV</option>
              <option value="OTHER">Otros</option>
            </select>

            {/* Filtro por estado */}
            <select
              className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              value={filterActive}
              onChange={(e) => setFilterActive(e.target.value)}
            >
              <option value="">Todos los estados</option>
              <option value="true">Activas</option>
              <option value="false">Inactivas</option>
            </select>

            {/* Bot√≥n nueva pantalla */}
            <button
              onClick={handleNewVenue}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
            >
              <Plus className="w-5 h-5" />
              Nueva Pantalla
            </button>
          </div>
        </div>

        {/* Lista de pantallas */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          {loading ? (
            <div className="flex items-center justify-center h-64">
              <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
            </div>
          ) : venues.length === 0 ? (
            <div className="text-center py-12">
              <Film className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-gray-500">No se encontraron pantallas de estreno</p>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Pantalla
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Tipo
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Ubicaci√≥n
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Pel√≠culas
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Estado
                    </th>
                    <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {venues.map((venue) => {
                    const Icon = venueTypeIcons[venue.type as keyof typeof venueTypeIcons] || Film
                    return (
                      <tr key={venue.id} className="hover:bg-gray-50">
                        <td className="px-6 py-4 whitespace-nowrap">
                          <div className="flex items-center">
                            <div className="flex-shrink-0 h-10 w-10">
                              {venue.logoUrl ? (
                                <img
                                  className="h-10 w-10 rounded-lg object-contain"
                                  src={venue.logoUrl}
                                  alt={venue.name}
                                />
                              ) : (
                                <div className="h-10 w-10 rounded-lg bg-gray-200 flex items-center justify-center">
                                  <Icon className="w-5 h-5 text-gray-400" />
                                </div>
                              )}
                            </div>
                            <div className="ml-4">
                              <div className="text-sm font-medium text-gray-900">
                                {venue.name}
                              </div>
                              {venue.website && (
                                <a
                                  href={venue.website}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1"
                                >
                                  <ExternalLink className="w-3 h-3" />
                                  Sitio web
                                </a>
                              )}
                            </div>
                          </div>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap">
                          <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">
                            {venueTypeLabels[venue.type as keyof typeof venueTypeLabels]}
                          </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {venue.type === 'CINEMA' && venue.city ? (
                            <div className="flex items-center gap-1">
                              <MapPin className="w-4 h-4" />
                              {venue.city}
                              {venue.province && `, ${venue.province}`}
                            </div>
                          ) : (
                            <span className="text-gray-400">-</span>
                          )}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                          {venue._count.screenings}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap">
                          <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            venue.isActive
                              ? 'bg-green-100 text-green-800'
                              : 'bg-gray-100 text-gray-800'
                          }`}>
                            {venue.isActive ? 'Activa' : 'Inactiva'}
                          </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                          <div className="flex items-center justify-end gap-2">
                            <button
                              onClick={() => handleEdit(venue)}
                              className="text-blue-600 hover:text-blue-900 transition-colors"
                              title="Editar"
                            >
                              <Edit className="w-4 h-4" />
                            </button>
                            <button
                              onClick={() => handleDelete(venue.id)}
                              disabled={deletingVenueId === venue.id || venue._count.screenings > 0}
                              className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                              title={venue._count.screenings > 0 ? 'No se puede eliminar con pel√≠culas asociadas' : 'Eliminar'}
                            >
                              {deletingVenueId === venue.id ? (
                                <Loader2 className="w-4 h-4 animate-spin" />
                              ) : (
                                <Trash2 className="w-4 h-4" />
                              )}
                            </button>
                          </div>
                        </td>
                      </tr>
                    )
                  })}
                </tbody>
              </table>
            </div>
          )}
        </div>

        {/* Paginaci√≥n */}
        {totalPages > 1 && (
          <div className="bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6 mt-4 rounded-lg shadow">
            <div className="flex-1 flex justify-between sm:hidden">
              <button
                onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                disabled={currentPage === 1}
                className="relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Anterior
              </button>
              <button
                onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                disabled={currentPage === totalPages}
                className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Siguiente
              </button>
            </div>
            <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
              <div>
                <p className="text-sm text-gray-700">
                  P√°gina <span className="font-medium">{currentPage}</span> de{' '}
                  <span className="font-medium">{totalPages}</span>
                </p>
              </div>
              <div>
                <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                  <button
                    onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                    disabled={currentPage === 1}
                    className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Anterior
                  </button>
                  <button
                    onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                    disabled={currentPage === totalPages}
                    className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Siguiente
                  </button>
                </nav>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Modal de creaci√≥n/edici√≥n */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-hidden">
            <div className="bg-gray-50 px-6 py-4 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h2 className="text-xl font-semibold text-gray-900">
                  {editingVenue ? 'Editar Pantalla de Estreno' : 'Nueva Pantalla de Estreno'}
                </h2>
                <button
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                    setEditingVenue(null)
                  }}
                  className="text-gray-400 hover:text-gray-500"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>

            <div className="p-6 overflow-y-auto max-h-[calc(90vh-8rem)]">
              <div className="space-y-6">
                {/* Informaci√≥n b√°sica */}
                <div>
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    Informaci√≥n B√°sica
                  </h3>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Nombre *
                      </label>
                      <input
                        type="text"
                        value={formData.name}
                        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                      />
                      {formErrors.name && (
                        <p className="mt-1 text-sm text-red-600">{formErrors.name}</p>
                      )}
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Tipo *
                      </label>
                      <select
                        value={formData.type}
                        onChange={(e) => setFormData({ ...formData, type: e.target.value })}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                      >
                        <option value="CINEMA">Cine</option>
                        <option value="STREAMING">Streaming</option>
                        <option value="TV_CHANNEL">Canal de TV</option>
                        <option value="OTHER">Otro</option>
                      </select>
                      {formErrors.type && (
                        <p className="mt-1 text-sm text-red-600">{formErrors.type}</p>
                      )}
                    </div>
                  </div>

                  <div className="mt-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Descripci√≥n
                    </label>
                    <textarea
                      value={formData.description}
                      onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                      rows={3}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    />
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        URL del Logo
                      </label>
                      <input
                        type="url"
                        value={formData.logoUrl}
                        onChange={(e) => setFormData({ ...formData, logoUrl: e.target.value })}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                      />
                      {formErrors.logoUrl && (
                        <p className="mt-1 text-sm text-red-600">{formErrors.logoUrl}</p>
                      )}
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Sitio Web
                      </label>
                      <input
                        type="url"
                        value={formData.website}
                        onChange={(e) => setFormData({ ...formData, website: e.target.value })}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                      />
                      {formErrors.website && (
                        <p className="mt-1 text-sm text-red-600">{formErrors.website}</p>
                      )}
                    </div>
                  </div>
                </div>

                {/* Ubicaci√≥n (solo para cines) */}
                {formData.type === 'CINEMA' && (
                  <div>
                    <h3 className="text-lg font-medium text-gray-900 mb-4">
                      Ubicaci√≥n
                    </h3>
                    
                    <div className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Direcci√≥n
                        </label>
                        <input
                          type="text"
                          value={formData.address}
                          onChange={(e) => setFormData({ ...formData, address: e.target.value })}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                        />
                      </div>

                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Ciudad
                          </label>
                          <input
                            type="text"
                            value={formData.city}
                            onChange={(e) => setFormData({ ...formData, city: e.target.value })}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Provincia
                          </label>
                          <input
                            type="text"
                            value={formData.province}
                            onChange={(e) => setFormData({ ...formData, province: e.target.value })}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Pa√≠s
                          </label>
                          <input
                            type="text"
                            value={formData.country}
                            onChange={(e) => setFormData({ ...formData, country: e.target.value })}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                          />
                        </div>
                      </div>

                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Latitud
                          </label>
                          <input
                            type="number"
                            step="0.000001"
                            value={formData.latitude}
                            onChange={(e) => setFormData({ ...formData, latitude: e.target.value })}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Longitud
                          </label>
                          <input
                            type="number"
                            step="0.000001"
                            value={formData.longitude}
                            onChange={(e) => setFormData({ ...formData, longitude: e.target.value })}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                          />
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Estado */}
                <div>
                  <label className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={formData.isActive}
                      onChange={(e) => setFormData({ ...formData, isActive: e.target.checked })}
                      className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2"
                    />
                    <span className="text-sm font-medium text-gray-700">
                      Pantalla activa
                    </span>
                  </label>
                </div>
              </div>

              {/* Botones */}
              <div className="mt-6 flex items-center justify-end gap-4 pt-4 border-t border-gray-200">
                <button
                  type="button"
                  onClick={() => {
                    setShowModal(false)
                    resetForm()
                    setEditingVenue(null)
                  }}
                  className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Cancelar
                </button>
                <button
                  onClick={handleSubmit}
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Guardando...
                    </>
                  ) : (
                    <>
                      <Save className="w-4 h-4" />
                      {editingVenue ? 'Actualizar' : 'Crear'} Pantalla
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/admin/stats/page.tsx
// ==================================================
// src/app/admin/stats/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { ArrowUpDown, BarChart3, Film, Users, RefreshCw } from 'lucide-react'

export const dynamic = 'force-dynamic'

interface MovieStat {
  movieId: number
  title: string
  slug: string
  viewsWeek: number
  viewsMonth: number
  viewsYear: number
  viewsTotal: number
}

interface PersonStat {
  personId: number
  name: string
  slug: string
  views: number
}

interface Stats {
  totalViews: number
  viewsByType: { pageType: string; views: number }[]
  topMovies: MovieStat[]
  topPeople: PersonStat[]
  lastUpdated: string | null
}

type SortField = 'viewsWeek' | 'viewsMonth' | 'viewsYear' | 'viewsTotal' | 'title'
type SortOrder = 'asc' | 'desc'

export default function StatsPage() {
  const [stats, setStats] = useState<Stats | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [sortField, setSortField] = useState<SortField>('viewsMonth')
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc')

  const fetchStats = async () => {
    setLoading(true)
    setError(null)
    try {
      const response = await fetch('/api/admin/stats')
      if (!response.ok) throw new Error('Error al cargar estad√≠sticas')
      const data = await response.json()
      setStats(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error desconocido')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchStats()
  }, [])

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortOrder('desc')
    }
  }

  const sortedMovies = stats?.topMovies?.slice().sort((a, b) => {
    if (sortField === 'title') {
      return sortOrder === 'asc' 
        ? a.title.localeCompare(b.title)
        : b.title.localeCompare(a.title)
    }
    const aVal = a[sortField] || 0
    const bVal = b[sortField] || 0
    return sortOrder === 'asc' ? aVal - bVal : bVal - aVal
  }) || []

  const SortHeader = ({ field, label }: { field: SortField; label: string }) => (
    <th
      className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
      onClick={() => handleSort(field)}
    >
      <div className="flex items-center gap-1">
        {label}
        <ArrowUpDown className={`w-4 h-4 ${sortField === field ? 'text-blue-600' : 'text-gray-400'}`} />
      </div>
    </th>
  )

  const getPageTypeLabel = (pageType: string) => {
    const labels: Record<string, string> = {
      'MOVIE': 'Pel√≠culas',
      'PERSON': 'Personas',
      'HOME': 'Home',
      'RELEASES': 'Estrenos',
      'EPHEMERIS': 'Efem√©rides',
      'OBITUARIES': 'Obituarios',
      'PERSON_LIST': 'Listado personas'
    }
    return labels[pageType] || pageType
  }

  if (loading) {
    return (
      <div className="p-8">
        <h1 className="text-3xl font-bold mb-6">Estad√≠sticas</h1>
        <div className="flex items-center justify-center h-64">
          <RefreshCw className="w-8 h-8 animate-spin text-gray-400" />
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="p-8">
        <h1 className="text-3xl font-bold mb-6">Estad√≠sticas</h1>
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <p className="text-red-600">{error}</p>
          <button
            onClick={fetchStats}
            className="mt-2 text-sm text-red-600 underline hover:no-underline"
          >
            Reintentar
          </button>
        </div>
      </div>
    )
  }

  return (
    <div className="p-8">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold">Estad√≠sticas</h1>
        <button
          onClick={fetchStats}
          className="flex items-center gap-2 px-4 py-2 bg-white hover:bg-gray-50 rounded-lg text-sm shadow"
        >
          <RefreshCw className="w-4 h-4" />
          Actualizar
        </button>
      </div>

      {/* Resumen general */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center gap-3">
            <BarChart3 className="w-8 h-8 text-blue-500" />
            <div>
              <p className="text-sm text-gray-600">Total visitas</p>
              <p className="text-2xl font-bold">{stats?.totalViews?.toLocaleString() || 0}</p>
            </div>
          </div>
        </div>
        
        {stats?.viewsByType?.map((type) => (
          <div key={type.pageType} className="bg-white rounded-lg shadow p-6">
            <div className="flex items-center gap-3">
              {type.pageType === 'MOVIE' ? (
                <Film className="w-8 h-8 text-green-500" />
              ) : type.pageType === 'PERSON' ? (
                <Users className="w-8 h-8 text-purple-500" />
              ) : (
                <BarChart3 className="w-8 h-8 text-gray-500" />
              )}
              <div>
                <p className="text-sm text-gray-600">{getPageTypeLabel(type.pageType)}</p>
                <p className="text-2xl font-bold">{type.views?.toLocaleString() || 0}</p>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* √öltima actualizaci√≥n */}
      {stats?.lastUpdated && (
        <p className="text-sm text-gray-600 mb-4">
          Estad√≠sticas actualizadas: {new Date(stats.lastUpdated).toLocaleString('es-AR')}
        </p>
      )}

      {/* Tabla de pel√≠culas */}
      <div className="bg-white rounded-lg shadow overflow-hidden mb-8">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-xl font-semibold flex items-center gap-2">
            <Film className="w-5 h-5" />
            Pel√≠culas m√°s vistas
          </h2>
        </div>
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-12">
                  #
                </th>
                <SortHeader field="title" label="Pel√≠cula" />
                <SortHeader field="viewsWeek" label="7 d√≠as" />
                <SortHeader field="viewsMonth" label="30 d√≠as" />
                <SortHeader field="viewsYear" label="365 d√≠as" />
                <SortHeader field="viewsTotal" label="Total" />
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {sortedMovies.map((movie, index) => (
                <tr key={movie.movieId} className="hover:bg-gray-50">
                  <td className="px-4 py-3 text-sm text-gray-500">
                    {index + 1}
                  </td>
                  <td className="px-4 py-3">
                    <a
                      href={`/pelicula/${movie.slug}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-600 hover:underline font-medium"
                    >
                      {movie.title}
                    </a>
                  </td>
                  <td className="px-4 py-3 text-sm">
                    {movie.viewsWeek?.toLocaleString() || 0}
                  </td>
                  <td className="px-4 py-3 text-sm">
                    {movie.viewsMonth?.toLocaleString() || 0}
                  </td>
                  <td className="px-4 py-3 text-sm">
                    {movie.viewsYear?.toLocaleString() || 0}
                  </td>
                  <td className="px-4 py-3 text-sm font-semibold">
                    {movie.viewsTotal?.toLocaleString() || 0}
                  </td>
                </tr>
              ))}
              {sortedMovies.length === 0 && (
                <tr>
                  <td colSpan={6} className="px-4 py-8 text-center text-gray-500">
                    No hay datos de estad√≠sticas todav√≠a
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>

      {/* Tabla de personas */}
      {stats?.topPeople && stats.topPeople.length > 0 && (
        <div className="bg-white rounded-lg shadow overflow-hidden">
          <div className="px-6 py-4 border-b border-gray-200">
            <h2 className="text-xl font-semibold flex items-center gap-2">
              <Users className="w-5 h-5" />
              Personas m√°s vistas (√∫ltimos 30 d√≠as)
            </h2>
          </div>
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-12">
                    #
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Persona
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Visitas
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {stats.topPeople.map((person, index) => (
                  <tr key={person.personId} className="hover:bg-gray-50">
                    <td className="px-4 py-3 text-sm text-gray-500">
                      {index + 1}
                    </td>
                    <td className="px-4 py-3">
                      <a
                        href={`/persona/${person.slug}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-600 hover:underline font-medium"
                      >
                        {person.name}
                      </a>
                    </td>
                    <td className="px-4 py-3 text-sm font-semibold">
                      {person.views?.toLocaleString() || 0}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/admin/themes/page.tsx
// ==================================================
// src/app/admin/themes/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import {
  Plus,
  Search,
  Edit,
  Trash2,
  Tag,
  X,
  Save,
  Loader2,
  Hash
} from 'lucide-react'
import { toast } from 'react-hot-toast'

// Schema de validaci√≥n
const themeFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().optional()
})

type ThemeFormData = z.infer<typeof themeFormSchema>

interface Theme {
  id: number
  slug: string
  name: string
  description?: string
  usageCount: number
  movieCount?: number
  createdAt: string
}

export default function AdminThemesPage() {
  const [themes, setThemes] = useState<Theme[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [sortBy, setSortBy] = useState('name')
  const [showModal, setShowModal] = useState(false)
  const [editingTheme, setEditingTheme] = useState<Theme | null>(null)
  const [deletingThemeId, setDeletingThemeId] = useState<number | null>(null)

  // Form
  const {
    register,
    handleSubmit,
    reset,
    setValue,
    formState: { errors, isSubmitting }
  } = useForm<ThemeFormData>({
    resolver: zodResolver(themeFormSchema)
  })

  // Cargar themes
  const fetchThemes = async () => {
    try {
      setLoading(true)
      const params = new URLSearchParams({
        search: searchTerm,
        sortBy: sortBy,
        sortOrder: sortBy === 'usageCount' ? 'desc' : 'asc'
      })

      const response = await fetch(`/api/themes?${params}`)
      if (!response.ok) throw new Error('Error al cargar los themes')

      const data = await response.json()
      setThemes(data || [])
    } catch (error) {
      toast.error('Error al cargar los themes')
      setThemes([])
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchThemes()
  }, [searchTerm, sortBy])

  // Crear o actualizar theme
  const onSubmit = async (data: ThemeFormData) => {
    try {
      const url = editingTheme
        ? `/api/themes/${editingTheme.id}`
        : '/api/themes'

      const method = editingTheme ? 'PUT' : 'POST'
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Error al guardar')
      }

      toast.success(editingTheme ? 'Theme actualizado' : 'Theme creado')
      setShowModal(false)
      reset()
      setEditingTheme(null)
      fetchThemes()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Error al guardar')
    }
  }

  // Editar theme
  const handleEdit = (theme: Theme) => {
    setEditingTheme(theme)
    setValue('name', theme.name)
    setValue('description', theme.description || '')
    setShowModal(true)
  }

  // Eliminar theme
  const handleDelete = async (id: number) => {
    if (!confirm('¬øEst√°s seguro de eliminar este theme?')) return

    try {
      setDeletingThemeId(id)
      const response = await fetch(`/api/themes/${id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Error al eliminar')
      }

      toast.success('Theme eliminado')
      fetchThemes()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Error al eliminar')
    } finally {
      setDeletingThemeId(null)
    }
  }

  // Abrir modal para nuevo theme
  const handleNewTheme = () => {
    setEditingTheme(null)
    reset()
    setShowModal(true)
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Administraci√≥n de Themes/Keywords
            </h1>
            <p className="mt-2 text-gray-600">
              Gestiona los temas y palabras clave para categorizar las pel√≠culas
            </p>
          </div>
        </div>
      </div>

      {/* Contenido principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Filtros y acciones */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* B√∫squeda */}
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                type="text"
                placeholder="Buscar themes..."
                className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>

            {/* Ordenar por */}
            <select
              className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
            >
              <option value="name">Nombre</option>
              <option value="usageCount">M√°s usadas</option>
              <option value="createdAt">M√°s recientes</option>
            </select>

            {/* Bot√≥n nuevo theme */}
            <button
              onClick={handleNewTheme}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
            >
              <Plus className="w-5 h-5" />
              Nuevo Theme
            </button>
          </div>

          {/* Estad√≠sticas */}
          <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="bg-gray-50 rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-500">Total Themes</p>
                  <p className="text-2xl font-bold text-gray-900">{themes.length}</p>
                </div>
                <Tag className="w-8 h-8 text-gray-400" />
              </div>
            </div>
            <div className="bg-gray-50 rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-500">Total Asignaciones</p>
                  <p className="text-2xl font-bold text-gray-900">
                    {themes.reduce((sum, t) => sum + (t.movieCount || 0), 0)}
                  </p>
                </div>
                <Hash className="w-8 h-8 text-gray-400" />
              </div>
            </div>
          </div>
        </div>

        {/* Lista de themes */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          {loading ? (
            <div className="flex items-center justify-center h-64">
              <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
            </div>
          ) : themes.length === 0 ? (
            <div className="text-center py-12">
              <Tag className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-gray-500">No se encontraron themes</p>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Theme
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Descripci√≥n
                    </th>
                    <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Pel√≠culas
                    </th>
                    <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {themes.map((theme) => (
                    <tr key={theme.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <Tag className="w-5 h-5 text-gray-400 mr-3" />
                          <div>
                            <div className="text-sm font-medium text-gray-900">
                              {theme.name}
                            </div>
                            <div className="text-sm text-gray-500">
                              /{theme.slug}
                            </div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4">
                        <p className="text-sm text-gray-500 line-clamp-2">
                          {theme.description || '-'}
                        </p>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-center">
                        <span className="text-sm font-medium text-gray-900">
                          {theme.movieCount || 0}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex items-center justify-end gap-2">
                          <button
                            onClick={() => handleEdit(theme)}
                            className="text-blue-600 hover:text-blue-900 transition-colors"
                            title="Editar"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDelete(theme.id)}
                            disabled={deletingThemeId === theme.id || (theme.movieCount || 0) > 0}
                            className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            title={theme.movieCount ? `En uso en ${theme.movieCount} pel√≠culas` : 'Eliminar'}
                          >
                            {deletingThemeId === theme.id ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>

      {/* Modal de creaci√≥n/edici√≥n */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full p-6">
            <div className="mb-4">
              <h2 className="text-xl font-semibold text-gray-900">
                {editingTheme ? 'Editar Theme' : 'Nuevo Theme'}
              </h2>
            </div>

            <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Nombre *
                </label>
                <input
                  type="text"
                  {...register('name')}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                  placeholder="Ej: Basada en hechos reales"
                />
                {errors.name && (
                  <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Descripci√≥n
                </label>
                <textarea
                  {...register('description')}
                  rows={3}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                  placeholder="Descripci√≥n opcional del theme"
                />
              </div>

              <div className="flex items-center justify-end gap-3 pt-4">
                <button
                  type="button"
                  onClick={() => {
                    setShowModal(false)
                    reset()
                    setEditingTheme(null)
                  }}
                  className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Cancelar
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Guardando...
                    </>
                  ) : (
                    <>
                      <Save className="w-4 h-4" />
                      {editingTheme ? 'Actualizar' : 'Crear'} Theme
                    </>
                  )}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/app/api/admin/stats/route.ts
// ==================================================
// src/app/api/admin/stats/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

export async function GET() {
  try {
    // Total de visitas
    const totalViews = await prisma.pageView.count()

    // Visitas por tipo
    const viewsByType = await prisma.pageView.groupBy({
      by: ['pageType'],
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } }
    })

    // Pel√≠culas m√°s vistas (desde movie_stats)
    const movieStats = await prisma.movieStats.findMany({
      orderBy: { viewsMonth: 'desc' },
      take: 50,
      include: {
        movie: {
          select: {
            id: true,
            title: true,
            slug: true
          }
        }
      }
    })

    // Personas m√°s vistas (√∫ltimos 30 d√≠as desde page_views)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    const topPeopleRaw = await prisma.pageView.groupBy({
      by: ['personId'],
      where: {
        pageType: 'PERSON',
        personId: { not: null },
        createdAt: { gte: thirtyDaysAgo }
      },
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } },
      take: 20
    })

    // Obtener datos de personas
    const personIds = topPeopleRaw
      .map(p => p.personId)
      .filter((id): id is number => id !== null)

    const people = await prisma.person.findMany({
      where: { id: { in: personIds } },
      select: { id: true, firstName: true, lastName: true, slug: true }
    })

    const peopleMap = new Map(people.map(p => [p.id, p]))

    const topPeople = topPeopleRaw.map(p => {
      const person = p.personId ? peopleMap.get(p.personId) : null
      return {
        personId: p.personId,
        name: person ? `${person.firstName || ''} ${person.lastName || ''}`.trim() : 'Desconocido',
        slug: person?.slug || '',
        views: p._count.id
      }
    })

    // √öltima actualizaci√≥n de movie_stats
    const lastUpdate = await prisma.movieStats.findFirst({
      orderBy: { updatedAt: 'desc' },
      select: { updatedAt: true }
    })

    return NextResponse.json({
      totalViews,
      viewsByType: viewsByType.map(v => ({
        pageType: v.pageType,
        views: v._count.id
      })),
      topMovies: movieStats.map(s => ({
        movieId: s.movieId,
        title: s.movie.title,
        slug: s.movie.slug,
        viewsWeek: s.viewsWeek,
        viewsMonth: s.viewsMonth,
        viewsYear: s.viewsYear,
        viewsTotal: s.viewsTotal
      })),
      topPeople,
      lastUpdated: lastUpdate?.updatedAt || null
    })
  } catch (error) {
    console.error('Error fetching admin stats:', error)
    return NextResponse.json(
      { error: 'Error al obtener estad√≠sticas' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/analytics/pageview/route.ts
// ==================================================
// src/app/api/analytics/pageview/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import crypto from 'crypto';

// Tipos v√°lidos de p√°gina
const VALID_PAGE_TYPES = [
  'HOME',
  'MOVIE',
  'PERSON',
  'EPHEMERIS',
  'PERSON_LIST',
  'RELEASES',
  'OBITUARIES'
] as const;

type PageType = typeof VALID_PAGE_TYPES[number];

interface PageViewRequest {
  pageType: PageType;
  movieId?: number;
  personId?: number;
  extraData?: Record<string, any>;
  sessionId?: string;
}

// Funci√≥n para hashear IP (privacidad)
function hashIP(ip: string): string {
  // Agregar salt para mayor seguridad
  const salt = process.env.IP_HASH_SALT || 'cinenacional-analytics-2024';
  return crypto.createHash('sha256').update(ip + salt).digest('hex');
}

// IPs excluidas del tracking
function isExcludedIP(ip: string): boolean {
  const excludedIPs = process.env.ANALYTICS_EXCLUDED_IPS?.split(',') || [];
  return excludedIPs.some(excluded => excluded.trim() === ip);
}

// Funci√≥n para extraer IP del request
function getClientIP(request: NextRequest): string {
  // Orden de prioridad para obtener IP real
  const forwardedFor = request.headers.get('x-forwarded-for');
  if (forwardedFor) {
    // x-forwarded-for puede tener m√∫ltiples IPs, tomar la primera
    return forwardedFor.split(',')[0].trim();
  }
  
  const realIP = request.headers.get('x-real-ip');
  if (realIP) {
    return realIP;
  }
  
  // Fallback
  return '0.0.0.0';
}

export async function POST(request: NextRequest) {
  try {
    const body: PageViewRequest = await request.json();
    
    // Validar pageType
    if (!body.pageType || !VALID_PAGE_TYPES.includes(body.pageType)) {
      return NextResponse.json(
        { error: 'pageType inv√°lido' },
        { status: 400 }
      );
    }
    
    // Validar que MOVIE tenga movieId
    if (body.pageType === 'MOVIE' && !body.movieId) {
      return NextResponse.json(
        { error: 'movieId requerido para pageType MOVIE' },
        { status: 400 }
      );
    }
    
    // Validar que PERSON tenga personId
    if (body.pageType === 'PERSON' && !body.personId) {
      return NextResponse.json(
        { error: 'personId requerido para pageType PERSON' },
        { status: 400 }
      );
    }
    
    // Obtener datos del request
    const clientIP = getClientIP(request);
    const userAgent = request.headers.get('user-agent') || null;
    const referrer = request.headers.get('referer') || null;

    // Ignorar IPs excluidas
    if (isExcludedIP(clientIP)) {
      return NextResponse.json({ success: true, skipped: true });
    }
    
    // Crear registro de pageview
    const pageView = await prisma.pageView.create({
      data: {
        pageType: body.pageType,
        movieId: body.movieId || null,
        personId: body.personId || null,
        extraData: body.extraData || null,
        sessionId: body.sessionId || null,
        ipHash: hashIP(clientIP),
        userAgent: userAgent?.substring(0, 500), // Truncar si es muy largo
        referrer: referrer?.substring(0, 500),
      },
    });
    
    // Responder inmediatamente (no bloquear al cliente)
    return NextResponse.json({ success: true, id: pageView.id });
    
  } catch (error) {
    console.error('Error registrando pageview:', error);
    
    // No exponer errores internos al cliente
    return NextResponse.json(
      { error: 'Error interno' },
      { status: 500 }
    );
  }
}

// Endpoint para obtener estad√≠sticas b√°sicas (opcional, para admin)
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const pageType = searchParams.get('pageType');
    const days = parseInt(searchParams.get('days') || '30');
    
    const dateFrom = new Date();
    dateFrom.setDate(dateFrom.getDate() - days);
    
    // Construir where clause
    const where: any = {
      createdAt: { gte: dateFrom }
    };
    
    if (pageType && VALID_PAGE_TYPES.includes(pageType as PageType)) {
      where.pageType = pageType;
    }
    
    // Obtener conteo total
    const totalViews = await prisma.pageView.count({ where });
    
    // Obtener conteo por tipo de p√°gina
    const viewsByType = await prisma.pageView.groupBy({
      by: ['pageType'],
      where: { createdAt: { gte: dateFrom } },
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } }
    });
    
    // Obtener pel√≠culas m√°s vistas
    const topMovies = await prisma.pageView.groupBy({
      by: ['movieId'],
      where: {
        pageType: 'MOVIE',
        movieId: { not: null },
        createdAt: { gte: dateFrom }
      },
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    });
    
    // Obtener nombres de pel√≠culas
    const movieIds = topMovies.map(m => m.movieId).filter(Boolean) as number[];
    const movies = await prisma.movie.findMany({
      where: { id: { in: movieIds } },
      select: { id: true, title: true, slug: true }
    });
    
    const topMoviesWithNames = topMovies.map(m => {
      const movie = movies.find(mov => mov.id === m.movieId);
      return {
        movieId: m.movieId,
        title: movie?.title || 'Desconocida',
        slug: movie?.slug,
        views: m._count.id
      };
    });
    
    // Obtener personas m√°s vistas
    const topPeople = await prisma.pageView.groupBy({
      by: ['personId'],
      where: {
        pageType: 'PERSON',
        personId: { not: null },
        createdAt: { gte: dateFrom }
      },
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    });
    
    // Obtener nombres de personas
    const personIds = topPeople.map(p => p.personId).filter(Boolean) as number[];
    const people = await prisma.person.findMany({
      where: { id: { in: personIds } },
      select: { id: true, firstName: true, lastName: true, slug: true }
    });
    
    const topPeopleWithNames = topPeople.map(p => {
      const person = people.find(per => per.id === p.personId);
      const name = person 
        ? [person.firstName, person.lastName].filter(Boolean).join(' ')
        : 'Desconocido';
      return {
        personId: p.personId,
        name,
        slug: person?.slug,
        views: p._count.id
      };
    });
    
    return NextResponse.json({
      period: `${days} d√≠as`,
      totalViews,
      viewsByType: viewsByType.map(v => ({
        pageType: v.pageType,
        views: v._count.id
      })),
      topMovies: topMoviesWithNames,
      topPeople: topPeopleWithNames
    });
    
  } catch (error) {
    console.error('Error obteniendo estad√≠sticas:', error);
    return NextResponse.json(
      { error: 'Error interno' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/auth/[...nextauth]/route.ts
// ==================================================
// src/app/api/auth/[...nextauth]/route.ts

import NextAuth from "next-auth"
import CredentialsProvider from "next-auth/providers/credentials"
import { PrismaAdapter } from "@next-auth/prisma-adapter"
import { prismaBase } from "@/lib/prisma"
import bcrypt from "bcryptjs"
import { z } from "zod"

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6)
})

const handler = NextAuth({
  adapter: PrismaAdapter(prismaBase),
  session: {
    strategy: "jwt",
    maxAge: 24 * 60 * 60, // 24 horas
  },
  pages: {
    signIn: "/admin/login",  // P√°gina de login dentro de /admin
    error: "/admin/login",
  },
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        try {
          const { email, password } = loginSchema.parse(credentials)
          
          const user = await prismaBase.user.findUnique({
            where: { email }
          })
          
          if (!user || !user.isActive) {
            return null
          }
          
          // Verificar password
          const isValid = await bcrypt.compare(password, user.password)
          
          if (!isValid) {
            return null
          }
          
          // Verificar que tenga permisos de admin
          if (user.role !== 'ADMIN' && user.role !== 'EDITOR' && !user.isAdmin) {
            return null
          }
          
          // Actualizar √∫ltimo login
          await prismaBase.user.update({
            where: { id: user.id },
            data: { lastLogin: new Date() }
          })
          
          // Log de auditor√≠a
          await prismaBase.auditLog.create({
            data: {
              userId: user.id,
              action: 'LOGIN',
              entity: 'auth',
              metadata: {
                timestamp: new Date().toISOString()
              }
            }
          })
          
          return {
            id: user.id,
            email: user.email,
            name: user.displayName || user.username || user.email,
            role: user.role,
            image: user.avatarUrl
          }
        } catch (error) {
          console.error('Auth error:', error)
          return null
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.role = user.role
        token.id = user.id
      }
      return token
    },
    async session({ session, token }) {
      if (session?.user) {
        session.user.role = token.role as string
        session.user.id = token.id as string
      }
      return session
    }
  },
  secret: process.env.NEXTAUTH_SECRET,
})

export { handler as GET, handler as POST }

// ==================================================
// src/app/api/calificaciones/route.ts
// ==================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/calificaciones - Listar todas las calificaciones
export async function GET() {
  try {
    const ratings = await prisma.rating.findMany({
      orderBy: { name: 'asc' },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })

    return NextResponse.json(ratings)
  } catch (error) {
    console.error('Error fetching ratings:', error)
    return NextResponse.json(
      { error: 'Error al obtener las calificaciones' },
      { status: 500 }
    )
  }
}

// POST /api/calificaciones - Crear nueva calificaci√≥n
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validar datos requeridos
    if (!body.name || !body.name.trim()) {
      return NextResponse.json(
        { error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    // Generar slug √∫nico
    let slug = createSlug(body.name)
    let slugExists = await prisma.rating.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(body.name)}-${counter}`
      slugExists = await prisma.rating.findUnique({ where: { slug } })
      counter++
    }

    const rating = await prisma.rating.create({
      data: {
        name: body.name.trim(),
        abbreviation: body.abbreviation?.trim() || null,
        description: body.description?.trim() || null,
        slug
      }
    })

    return NextResponse.json(rating, { status: 201 })
  } catch (error) {
    console.error('Error creating rating:', error)
    return NextResponse.json(
      { error: 'Error al crear la calificaci√≥n' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/calificaciones/[id]/route.ts
// ==================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

// GET /api/calificaciones/[id] - Obtener una calificaci√≥n por ID
/**
 * GET
 * @TODO Add documentation
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    const rating = await prisma.rating.findUnique({
      where: { id },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    if (!rating) {
      return NextResponse.json(
        { error: 'Calificaci√≥n no encontrada' },
        { status: 404 }
      )
    }

    return NextResponse.json(rating)
  } catch (error) {
    console.error('Error fetching rating:', error)
    return NextResponse.json(
      { error: 'Error al obtener la calificaci√≥n' },
      { status: 500 }
    )
  }
}

// PUT /api/calificaciones/[id] - Actualizar calificaci√≥n
/**
 * PUT
 * @TODO Add documentation
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    
    // Validar datos requeridos
    if (!body.name || !body.name.trim()) {
      return NextResponse.json(
        { error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    // Verificar que la calificaci√≥n existe
    const existingRating = await prisma.rating.findUnique({
      where: { id }
    })
    
    if (!existingRating) {
      return NextResponse.json(
        { error: 'Calificaci√≥n no encontrada' },
        { status: 404 }
      )
    }

    const rating = await prisma.rating.update({
      where: { id },
      data: {
        name: body.name.trim(),
        abbreviation: body.abbreviation?.trim() || null,
        description: body.description?.trim() || null
      }
    })

    return NextResponse.json(rating)
  } catch (error) {
    console.error('Error updating rating:', error)
    return NextResponse.json(
      { error: 'Error al actualizar la calificaci√≥n' },
      { status: 500 }
    )
  }
}

// DELETE /api/calificaciones/[id] - Eliminar calificaci√≥n
/**
 * DELETE
 * @TODO Add documentation
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    // Verificar que la calificaci√≥n existe
    const rating = await prisma.rating.findUnique({
      where: { id },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    if (!rating) {
      return NextResponse.json(
        { error: 'Calificaci√≥n no encontrada' },
        { status: 404 }
      )
    }

    // Verificar si tiene pel√≠culas asociadas
    if (rating._count.movies > 0) {
      return NextResponse.json(
        { error: 'No se puede eliminar una calificaci√≥n que tiene pel√≠culas asociadas' },
        { status: 400 }
      )
    }

    // Eliminar calificaci√≥n
    await prisma.rating.delete({
      where: { id }
    })

    return NextResponse.json(
      { message: 'Calificaci√≥n eliminada exitosamente' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting rating:', error)
    return NextResponse.json(
      { error: 'Error al eliminar la calificaci√≥n' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/color-types/route.ts
// ==================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

// GET /api/color-types - Listar todos los tipos de color
export async function GET() {
  try {
    const colorTypes = await prisma.colorType.findMany({
      orderBy: { displayOrder: 'asc' }
    })

    return NextResponse.json(colorTypes)
  } catch (error) {
    console.error('Error fetching color types:', error)
    return NextResponse.json(
      { error: 'Error al obtener los tipos de color' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/companies/distribution/route.ts
// ==================================================
// =====================================================
// src/app/api/companies/distribution/route.ts
// =====================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/companies/distribution - Listar distribuidoras
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const search = searchParams.get('search') || ''

    const where = search ? {
      name: { contains: search, mode: 'insensitive' as const }
    } : {}

    const companies = await prisma.distributionCompany.findMany({
      where,
      orderBy: { name: 'asc' }
    })

    return NextResponse.json(companies)
  } catch (error) {
    console.error('Error fetching distribution companies:', error)
    return NextResponse.json(
      { error: 'Error al obtener las distribuidoras' },
      { status: 500 }
    )
  }
}

// POST /api/companies/distribution - Crear nueva distribuidora
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    let slug = createSlug(body.name)
    let slugExists = await prisma.distributionCompany.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(body.name)}-${counter}`
      slugExists = await prisma.distributionCompany.findUnique({ where: { slug } })
      counter++
    }

    const company = await prisma.distributionCompany.create({
      data: {
        ...body,
        slug
      }
    })

    return NextResponse.json(company, { status: 201 })
  } catch (error) {
    console.error('Error creating distribution company:', error)
    return NextResponse.json(
      { error: 'Error al crear la distribuidora' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/companies/production/route.ts
// ==================================================
// =====================================================
// src/app/api/companies/production/route.ts
// =====================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/companies/production - Listar productoras
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const search = searchParams.get('search') || ''

    const where = search ? {
      name: { contains: search, mode: 'insensitive' as const }
    } : {}

    const companies = await prisma.productionCompany.findMany({
      where,
      orderBy: { name: 'asc' }
    })

    return NextResponse.json(companies)
  } catch (error) {
    console.error('Error fetching production companies:', error)
    return NextResponse.json(
      { error: 'Error al obtener las productoras' },
      { status: 500 }
    )
  }
}

// POST /api/companies/production - Crear nueva productora
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    let slug = createSlug(body.name)
    let slugExists = await prisma.productionCompany.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(body.name)}-${counter}`
      slugExists = await prisma.productionCompany.findUnique({ where: { slug } })
      counter++
    }

    const company = await prisma.productionCompany.create({
      data: {
        ...body,
        slug
      }
    })

    return NextResponse.json(company, { status: 201 })
  } catch (error) {
    console.error('Error creating production company:', error)
    return NextResponse.json(
      { error: 'Error al crear la productora' },
      { status: 500 }
    )
  }
}


// ==================================================
// src/app/api/efemerides/route.ts
// ==================================================
// src/app/api/efemerides/route.ts - ACTUALIZADO CON SOPORTE PARA M√öLTIPLES DIRECTORES

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { calcularAniosDesde, formatearEfemeride } from '@/lib/utils/efemerides';
import { Efemeride, DirectorInfo } from '@/types/home.types';
import RedisClient from '@/lib/redis';

export const dynamic = 'force-dynamic';

// ============================================
// CACHE CONFIGURATION
// ============================================

const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 horas
const REDIS_TTL = 86400; // 24 horas

function generateCacheKey(dia: number, mes: number, randomSample?: boolean): string {
  const suffix = randomSample ? ':random' : ':all';
  return `efemerides:${mes}-${dia}${suffix}:v3`; // v3 por el cambio de directores
}

/**
 * Procesa el array de crew y extrae los directores como DirectorInfo[]
 */
function extractDirectors(crew: Array<{ person: { slug: string; firstName: string | null; lastName: string | null } }>): DirectorInfo[] {
  return crew.map(c => ({
    name: `${c.person.firstName || ''} ${c.person.lastName || ''}`.trim(),
    slug: c.person.slug
  })).filter(d => d.name); // Filtrar directores sin nombre
}

// ============================================
// GET /api/efemerides
// ============================================
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    
    // Obtener par√°metros - si no se especifican, usar fecha actual
    const hoy = new Date();
    const dia = parseInt(searchParams.get('day') || searchParams.get('dia') || hoy.getDate().toString());
    const mes = parseInt(searchParams.get('month') || searchParams.get('mes') || (hoy.getMonth() + 1).toString());
    
    // Par√°metro para indicar si queremos muestra aleatoria (para la home)
    const randomSample = searchParams.get('random') === 'true';
    
    // Validar par√°metros
    if (mes < 1 || mes > 12) {
      return NextResponse.json(
        { error: 'Mes inv√°lido (debe ser entre 1 y 12)' },
        { status: 400 }
      );
    }
    
    if (dia < 1 || dia > 31) {
      return NextResponse.json(
        { error: 'D√≠a inv√°lido (debe ser entre 1 y 31)' },
        { status: 400 }
      );
    }

    // ============================================
    // 1. INTENTAR REDIS CACHE
    // ============================================
    const cacheKey = generateCacheKey(dia, mes, randomSample);
    const now = Date.now();
    
    try {
      const redisCached = await RedisClient.get(cacheKey);
      
      if (redisCached) {
        console.log(`‚úÖ Cache HIT desde Redis para efem√©rides: ${mes}/${dia}`);
        return NextResponse.json(
          JSON.parse(redisCached),
          {
            headers: {
              'Cache-Control': `public, s-maxage=${REDIS_TTL}, stale-while-revalidate=${REDIS_TTL * 2}`,
              'X-Cache': 'HIT',
              'X-Cache-Source': 'redis'
            }
          }
        );
      }
    } catch (redisError) {
      console.error('Redis error (non-fatal):', redisError);
    }

    // ============================================
    // 2. INTENTAR MEMORY CACHE
    // ============================================
    const memoryCached = memoryCache.get(cacheKey);
    
    if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
      console.log(`‚úÖ Cache HIT desde memoria para efem√©rides: ${mes}/${dia}`);
      
      RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), REDIS_TTL)
        .catch(err => console.error('Error guardando en Redis:', err));
      
      return NextResponse.json(memoryCached.data, {
        headers: {
          'Cache-Control': `public, s-maxage=${REDIS_TTL}, stale-while-revalidate=${REDIS_TTL * 2}`,
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory'
        }
      });
    }

    // ============================================
    // 3. CONSULTAR BASE DE DATOS
    // ============================================
    console.log(`üîÑ Cache MISS - Consultando BD para efem√©rides: ${mes}/${dia}`);
    
    // Obtener pel√≠culas con fechas de estreno para esta fecha
    const peliculasEstreno = await prisma.movie.findMany({
      where: {
        releaseDay: dia,
        releaseMonth: mes,
        releaseYear: { not: null }
      },
      select: {
        id: true,
        slug: true,
        title: true,
        releaseYear: true,
        releaseMonth: true,
        releaseDay: true,
        posterUrl: true,
        crew: {
          where: {
            roleId: 2 // Director
          },
          select: {
            person: {
              select: {
                slug: true,
                firstName: true,
                lastName: true
              }
            }
          }
          // SIN take: 1 - obtener TODOS los directores
        }
      }
    });
    
    // Obtener pel√≠culas con inicio de rodaje
    const peliculasInicioRodaje = await prisma.movie.findMany({
      where: {
        filmingStartDay: dia,
        filmingStartMonth: mes,
        filmingStartYear: { not: null }
      },
      select: {
        id: true,
        slug: true,
        title: true,
        filmingStartYear: true,
        filmingStartMonth: true,
        filmingStartDay: true,
        posterUrl: true,
        crew: {
          where: {
            roleId: 2
          },
          select: {
            person: {
              select: {
                slug: true,
                firstName: true,
                lastName: true
              }
            }
          }
          // SIN take: 1 - obtener TODOS los directores
        }
      }
    });
    
    // Obtener pel√≠culas con fin de rodaje
    const peliculasFinRodaje = await prisma.movie.findMany({
      where: {
        filmingEndDay: dia,
        filmingEndMonth: mes,
        filmingEndYear: { not: null }
      },
      select: {
        id: true,
        slug: true,
        title: true,
        filmingEndYear: true,
        filmingEndMonth: true,
        filmingEndDay: true,
        posterUrl: true,
        crew: {
          where: {
            roleId: 2
          },
          select: {
            person: {
              select: {
                slug: true,
                firstName: true,
                lastName: true
              }
            }
          }
          // SIN take: 1 - obtener TODOS los directores
        }
      }
    });
    
    // Obtener personas nacidas en esta fecha
    const personasNacimiento = await prisma.person.findMany({
      where: {
        birthDay: dia,
        birthMonth: mes,
        birthYear: { not: null }
      },
      select: {
        id: true,
        slug: true,
        firstName: true,
        lastName: true,
        birthYear: true,
        birthMonth: true,
        birthDay: true,
        photoUrl: true
      }
    });
    
    // Obtener personas fallecidas en esta fecha
    const personasMuerte = await prisma.person.findMany({
      where: {
        deathDay: dia,
        deathMonth: mes,
        deathYear: { not: null }
      },
      select: {
        id: true,
        slug: true,
        firstName: true,
        lastName: true,
        deathYear: true,
        deathMonth: true,
        deathDay: true,
        photoUrl: true
      }
    });
    
    // ============================================
    // 4. FORMATEAR EFEM√âRIDES
    // ============================================
    const efemerides: (Efemeride | null)[] = [];
    
    // Procesar estrenos
    peliculasEstreno.forEach(pelicula => {
      const directors = extractDirectors(pelicula.crew);
      const efemeride = formatearEfemeride({
        tipo: 'pelicula',
        tipoEvento: 'estreno',
        a√±o: pelicula.releaseYear!,
        mes: pelicula.releaseMonth!,
        dia: pelicula.releaseDay!,
        fecha: new Date(pelicula.releaseYear!, pelicula.releaseMonth! - 1, pelicula.releaseDay!),
        titulo: pelicula.title,
        directors: directors,
        directorSlug: directors[0]?.slug,
        slug: pelicula.slug,
        posterUrl: pelicula.posterUrl || undefined
      });
      if (efemeride) efemerides.push(efemeride);
    });
    
    // Procesar inicio de rodajes
    peliculasInicioRodaje.forEach(pelicula => {
      const directors = extractDirectors(pelicula.crew);
      const efemeride = formatearEfemeride({
        tipo: 'pelicula',
        tipoEvento: 'inicio_rodaje',
        a√±o: pelicula.filmingStartYear!,
        mes: pelicula.filmingStartMonth!,
        dia: pelicula.filmingStartDay!,
        fecha: new Date(pelicula.filmingStartYear!, pelicula.filmingStartMonth! - 1, pelicula.filmingStartDay!),
        titulo: pelicula.title,
        directors: directors,
        directorSlug: directors[0]?.slug,
        slug: pelicula.slug,
        posterUrl: pelicula.posterUrl || undefined
      });
      if (efemeride) efemerides.push(efemeride);
    });
    
    // Procesar fin de rodajes
    peliculasFinRodaje.forEach(pelicula => {
      const directors = extractDirectors(pelicula.crew);
      const efemeride = formatearEfemeride({
        tipo: 'pelicula',
        tipoEvento: 'fin_rodaje',
        a√±o: pelicula.filmingEndYear!,
        mes: pelicula.filmingEndMonth!,
        dia: pelicula.filmingEndDay!,
        fecha: new Date(pelicula.filmingEndYear!, pelicula.filmingEndMonth! - 1, pelicula.filmingEndDay!),
        titulo: pelicula.title,
        directors: directors,
        directorSlug: directors[0]?.slug,
        slug: pelicula.slug,
        posterUrl: pelicula.posterUrl || undefined
      });
      if (efemeride) efemerides.push(efemeride);
    });
    
    // Procesar nacimientos
    personasNacimiento.forEach(persona => {
      const nombre = `${persona.firstName || ''} ${persona.lastName || ''}`.trim();
      
      const efemeride = formatearEfemeride({
        tipo: 'persona',
        tipoEvento: 'nacimiento',
        a√±o: persona.birthYear!,
        mes: persona.birthMonth!,
        dia: persona.birthDay!,
        fecha: new Date(persona.birthYear!, persona.birthMonth! - 1, persona.birthDay!),
        nombre,
        slug: persona.slug,
        photoUrl: persona.photoUrl || undefined
      });
      if (efemeride) efemerides.push(efemeride);
    });
    
    // Procesar muertes
    personasMuerte.forEach(persona => {
      const nombre = `${persona.firstName || ''} ${persona.lastName || ''}`.trim();
      
      const efemeride = formatearEfemeride({
        tipo: 'persona',
        tipoEvento: 'muerte',
        a√±o: persona.deathYear!,
        mes: persona.deathMonth!,
        dia: persona.deathDay!,
        fecha: new Date(persona.deathYear!, persona.deathMonth! - 1, persona.deathDay!),
        nombre,
        slug: persona.slug,
        photoUrl: persona.photoUrl || undefined
      });
      if (efemeride) efemerides.push(efemeride);
    });
    
    // Filtrar nulls y ordenar por a√±os (m√°s recientes primero)
    const efemeridesValidas = efemerides
      .filter((e): e is Efemeride => e !== null)
      .sort((a, b) => {
        const a√±osA = parseInt(a.hace.match(/\d+/)?.[0] || '0');
        const a√±osB = parseInt(b.hace.match(/\d+/)?.[0] || '0');
        return a√±osA - a√±osB; // Menos a√±os primero (m√°s reciente)
      });
    
    // ============================================
    // 5. APLICAR L√ìGICA DE MUESTRA ALEATORIA (PARA HOME)
    // ============================================
    let resultado: { efemerides: Efemeride[] };
    
    if (randomSample && efemeridesValidas.length === 0) {
      // Si no hay efem√©rides para hoy y se pidi√≥ muestra aleatoria, buscar ejemplos
      const peliculasEjemplo = await prisma.movie.findMany({
        where: {
          releaseDay: { not: null },
          releaseMonth: { not: null },
          releaseYear: { not: null }
        },
        select: {
          id: true,
          slug: true,
          title: true,
          releaseYear: true,
          releaseMonth: true,
          releaseDay: true,
          posterUrl: true,
          crew: {
            where: {
              roleId: 2
            },
            select: {
              person: {
                select: {
                  slug: true,
                  firstName: true,
                  lastName: true
                }
              }
            }
            // SIN take: 1
          }
        },
        take: 5
      });
      
      const efemeridesEjemplo = peliculasEjemplo.slice(0, 2).map(pelicula => {
        const directors = extractDirectors(pelicula.crew);
        const directorText = directors.length > 0
          ? directors.length === 1
            ? directors[0].name
            : directors.length === 2
              ? `${directors[0].name} y ${directors[1].name}`
              : `${directors.slice(0, -1).map(d => d.name).join(', ')} y ${directors[directors.length - 1].name}`
          : null;
        
        const a√±osDesde = new Date().getFullYear() - pelicula.releaseYear!;
        
        return {
          id: `ejemplo-${pelicula.id}`,
          tipo: 'pelicula' as const,
          hace: `Hace ${a√±osDesde} ${a√±osDesde === 1 ? 'a√±o' : 'a√±os'}`,
          evento: `se estrenaba "${pelicula.title}"${directorText ? `, de ${directorText}` : ''}`,
          fecha: new Date(pelicula.releaseYear!, pelicula.releaseMonth! - 1, pelicula.releaseDay!),
          slug: pelicula.slug,
          posterUrl: pelicula.posterUrl || undefined,
          directors: directors,
          director: directorText || undefined,
          directorSlug: directors[0]?.slug
        };
      });
      
      resultado = { efemerides: efemeridesEjemplo };
      
      // No cachear ejemplos aleatorios
      return NextResponse.json(resultado);
      
    } else if (randomSample && efemeridesValidas.length > 2) {
      // Si hay muchas efem√©rides y se pidi√≥ muestra, tomar 2 aleatorias
      const shuffled = [...efemeridesValidas].sort(() => Math.random() - 0.5);
      resultado = { efemerides: shuffled.slice(0, 2) };
      
      // No cachear muestras aleatorias
      return NextResponse.json(resultado);
      
    } else {
      // Devolver todas las efem√©rides (para p√°gina de efem√©rides)
      resultado = { efemerides: efemeridesValidas };
    }
    
    // ============================================
    // 6. GUARDAR EN CACH√â (solo si no es muestra aleatoria)
    // ============================================
    if (!randomSample) {
      RedisClient.set(cacheKey, JSON.stringify(resultado), REDIS_TTL)
        .then(saved => {
          if (saved) {
            console.log(`‚úÖ Efem√©rides guardadas en Redis con TTL ${REDIS_TTL}s (24h)`);
          }
        })
        .catch(err => console.error('Error guardando en Redis:', err));
      
      memoryCache.set(cacheKey, {
        data: resultado,
        timestamp: now
      });
      
      if (memoryCache.size > 365) {
        const oldestKey = memoryCache.keys().next().value;
        if (oldestKey) {
          memoryCache.delete(oldestKey);
        }
      }
    }
    
    return NextResponse.json(resultado, {
      headers: randomSample ? {} : {
        'Cache-Control': `public, s-maxage=${REDIS_TTL}, stale-while-revalidate=${REDIS_TTL * 2}`,
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database'
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching efem√©rides:', error);
    
    // Intentar servir desde cach√© stale si hay error
    const searchParams = request.nextUrl.searchParams;
    const hoy = new Date();
    const dia = parseInt(searchParams.get('day') || searchParams.get('dia') || hoy.getDate().toString());
    const mes = parseInt(searchParams.get('month') || searchParams.get('mes') || (hoy.getMonth() + 1).toString());
    const randomSample = searchParams.get('random') === 'true';
    
    const cacheKey = generateCacheKey(dia, mes, randomSample);
    const staleCache = memoryCache.get(cacheKey);
    
    if (staleCache) {
      console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
      return NextResponse.json(staleCache.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }
    
    return NextResponse.json(
      { error: 'Error al obtener efem√©rides' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/first-name-gender/route.ts
// ==================================================
// src/app/api/first-name-gender/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

/**
 * GET /api/first-name-gender?name=Juan
 * Busca un nombre en la tabla first_name_genders y devuelve su g√©nero
 */
export async function GET(request: NextRequest) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const name = searchParams.get('name');

        if (!name || name.trim().length === 0) {
            return NextResponse.json(
                { error: 'El par√°metro "name" es requerido' },
                { status: 400 }
            );
        }

        // Convierte todo a min√∫sculas: "Josefina" ‚Üí "josefina" ‚úÖ
        const normalizedName = name.trim().toLowerCase();

        const result = await prisma.firstNameGender.findUnique({
            where: { name: normalizedName }
        });

        if (!result) {
            return NextResponse.json({
                found: false,
                name: normalizedName,
                gender: null
            });
        }

        return NextResponse.json({
            found: true,
            name: result.name,
            gender: result.gender // MALE, FEMALE, o UNISEX
        });

    } catch (error) {
        console.error('Error buscando nombre en first_name_gender:', error);
        return NextResponse.json(
            { error: 'Error al buscar el nombre' },
            { status: 500 }
        );
    }
}

/**
 * POST /api/first-name-gender
 * Agrega o actualiza un nombre en la tabla first_name_genders
 * Body: { name: string, gender: 'MALE' | 'FEMALE' }
 * 
 * Solo se agregan nombres con g√©nero MALE o FEMALE.
 * Los UNISEX o desconocidos no se agregan autom√°ticamente.
 */
export async function POST(request: NextRequest) {
    try {
        const data = await request.json();
        const { name, gender } = data;

        if (!name || name.trim().length === 0) {
            return NextResponse.json(
                { error: 'El nombre es requerido' },
                { status: 400 }
            );
        }

        // Solo permitir MALE o FEMALE para agregar a la tabla
        if (!['MALE', 'FEMALE'].includes(gender)) {
            return NextResponse.json(
                { error: 'El g√©nero debe ser MALE o FEMALE para agregarlo a la base de datos' },
                { status: 400 }
            );
        }

        
        const normalizedName = name.trim().toLowerCase();

        // Usar upsert para crear o actualizar
        const result = await prisma.firstNameGender.upsert({
            where: { name: normalizedName },
            update: { gender: gender },
            create: {
                name: normalizedName,
                gender: gender
            }
        });

        console.log(`‚úÖ Nombre "${normalizedName}" guardado con g√©nero ${gender}`);

        return NextResponse.json({
            success: true,
            data: result
        }, { status: 201 });

    } catch (error) {
        console.error('Error guardando nombre en first_name_gender:', error);
        return NextResponse.json(
            { error: 'Error al guardar el nombre' },
            { status: 500 }
        );
    }
}

// ==================================================
// src/app/api/genres/route.ts
// ==================================================
// src/app/api/genres/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/genres - Listar todos los g√©neros con conteo de pel√≠culas
export async function GET() {
  try {
    const genres = await prisma.genre.findMany({
      orderBy: { name: 'asc' },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })

    return NextResponse.json(genres)
  } catch (error) {
    console.error('Error fetching genres:', error)
    return NextResponse.json(
      { error: 'Error al obtener los g√©neros' },
      { status: 500 }
    )
  }
}

// POST /api/genres - Crear nuevo g√©nero
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validar datos requeridos
    if (!body.name || body.name.trim() === '') {
      return NextResponse.json(
        { error: 'El nombre del g√©nero es requerido' },
        { status: 400 }
      )
    }

    // Generar slug √∫nico
    let slug = createSlug(body.name)
    let slugExists = await prisma.genre.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(body.name)}-${counter}`
      slugExists = await prisma.genre.findUnique({ where: { slug } })
      counter++
    }

    // Crear g√©nero
    const genre = await prisma.genre.create({
      data: {
        name: body.name.trim(),
        slug,
        description: body.description?.trim() || null
      },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })

    return NextResponse.json(genre, { status: 201 })
  } catch (error) {
    console.error('Error creating genre:', error)
    return NextResponse.json(
      { error: 'Error al crear el g√©nero' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/genres/[id]/route.ts
// ==================================================
// src/app/api/genres/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

// GET /api/genres/[id] - Obtener g√©nero por ID
/**
 * GET
 * @TODO Add documentation
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      )
    }
    
    const genre = await prisma.genre.findUnique({
      where: { id },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    if (!genre) {
      return NextResponse.json(
        { error: 'G√©nero no encontrado' },
        { status: 404 }
      )
    }
    
    return NextResponse.json(genre)
  } catch (error) {
    console.error('Error fetching genre:', error)
    return NextResponse.json(
      { error: 'Error al obtener el g√©nero' },
      { status: 500 }
    )
  }
}

// PUT /api/genres/[id] - Actualizar g√©nero
/**
 * PUT
 * @TODO Add documentation
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      )
    }
    
    // Validar datos requeridos
    if (!body.name || body.name.trim() === '') {
      return NextResponse.json(
        { error: 'El nombre del g√©nero es requerido' },
        { status: 400 }
      )
    }
    
    // Verificar que el g√©nero existe
    const existingGenre = await prisma.genre.findUnique({
      where: { id }
    })
    
    if (!existingGenre) {
      return NextResponse.json(
        { error: 'G√©nero no encontrado' },
        { status: 404 }
      )
    }
    
    // Actualizar g√©nero
    const genre = await prisma.genre.update({
      where: { id },
      data: {
        name: body.name.trim(),
        description: body.description?.trim() || null
      },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    return NextResponse.json(genre)
  } catch (error) {
    console.error('Error updating genre:', error)
    return NextResponse.json(
      { error: 'Error al actualizar el g√©nero' },
      { status: 500 }
    )
  }
}

// DELETE /api/genres/[id] - Eliminar g√©nero
/**
 * DELETE
 * @TODO Add documentation
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      )
    }
    
    // Verificar que el g√©nero existe
    const genre = await prisma.genre.findUnique({
      where: { id },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    if (!genre) {
      return NextResponse.json(
        { error: 'G√©nero no encontrado' },
        { status: 404 }
      )
    }
    
    // Verificar si tiene pel√≠culas asociadas
    if (genre._count.movies > 0) {
      return NextResponse.json(
        { 
          error: `No se puede eliminar el g√©nero porque tiene ${genre._count.movies} pel√≠cula(s) asociada(s)` 
        },
        { status: 400 }
      )
    }
    
    // Eliminar g√©nero
    await prisma.genre.delete({
      where: { id }
    })
    
    return NextResponse.json(
      { message: 'G√©nero eliminado exitosamente' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting genre:', error)
    return NextResponse.json(
      { error: 'Error al eliminar el g√©nero' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/health/db/route.ts
// ==================================================
// src/app/api/health/db/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

export async function GET() {
  try {
    // Test b√°sico de conexi√≥n
    const startTime = Date.now()
    await prisma.$queryRaw`SELECT 1`
    const queryTime = Date.now() - startTime

    // Obtener estad√≠sticas b√°sicas de la BD
    const [movieCount, peopleCount, poolStatsRaw] = await Promise.all([
      prisma.movie.count(),
      prisma.person.count(),
      prisma.$queryRaw<Array<{
        total_connections: number
        active_connections: number
        idle_connections: number
      }>>`
        SELECT 
          CAST(count(*) AS INTEGER) as total_connections,
          CAST(count(*) FILTER (WHERE state = 'active') AS INTEGER) as active_connections,
          CAST(count(*) FILTER (WHERE state = 'idle') AS INTEGER) as idle_connections
        FROM pg_stat_activity
        WHERE datname = current_database()
      `
    ])

    // Convertir BigInt a n√∫meros normales
    const poolStats = poolStatsRaw[0] ? {
      total_connections: Number(poolStatsRaw[0].total_connections),
      active_connections: Number(poolStatsRaw[0].active_connections),
      idle_connections: Number(poolStatsRaw[0].idle_connections)
    } : {
      total_connections: 0,
      active_connections: 0,
      idle_connections: 0
    }

    return NextResponse.json({
      status: 'healthy',
      database: {
        connected: true,
        responseTime: `${queryTime}ms`,
        stats: {
          movies: movieCount,
          people: peopleCount
        },
        pool: poolStats
      },
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    console.error('Database health check failed:', error)
    return NextResponse.json(
      {
        status: 'unhealthy',
        database: {
          connected: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        },
        timestamp: new Date().toISOString()
      },
      { status: 503 }
    )
  }
}

// ==================================================
// src/app/api/health/route.ts
// ==================================================
// src/app/api/health/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

export async function GET() {
  try {
    // Verificar conexi√≥n a la base de datos
    await prisma.$queryRaw`SELECT 1`
    
    return NextResponse.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: process.env.NODE_ENV,
      database: 'connected'
    })
  } catch (error) {
    return NextResponse.json(
      {
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        error: error instanceof Error ? error.message : 'Unknown error',
        database: 'disconnected'
      },
      { status: 503 }
    )
  }
}

// ==================================================
// src/app/api/images/hero/route.ts
// ==================================================
// src/app/api/images/hero/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

// Esta ruta debe ser din√°mica
export const dynamic = 'force-dynamic';

// GET /api/images/hero - Obtener im√°genes para el hero (una por pel√≠cula)
export async function GET(request: NextRequest) {
  try {
    // Primero: obtener las √∫ltimas 5 pel√≠culas que tienen im√°genes
    const moviesWithImages = await prisma.movie.findMany({
      where: {
        images: {
          some: {} // Pel√≠culas que tienen al menos una imagen
        }
      },
      orderBy: {
        updatedAt: 'desc'
      },
      take: 5,
      select: {
        id: true
      }
    })

    if (moviesWithImages.length === 0) {
      return NextResponse.json({ images: [] })
    }

    const movieIds = moviesWithImages.map(m => m.id)

    // Segundo: obtener todas las im√°genes de esas pel√≠culas
    const images = await prisma.image.findMany({
      where: {
        movieId: { in: movieIds }
      },
      include: {
        movie: {
          select: {
            id: true,
            title: true,
            year: true,        // A√±o de producci√≥n (prioridad)
            releaseYear: true, // A√±o de estreno (fallback)
            slug: true
          }
        },
        people: {
          include: {
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true
              }
            }
          },
          orderBy: {
            position: 'asc'
          }
        }
      }
    })

    // Tercero: agrupar por pel√≠cula y elegir una al azar de cada una
    const imagesByMovie = new Map<number, typeof images>()
    
    for (const image of images) {
      if (image.movieId) {
        const existing = imagesByMovie.get(image.movieId) || []
        existing.push(image)
        imagesByMovie.set(image.movieId, existing)
      }
    }

    // Seleccionar una imagen al azar de cada pel√≠cula
    const heroImages: typeof images = []
    
    for (const movieId of movieIds) {
      const movieImages = imagesByMovie.get(movieId)
      if (movieImages && movieImages.length > 0) {
        const randomIndex = Math.floor(Math.random() * movieImages.length)
        heroImages.push(movieImages[randomIndex])
      }
    }

    return NextResponse.json({
      images: heroImages
    })
  } catch (error) {
    console.error('Error fetching hero images:', error)
    return NextResponse.json(
      { error: 'Error al obtener im√°genes del hero', images: [] },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/images/route.ts
// ==================================================
// src/app/api/images/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { imageFormSchema } from '@/lib/images/imageTypes'

// GET - Listar im√°genes (con filtro opcional por movieId)
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const movieId = searchParams.get('movieId')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '20')
    const skip = (page - 1) * limit

    const where: any = {}
    if (movieId) {
      where.movieId = parseInt(movieId)
    }

    const [images, totalCount] = await Promise.all([
      prisma.image.findMany({
        where,
        include: {
          movie: {
            select: {
              id: true,
              title: true,
              releaseYear: true
            }
          },
          people: {
            include: {
              person: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true
                }
              }
            },
            orderBy: {
              position: 'asc'
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.image.count({ where })
    ])

    return NextResponse.json({
      data: images,
      totalCount,
      page,
      totalPages: Math.ceil(totalCount / limit),
      hasMore: skip + images.length < totalCount
    })
  } catch (error) {
    console.error('Error fetching images:', error)
    return NextResponse.json(
      { error: 'Error al obtener im√°genes' },
      { status: 500 }
    )
  }
}

// POST - Crear imagen
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validar datos
    const validatedData = imageFormSchema.parse(body)
    
    const { people, ...imageData } = validatedData

    // Crear imagen con personas en una transacci√≥n
    const image = await prisma.$transaction(async (tx) => {
      // Crear la imagen
      const newImage = await tx.image.create({
        data: {
          cloudinaryPublicId: imageData.cloudinaryPublicId,
          type: imageData.type,
          photoDate: imageData.photoDate ? new Date(imageData.photoDate) : null,
          photographerCredit: imageData.photographerCredit,
          eventName: imageData.eventName,
          movieId: imageData.movieId
        }
      })

      // Crear relaciones con personas si hay
      if (people && people.length > 0) {
        await tx.imagePerson.createMany({
          data: people.map(p => ({
            imageId: newImage.id,
            personId: p.personId,
            position: p.position
          }))
        })
      }

      // Retornar imagen con relaciones
      return tx.image.findUnique({
        where: { id: newImage.id },
        include: {
          movie: {
            select: {
              id: true,
              title: true,
              releaseYear: true
            }
          },
          people: {
            include: {
              person: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true
                }
              }
            },
            orderBy: {
              position: 'asc'
            }
          }
        }
      })
    })

    return NextResponse.json(image, { status: 201 })
  } catch (error) {
    console.error('Error creating image:', error)
    
    if (error instanceof Error && error.message.includes('Unique constraint')) {
      return NextResponse.json(
        { error: 'Ya existe una imagen con ese ID de Cloudinary' },
        { status: 409 }
      )
    }
    
    return NextResponse.json(
      { error: 'Error al crear imagen' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/images/[id]/route.ts
// ==================================================
// src/app/api/images/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { imageFormSchema } from '@/lib/images/imageTypes'

// GET - Obtener imagen por ID
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    const image = await prisma.image.findUnique({
      where: { id },
      include: {
        movie: {
          select: {
            id: true,
            title: true,
            releaseYear: true
          }
        },
        people: {
          include: {
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true
              }
            }
          },
          orderBy: {
            position: 'asc'
          }
        }
      }
    })

    if (!image) {
      return NextResponse.json(
        { error: 'Imagen no encontrada' },
        { status: 404 }
      )
    }

    return NextResponse.json(image)
  } catch (error) {
    console.error('Error fetching image:', error)
    return NextResponse.json(
      { error: 'Error al obtener imagen' },
      { status: 500 }
    )
  }
}

// PUT - Actualizar imagen
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    
    const validatedData = imageFormSchema.parse(body)
    const { people, ...imageData } = validatedData

    const image = await prisma.$transaction(async (tx) => {
      // Actualizar imagen
      await tx.image.update({
        where: { id },
        data: {
          cloudinaryPublicId: imageData.cloudinaryPublicId,
          type: imageData.type,
          photoDate: imageData.photoDate ? new Date(imageData.photoDate) : null,
          photographerCredit: imageData.photographerCredit,
          eventName: imageData.eventName,
          movieId: imageData.movieId
        }
      })

      // Eliminar personas existentes y crear nuevas
      await tx.imagePerson.deleteMany({
        where: { imageId: id }
      })

      if (people && people.length > 0) {
        await tx.imagePerson.createMany({
          data: people.map(p => ({
            imageId: id,
            personId: p.personId,
            position: p.position
          }))
        })
      }

      // Retornar imagen actualizada
      return tx.image.findUnique({
        where: { id },
        include: {
          movie: {
            select: {
              id: true,
              title: true,
              releaseYear: true
            }
          },
          people: {
            include: {
              person: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true
                }
              }
            },
            orderBy: {
              position: 'asc'
            }
          }
        }
      })
    })

    return NextResponse.json(image)
  } catch (error) {
    console.error('Error updating image:', error)
    return NextResponse.json(
      { error: 'Error al actualizar imagen' },
      { status: 500 }
    )
  }
}

// DELETE - Eliminar imagen
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    await prisma.image.delete({
      where: { id }
    })

    return new NextResponse(null, { status: 204 })
  } catch (error) {
    console.error('Error deleting image:', error)
    return NextResponse.json(
      { error: 'Error al eliminar imagen' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/locations/check-slug/route.ts
// ==================================================
// src/app/api/locations/check-slug/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { generateSlug } from '@/lib/utils/slugs'

// POST /api/locations/check-slug - Verificar si un slug est√° disponible
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { name, excludeId } = body

    if (!name || name.trim() === '') {
      return NextResponse.json(
        { available: false, slug: '', error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    const baseSlug = generateSlug(name)
    let slug = baseSlug
    let counter = 1
    let available = false

    // Buscar un slug disponible
    while (!available) {
      const where: any = { slug }
      if (excludeId) {
        where.NOT = { id: parseInt(excludeId) }
      }

      const exists = await prisma.location.findFirst({ where })
      
      if (!exists) {
        available = true
      } else {
        slug = `${baseSlug}-${counter}`
        counter++
      }
    }

    return NextResponse.json({ available: true, slug })
  } catch (error) {
    console.error('Error checking slug:', error)
    return NextResponse.json(
      { available: false, slug: '', error: 'Error al verificar el slug' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/locations/countries/route.ts
// ==================================================
// src/app/api/locations/countries/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const dynamic = 'force-dynamic'

export async function GET(request: NextRequest) {
  try {
    // Obtener todas las locations que no tienen parent (son pa√≠ses)
    // Quitamos el filtro 'type' que puede no existir
    const countries = await prisma.location.findMany({
      where: {
        parentId: null  // Solo filtrar por parentId null
      },
      orderBy: {
        name: 'asc'
      },
      select: {
        id: true,
        name: true,
        slug: true
      }
    });

    return NextResponse.json(countries);
  } catch (error) {
    console.error('Error fetching countries:', error);
    
    // Devolver el mensaje de error espec√≠fico para debugging
    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to fetch countries' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/locations/route.ts
// ==================================================
// src/app/api/locations/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { generateUniqueSlug } from '@/lib/utils/slugs'

// Forzar que esta ruta sea din√°mica
/**
 * dynamic
 * @TODO Add documentation
 */
export const dynamic = 'force-dynamic'
/**
 * revalidate
 * @TODO Add documentation
 */
export const revalidate = 0

// GET /api/locations - Listar lugares con filtros opcionales
/**
 * GET
 * @TODO Add documentation
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const parentId = searchParams.get('parentId')
    const search = searchParams.get('search')
    const includeChildren = searchParams.get('includeChildren') === 'true'

    const where: any = {}
    
    if (parentId === 'null') {
      where.parentId = null
    } else if (parentId) {
      where.parentId = parseInt(parentId)
    }
    
    if (search) {
      where.name = {
        contains: search,
        mode: 'insensitive'
      }
    }

    const locations = await prisma.location.findMany({
      where,
      include: {
        parent: true,
        children: includeChildren ? {
          include: {
            children: true
          }
        } : false,
        _count: {
          select: {
            children: true,
            peopleBornHere: true,
            peopleDiedHere: true
          }
        }
      },
      orderBy: [
        { parentId: 'asc' },
        { name: 'asc' }
      ]
    })

    return NextResponse.json(locations, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
      },
    })
  } catch (error) {
    console.error('Error fetching locations:', error)
    return NextResponse.json(
      { error: 'Error al obtener los lugares' },
      { status: 500 }
    )
  }
}

// POST /api/locations - Crear nuevo lugar
/**
 * POST
 * @TODO Add documentation
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { name, parentId, latitude, longitude } = body

    // Validaciones
    if (!name || name.trim() === '') {
      return NextResponse.json(
        { error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    // Generar slug √∫nico
    const slug = await generateUniqueSlug(name, 'location', prisma)

    const location = await prisma.location.create({
      data: {
        name,
        slug,
        parent: parentId ? { connect: { id: parseInt(parentId) } } : undefined,
        latitude: latitude ? parseFloat(latitude) : null,
        longitude: longitude ? parseFloat(longitude) : null
      },
      include: {
        parent: true
      }
    })

    return NextResponse.json(location, { status: 201 })
  } catch (error) {
    console.error('Error creating location:', error)
    return NextResponse.json(
      { error: 'Error al crear el lugar' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/locations/search/route.ts
// ==================================================
// src/app/api/locations/search/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const dynamic = 'force-dynamic'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (!query || query.length < 2) {
      return NextResponse.json([]);
    }

    // Buscar ubicaciones que coincidan con el query
    const locations = await prisma.location.findMany({
      where: {
        name: {
          contains: query,
          mode: 'insensitive'
        }
      },
      include: {
        parent: {
          include: {
            parent: true
          }
        }
      },
      take: 20,
      orderBy: [
        {
          name: 'asc'
        }
      ]
    });

    // Construir el path completo para cada ubicaci√≥n
    const locationsWithPath = await Promise.all(
      locations.map(async (location) => {
        let path = location.name;
        let current = location;
        
        while (current.parent) {
          path = `${current.parent.name}, ${path}`;
          
          if (current.parent.parent) {
            path = `${current.parent.parent.name}, ${path}`;
            break; // Asumimos m√°ximo 3 niveles
          }
          break;
        }

        return {
          id: location.id,
          name: location.name,
          slug: location.slug,
          parentId: location.parentId,
          path,
          parent: location.parent
        };
      })
    );

    return NextResponse.json(locationsWithPath);
  } catch (error) {
    console.error('Error searching locations:', error);
    return NextResponse.json(
      { error: 'Error al buscar ubicaciones' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/locations/tree/route.ts
// ==================================================
// src/app/api/locations/tree/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

// Forzar que esta ruta sea din√°mica
export const dynamic = 'force-dynamic'
export const revalidate = 0

interface LocationNode {
  id: number
  name: string
  slug: string
  parentId: number | null
  children: LocationNode[]
  _count: {
    children: number
    peopleBornHere: number
    peopleDiedHere: number
  }
}

// GET /api/locations/tree - Obtener estructura de √°rbol completa
export async function GET(request: NextRequest) {
  try {
    // Obtener todos los lugares
    const locations = await prisma.location.findMany({
      orderBy: [
        { parentId: 'asc' },
        { name: 'asc' }
      ],
      include: {
        _count: {
          select: {
            children: true,
            peopleBornHere: true,
            peopleDiedHere: true
          }
        }
      }
    })

    // Construir el √°rbol
    const locationMap = new Map<number, LocationNode>()
    const roots: LocationNode[] = []

    // Primero, crear todos los nodos
    locations.forEach(location => {
      locationMap.set(location.id, {
        id: location.id,
        name: location.name,
        slug: location.slug,
        parentId: location.parentId,
        children: [],
        _count: location._count
      })
    })

    // Luego, establecer las relaciones padre-hijo
    locations.forEach(location => {
      const node = locationMap.get(location.id)!
      if (location.parentId) {
        const parent = locationMap.get(location.parentId)
        if (parent) {
          parent.children.push(node)
        }
      } else {
        roots.push(node)
      }
    })

    // Ordenar los hijos de cada nodo alfab√©ticamente
    const sortChildren = (node: LocationNode) => {
      node.children.sort((a, b) => a.name.localeCompare(b.name))
      node.children.forEach(sortChildren)
    }
    roots.forEach(sortChildren)

    return NextResponse.json(roots, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
      },
    })
  } catch (error) {
    console.error('Error fetching location tree:', error)
    return NextResponse.json(
      { error: 'Error al obtener el √°rbol de lugares' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/locations/[id]/route.ts
// ==================================================
// src/app/api/locations/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { generateUniqueSlug } from '@/lib/utils/slugs'

// GET /api/locations/[id] - Obtener un lugar por ID con path completo
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    if (isNaN(id)) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const location = await prisma.location.findUnique({
      where: { id },
      include: {
        parent: {
          include: {
            parent: true
          }
        },
        children: {
          orderBy: { name: 'asc' }
        },
        _count: {
          select: {
            children: true,
            peopleBornHere: true,
            peopleDiedHere: true
          }
        }
      }
    })

    if (!location) {
      return NextResponse.json(
        { error: 'Lugar no encontrado' },
        { status: 404 }
      )
    }

    // Construir el path completo
    let path = location.name
    let current = location
    
    while (current.parent) {
      path = `${current.parent.name} > ${path}`
      
      if (current.parent.parentId) {
        const grandParent = await prisma.location.findUnique({
          where: { id: current.parent.parentId },
          include: { parent: true }
        })
        
        if (grandParent) {
          current = { ...current, parent: grandParent }
        } else {
          break
        }
      } else {
        break
      }
    }

    // Retornar la location con el path incluido
    return NextResponse.json({
      ...location,
      path
    })
  } catch (error) {
    console.error('Error fetching location:', error)
    return NextResponse.json(
      { error: 'Error al obtener el lugar' },
      { status: 500 }
    )
  }
}

// PUT /api/locations/[id] - Actualizar un lugar
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    const { name, parentId, latitude, longitude } = body

    // Validaciones
    if (!name || name.trim() === '') {
      return NextResponse.json(
        { error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    // Verificar que no se est√° asignando como padre a s√≠ mismo o a sus descendientes
    if (parentId === id) {
      return NextResponse.json(
        { error: 'Un lugar no puede ser su propio padre' },
        { status: 400 }
      )
    }

    if (parentId) {
      // Verificar que no se est√° creando un ciclo
      const isDescendant = await checkIfDescendant(id, parseInt(parentId))
      if (isDescendant) {
        return NextResponse.json(
          { error: 'No se puede asignar un descendiente como padre' },
          { status: 400 }
        )
      }
    }

    // Generar nuevo slug si cambi√≥ el nombre
    const currentLocation = await prisma.location.findUnique({
      where: { id }
    })

    if (!currentLocation) {
      return NextResponse.json(
        { error: 'Lugar no encontrado' },
        { status: 404 }
      )
    }

    let slug = currentLocation.slug
    if (currentLocation.name !== name) {
      slug = await generateUniqueSlug(name, 'location', prisma, id)
    }

    const location = await prisma.location.update({
      where: { id },
      data: {
        name,
        slug,
        parent: parentId ? { connect: { id: parseInt(parentId) } } : { disconnect: true },
        latitude: latitude ? parseFloat(latitude) : null,
        longitude: longitude ? parseFloat(longitude) : null
      },
      include: {
        parent: true
      }
    })

    return NextResponse.json(location)
  } catch (error) {
    console.error('Error updating location:', error)
    return NextResponse.json(
      { error: 'Error al actualizar el lugar' },
      { status: 500 }
    )
  }
}

// DELETE /api/locations/[id] - Eliminar un lugar
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)

    // Verificar si tiene hijos
    const location = await prisma.location.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            children: true,
            peopleBornHere: true,
            peopleDiedHere: true
          }
        }
      }
    })

    if (!location) {
      return NextResponse.json(
        { error: 'Lugar no encontrado' },
        { status: 404 }
      )
    }

    // Verificar si tiene relaciones
    const hasRelations = 
      location._count.children > 0 ||
      location._count.peopleBornHere > 0 ||
      location._count.peopleDiedHere > 0

    if (hasRelations) {
      const relations = []
      if (location._count.children > 0) relations.push(`${location._count.children} lugares hijos`)
      if (location._count.peopleBornHere > 0) relations.push(`${location._count.peopleBornHere} personas nacidas aqu√≠`)
      if (location._count.peopleDiedHere > 0) relations.push(`${location._count.peopleDiedHere} personas fallecidas aqu√≠`)

      return NextResponse.json(
        { error: `No se puede eliminar el lugar porque tiene: ${relations.join(', ')}` },
        { status: 400 }
      )
    }

    await prisma.location.delete({
      where: { id }
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting location:', error)
    return NextResponse.json(
      { error: 'Error al eliminar el lugar' },
      { status: 500 }
    )
  }
}

// Funci√≥n auxiliar para verificar si un lugar es descendiente de otro
async function checkIfDescendant(ancestorId: number, descendantId: number): Promise<boolean> {
  const descendant = await prisma.location.findUnique({
    where: { id: descendantId },
    select: { parentId: true }
  })

  if (!descendant || !descendant.parentId) {
    return false
  }

  if (descendant.parentId === ancestorId) {
    return true
  }

  return checkIfDescendant(ancestorId, descendant.parentId)
}

// ==================================================
// src/app/api/metrics/database/route.ts
// ==================================================
// src/app/api/metrics/database/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

// Proteger este endpoint en producci√≥n
const METRICS_SECRET = process.env.METRICS_SECRET || 'your-secret-key'

export async function GET(request: NextRequest) {
  // Verificar autorizaci√≥n
  const authHeader = request.headers.get('authorization')
  if (authHeader !== `Bearer ${METRICS_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  try {
    // Obtener m√©tricas de Prisma
    const metrics = (prisma as any).getMetrics()
    
    // Intentar obtener m√©tricas de PostgreSQL
    let pgStats = null
    try {
      const result = await prisma.$queryRaw`
        SELECT 
          numbackends as active_connections,
          xact_commit as committed_transactions,
          xact_rollback as rolled_back_transactions,
          blks_read as blocks_read,
          blks_hit as blocks_hit,
          tup_returned as rows_returned,
          tup_fetched as rows_fetched,
          tup_inserted as rows_inserted,
          tup_updated as rows_updated,
          tup_deleted as rows_deleted
        FROM pg_stat_database 
        WHERE datname = current_database()
      ` as any[]
      
      pgStats = result[0]
    } catch (error) {
      console.error('Error fetching PG stats:', error)
    }

    // Pool stats
    let poolStats = null
    try {
      const poolResult = await prisma.$queryRaw`
        SELECT 
          count(*) FILTER (WHERE state = 'active') as active,
          count(*) FILTER (WHERE state = 'idle') as idle,
          count(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction,
          count(*) FILTER (WHERE state = 'idle in transaction (aborted)') as idle_aborted,
          count(*) FILTER (WHERE state = 'fastpath function call') as fastpath,
          count(*) FILTER (WHERE state = 'disabled') as disabled,
          count(*) as total
        FROM pg_stat_activity
        WHERE datname = current_database()
      ` as any[]
      
      poolStats = poolResult[0]
    } catch (error) {
      console.error('Error fetching pool stats:', error)
    }

    // Query performance stats
    let queryStats = null
    try {
      const queryResult = await prisma.$queryRaw`
        SELECT 
          calls,
          total_exec_time,
          mean_exec_time,
          max_exec_time,
          min_exec_time,
          query
        FROM pg_stat_statements
        WHERE query NOT LIKE '%pg_stat%'
        ORDER BY mean_exec_time DESC
        LIMIT 10
      ` as any[]
      
      queryStats = queryResult
    } catch (error) {
      // pg_stat_statements puede no estar habilitado
      console.log('pg_stat_statements not available')
    }

    const response = {
      timestamp: new Date().toISOString(),
      prisma: metrics,
      postgresql: pgStats,
      connectionPool: poolStats,
      slowQueries: queryStats,
      health: {
        status: 'healthy',
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        pid: process.pid
      }
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('Error fetching metrics:', error)
    return NextResponse.json(
      { 
        error: 'Failed to fetch metrics',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/movies/home-feed/route.ts
// ==================================================
// src/app/api/movies/home-feed/route.ts - VERSI√ìN CORREGIDA

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import RedisClient from '@/lib/redis';

// Mantener cach√© en memoria como fallback si Redis falla
let memoryCachedData: any = null;
let memoryCacheTime: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

export async function GET() {
  const cacheKey = 'home-feed:movies:v2'; // ‚ö†Ô∏è IMPORTANTE: Cambi√© la versi√≥n del cache key para invalidar el cach√© anterior

  try {
    // 1. Intentar obtener de Redis primero
    const redisCached = await RedisClient.get(cacheKey);

    if (redisCached) {
      console.log('‚úÖ Cache HIT desde Redis');
      return NextResponse.json(
        JSON.parse(redisCached),
        {
          headers: {
            'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=600',
            'X-Cache': 'HIT',
            'X-Cache-Source': 'redis'
          }
        }
      );
    }

    // 2. Si Redis falla o no hay cach√©, verificar cach√© en memoria como fallback
    const now = Date.now();
    if (memoryCachedData && (now - memoryCacheTime) < CACHE_DURATION) {
      console.log('‚úÖ Cache HIT desde memoria (Redis fallback)');

      // Intentar guardar en Redis para pr√≥ximas requests
      await RedisClient.set(
        cacheKey,
        JSON.stringify(memoryCachedData),
        300 // 5 minutos
      );

      return NextResponse.json(memoryCachedData, {
        headers: {
          'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=600',
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory'
        }
      });
    }

    // 3. Si no hay cach√© en ning√∫n lado, generar nuevo
    console.log('üîÑ Cache MISS - Generando datos desde la base de datos');

    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth() + 1;
    const currentDay = today.getDate();

    // OPTIMIZACI√ìN: Queries paralelas y espec√≠ficas
    const [ultimosEstrenos, proximosEstrenos, ultimasPeliculas, ultimasPersonas] = await Promise.all([
      // √öltimos estrenos - solo pel√≠culas con fecha completa Y que ya se estrenaron
      prisma.movie.findMany({
        where: {
          AND: [
            { releaseYear: { not: null } },
            { releaseMonth: { not: null } },
            { releaseDay: { not: null } },
            {
              OR: [
                // A√±os anteriores
                { releaseYear: { lt: currentYear } },
                // Este a√±o pero meses anteriores
                {
                  AND: [
                    { releaseYear: currentYear },
                    { releaseMonth: { lt: currentMonth } }
                  ]
                },
                // Este a√±o, este mes, pero d√≠as anteriores o el d√≠a de hoy
                {
                  AND: [
                    { releaseYear: currentYear },
                    { releaseMonth: currentMonth },
                    { releaseDay: { lte: currentDay } }  // ‚úÖ FIX: Verificar tambi√©n el d√≠a
                  ]
                }
              ]
            }
          ]
        },
        select: {
          id: true,
          slug: true,
          title: true,
          releaseYear: true,
          releaseMonth: true,
          releaseDay: true,
          posterUrl: true,
          genres: {
            select: {
              genre: {
                select: { name: true }
              }
            },
            take: 3
          },
          crew: {
            where: { roleId: 2 }, // Solo Director
            select: {
              roleId: true,
              person: {
                select: {
                  firstName: true,
                  lastName: true
                }
              }
            },
            take: 3 // Tomar hasta 3 directores si hay co-directores
          }
        },
        orderBy: [
          { releaseYear: 'desc' },
          { releaseMonth: 'desc' },
          { releaseDay: 'desc' }
        ],
        take: 6
      }),

      // Pr√≥ximos estrenos - pel√≠culas con fechas futuras
      prisma.movie.findMany({
        where: {
          AND: [
            { releaseYear: { not: null } },
            {
              OR: [
                // A√±os futuros
                { releaseYear: { gt: currentYear } },
                // Este a√±o pero meses futuros
                {
                  AND: [
                    { releaseYear: currentYear },
                    { releaseMonth: { gt: currentMonth } }
                  ]
                },
                // Este a√±o, este mes, pero d√≠as futuros (no incluir hoy)
                {
                  AND: [
                    { releaseYear: currentYear },
                    { releaseMonth: currentMonth },
                    { releaseDay: { gt: currentDay } }  // ‚úÖ FIX: Solo d√≠as futuros, no el d√≠a de hoy
                  ]
                }
              ]
            }
          ]
        },
        select: {
          id: true,
          slug: true,
          title: true,
          releaseYear: true,
          releaseMonth: true,
          releaseDay: true,
          posterUrl: true,
          genres: {
            select: {
              genre: {
                select: { name: true }
              }
            },
            take: 3
          },
          crew: {
            where: { roleId: 2 },
            select: {
              roleId: true,
              person: {
                select: {
                  firstName: true,
                  lastName: true
                }
              }
            },
            take: 3 // Tomar hasta 3 directores si hay co-directores
          }
        },
        orderBy: [
          { releaseYear: 'asc' },
          { releaseMonth: 'asc' },
          { releaseDay: 'asc' }
        ],
        take: 6
      }),

      // √öltimas pel√≠culas - solo campos esenciales
      prisma.movie.findMany({
        select: {
          id: true,
          slug: true,
          title: true,
          posterUrl: true
        },
        orderBy: { createdAt: 'desc' },
        take: 8
      }),

      // √öltimas personas - con g√©nero y roles de √∫ltima pel√≠cula
      // √öltimas personas - con g√©nero y roles de √∫ltima pel√≠cula
      prisma.person.findMany({
        select: {
          id: true,
          slug: true,
          firstName: true,
          lastName: true,
          photoUrl: true,
          gender: true,
          _count: {
            select: {
              castRoles: true,
              crewRoles: true
            }
          },
          // Obtener los √∫ltimos roles de crew para determinar el rol espec√≠fico
          crewRoles: {
            select: {
              role: {
                select: { name: true }
              },
              movie: {
                select: {
                  id: true,
                  createdAt: true
                }
              }
            },
            orderBy: {
              movie: { createdAt: 'desc' }
            },
            take: 10
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 6
      })
    ]);

    // Formatear los datos de manera eficiente
    // IMPORTANTE: NO eliminar el campo crew, el componente MovieCard lo necesita
    const formattedData = {
      ultimosEstrenos: ultimosEstrenos.map(movie => ({
        ...movie,
        // Mantener crew para que MovieCard pueda procesarlo
        // NO agregar: crew: undefined
        genres: movie.genres.map(g => ({ name: g.genre.name }))
      })),

      proximosEstrenos: proximosEstrenos.map(movie => ({
        ...movie,
        // Mantener crew para que MovieCard pueda procesarlo
        genres: movie.genres.map(g => ({ name: g.genre.name }))
      })),

      ultimasPeliculas,

      ultimasPersonas: ultimasPersonas.map(person => {
        const { _count, crewRoles, ...personData } = person;

        let role: string;

        if (_count.castRoles > _count.crewRoles) {
          // Es mayormente actor/actriz - usar g√©nero
          if (person.gender === 'MALE') {
            role = 'Actor';
          } else if (person.gender === 'FEMALE') {
            role = 'Actriz';
          } else {
            role = 'Actor/Actriz';
          }
        } else if (_count.crewRoles > 0 && crewRoles && crewRoles.length > 0) {
          // Es mayormente crew - obtener roles de la √∫ltima pel√≠cula
          const lastMovieId = crewRoles[0]?.movie?.id;

          if (lastMovieId) {
            // Obtener todos los roles de esa pel√≠cula
            const rolesInLastMovie = crewRoles
              .filter(cr => cr.movie?.id === lastMovieId)
              .map(cr => cr.role?.name)
              .filter((r): r is string => !!r);

            // Eliminar duplicados y unir con coma
            const uniqueRoles = [...new Set(rolesInLastMovie)];
            role = uniqueRoles.length > 0 ? uniqueRoles.join(', ') : 'Equipo t√©cnico';
          } else {
            role = 'Equipo t√©cnico';
          }
        } else {
          role = 'Profesional del cine';
        }

        return {
          ...personData,
          role
        };
      }),

      // Agregar timestamp para debugging
      generatedAt: new Date().toISOString()
    };

    // 4. Guardar en ambos cach√©s
    // Redis con TTL de 5 minutos
    const redisSaved = await RedisClient.set(
      cacheKey,
      JSON.stringify(formattedData),
      300 // 5 minutos en segundos
    );

    if (redisSaved) {
      console.log('‚úÖ Datos guardados en Redis');
    } else {
      console.log('‚ö†Ô∏è No se pudo guardar en Redis, usando solo cach√© en memoria');
    }

    // Actualizar cach√© en memoria como fallback
    memoryCachedData = formattedData;
    memoryCacheTime = now;

    return NextResponse.json(formattedData, {
      headers: {
        'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=600',
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database'
      }
    });

  } catch (error) {
    console.error('‚ùå Error fetching home feed:', error);

    // Si hay error, intentar servir desde cach√© en memoria
    if (memoryCachedData) {
      console.log('‚ö†Ô∏è Sirviendo cach√© viejo desde memoria debido a error');
      return NextResponse.json(memoryCachedData, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }

    // Si no hay ning√∫n cach√© disponible, error 500
    return NextResponse.json(
      { error: 'Error al cargar los datos de la home' },
      { status: 500 }
    );
  }
}

// Endpoint para invalidar cach√© manualmente (√∫til para testing)
export async function DELETE() {
  try {
    // Invalidar ambas versiones del cach√© por si acaso
    const deleted1 = await RedisClient.del('home-feed:movies:v1');
    const deleted2 = await RedisClient.del('home-feed:movies:v2');
    memoryCachedData = null;
    memoryCacheTime = 0;

    return NextResponse.json({
      success: true,
      message: 'Cach√© invalidado exitosamente',
      redisDeleted: { v1: deleted1, v2: deleted2 }
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Error al invalidar cach√©' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/movies/route.ts
// ==================================================
// src/app/api/movies/route.ts - CON REDIS CACHE
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'
import { movieSchema } from '@/lib/schemas'
import { generateUniqueSlug } from '@/lib/utils/slugs'
import RedisClient from '@/lib/redis'

// ============================================
// CACHE CONFIGURATION
// ============================================

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 60 * 60 * 1000; // 1 hora en ms

// TTL diferenciado seg√∫n tipo de consulta
function getRedisTTL(searchParams: URLSearchParams): number {
  const upcoming = searchParams.get('upcoming');
  const year = searchParams.get('year');
  const yearFrom = searchParams.get('yearFrom');
  
  // Pr√≥ximos estrenos: 15 minutos (cambian frecuentemente)
  if (upcoming === 'true') {
    return 900; // 15 minutos
  }
  
  // Datos hist√≥ricos: 24 horas (no cambian)
  if (year || yearFrom) {
    return 86400; // 24 horas
  }
  
  // Por defecto: 1 hora
  return 3600;
}

// Genera clave √∫nica basada en los par√°metros de b√∫squeda
function generateCacheKey(searchParams: URLSearchParams): string {
  const relevantParams = [
    'page',
    'limit',
    'search',
    'genre',
    'year',
    'yearFrom',
    'yearTo',
    'stage',
    'sortBy',
    'sortOrder',
    'upcoming'
  ];
  
  const keyParts = relevantParams
    .map(param => {
      const value = searchParams.get(param);
      return value ? `${param}:${value}` : null;
    })
    .filter(Boolean);
  
  return `movies:list:${keyParts.join(':')}:v1`;
}

// ============================================
// GET /api/movies - Obtener lista de pel√≠culas con filtros
// ============================================
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    
    // Generar clave de cach√© √∫nica
    const cacheKey = generateCacheKey(searchParams);
    const redisTTL = getRedisTTL(searchParams);
    
    // 1. Intentar obtener de Redis
    try {
      const redisCached = await RedisClient.get(cacheKey);
      
      if (redisCached) {
        console.log(`‚úÖ Cache HIT desde Redis para listado: ${cacheKey.substring(0, 60)}...`);
        return NextResponse.json(
          JSON.parse(redisCached),
          {
            headers: {
              'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
              'X-Cache': 'HIT',
              'X-Cache-Source': 'redis'
            }
          }
        );
      }
    } catch (redisError) {
      console.error('Redis error (non-fatal):', redisError);
    }
    
    // 2. Verificar cach√© en memoria como fallback
    const now = Date.now();
    const memoryCached = memoryCache.get(cacheKey);
    
    if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
      console.log(`‚úÖ Cache HIT desde memoria para listado: ${cacheKey.substring(0, 60)}...`);
      
      // Intentar guardar en Redis para pr√≥ximas requests
      RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), redisTTL)
        .catch(err => console.error('Error guardando en Redis:', err));
      
      return NextResponse.json(memoryCached.data, {
        headers: {
          'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory'
        }
      });
    }
    
    // 3. No hay cach√©, consultar base de datos
    console.log(`üîÑ Cache MISS - Consultando BD para listado: ${cacheKey.substring(0, 60)}...`);
    
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '20')
    const search = searchParams.get('search') || ''
    const genre = searchParams.get('genre') || ''
    const year = searchParams.get('year') || ''
    const stage = searchParams.get('stage') || ''
    const sortBy = searchParams.get('sortBy') || 'createdAt'
    const sortOrder = searchParams.get('sortOrder') || 'desc' as 'asc' | 'desc'
    const yearFrom = searchParams.get('yearFrom') || ''
    const yearTo = searchParams.get('yearTo') || ''
    const upcoming = searchParams.get('upcoming') || ''

    // Si hay b√∫squeda, usar query SQL con unaccent
    if (search) {
      try {
        const searchQuery = search.toLowerCase().trim()
        const searchPattern = `%${searchQuery}%`
        const skip = (page - 1) * limit

        const movies = await prisma.$queryRaw<any[]>`
          SELECT 
            id,
            slug,
            title,
            year,
            release_year as "releaseYear",
            release_month as "releaseMonth",
            release_day as "releaseDay",
            duration,
            poster_url as "posterUrl",
            stage
          FROM movies
          WHERE 
            unaccent(LOWER(title)) LIKE unaccent(${searchPattern})
          ORDER BY title ASC
          LIMIT ${limit}
          OFFSET ${skip}
        `

        const totalResult = await prisma.$queryRaw<{ count: number }[]>`
          SELECT COUNT(*)::int as count
          FROM movies
          WHERE 
            unaccent(LOWER(title)) LIKE unaccent(${searchPattern})
        `

        const total = totalResult[0]?.count || 0
        const movieIds = movies.map(m => m.id)

        if (movieIds.length > 0) {
          const [genres, countries] = await Promise.all([
            prisma.movieGenre.findMany({
              where: { movieId: { in: movieIds } },
              include: { genre: true }
            }),
            prisma.movieCountry.findMany({
              where: { movieId: { in: movieIds }, isPrimary: true },
              include: { location: true }
            })
          ])

          const formattedMovies = movies.map((movie: any) => {
            const movieGenres = genres.filter(g => g.movieId === movie.id)
            const movieCountry = countries.find(c => c.movieId === movie.id)

            return {
              id: movie.id,
              slug: movie.slug,
              title: movie.title,
              year: movie.year,
              releaseYear: movie.releaseYear,
              releaseMonth: movie.releaseMonth,
              releaseDay: movie.releaseDay,
              duration: movie.duration,
              posterUrl: movie.posterUrl,
              stage: movie.stage,
              genres: movieGenres.map(g => ({
                id: g.genre.id,
                name: g.genre.name
              })),
              country: movieCountry?.location?.name || 'Argentina'
            }
          })

          const result = {
            movies: formattedMovies,
            pagination: {
              page,
              limit,
              total,
              totalPages: Math.ceil(total / limit),
              currentPage: page,
              totalItems: total
            }
          };
          
          // Guardar en ambos cach√©s
          RedisClient.set(cacheKey, JSON.stringify(result), redisTTL)
            .then(saved => {
              if (saved) {
                console.log(`‚úÖ Listado guardado en Redis con TTL ${redisTTL}s (${redisTTL/60} min)`);
              }
            })
            .catch(err => console.error('Error guardando en Redis:', err));
          
          memoryCache.set(cacheKey, {
            data: result,
            timestamp: now
          });

          return NextResponse.json(result, {
            headers: {
              'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
              'X-Cache': 'MISS',
              'X-Cache-Source': 'database'
            }
          });
        }

        const emptyResult = {
          movies: [],
          pagination: {
            page,
            limit,
            total: 0,
            totalPages: 0,
            currentPage: page,
            totalItems: 0
          }
        };
        
        // Tambi√©n cachear resultados vac√≠os (por menos tiempo)
        RedisClient.set(cacheKey, JSON.stringify(emptyResult), 300)
          .catch(err => console.error('Error guardando en Redis:', err));

        return NextResponse.json(emptyResult, {
          headers: {
            'Cache-Control': 'public, s-maxage=300',
            'X-Cache': 'MISS',
            'X-Cache-Source': 'database'
          }
        });

      } catch (err) {
        console.error('Error with unaccent search:', err)
        // Continuar con fallback
      }
    }

    // B√∫squeda est√°ndar sin unaccent
    const where: any = {}

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { synopsis: { contains: search, mode: 'insensitive' } }
      ]
    }

    if (genre) {
      where.genres = {
        some: {
          genre: {
            slug: genre
          }
        }
      }
    }

    if (year) {
      where.releaseYear = parseInt(year)
    }

    if (yearFrom && yearTo && !year) {
      where.releaseYear = {
        gte: parseInt(yearFrom),
        lte: parseInt(yearTo)
      }
    }

    if (upcoming === 'true') {
      const now = new Date()
      const currentYear = now.getFullYear()

      where.releaseYear = {
        gte: currentYear
      }
    }

    if (stage) {
      where.stage = stage
    }

    const skip = (page - 1) * limit

    // Definir orderBy con tipo expl√≠cito
    const orderByClause = sortBy === 'releaseYear' 
      ? [
          { releaseYear: sortOrder as 'asc' | 'desc' },
          { releaseMonth: sortOrder as 'asc' | 'desc' },
          { releaseDay: sortOrder as 'asc' | 'desc' }
        ]
      : { [sortBy]: sortOrder as 'asc' | 'desc' };

    const [movies, total] = await Promise.all([
      prisma.movie.findMany({
        where,
        skip,
        take: limit,
        orderBy: orderByClause,
        include: {
          genres: {
            include: {
              genre: true
            }
          },
          movieCountries: {
            where: {
              isPrimary: true
            },
            include: {
              location: true
            }
          },
          crew: {
            where: {
              roleId: 2
            },
            include: {
              person: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true,
                  slug: true
                }
              },
              role: true
            },
            orderBy: {
              billingOrder: 'asc'
            }
          }
        }
      }),
      prisma.movie.count({ where })
    ])

    const formattedMovies = movies.map(movie => ({
      id: movie.id,
      slug: movie.slug,
      title: movie.title,
      year: movie.year,
      releaseYear: movie.releaseYear,
      releaseMonth: movie.releaseMonth,
      releaseDay: movie.releaseDay,
      releaseDateFormatted: movie.releaseYear
        ? `${movie.releaseYear}${movie.releaseMonth ? `-${String(movie.releaseMonth).padStart(2, '0')}` : ''}${movie.releaseDay ? `-${String(movie.releaseDay).padStart(2, '0')}` : ''}`
        : null,
      duration: movie.duration,
      posterUrl: movie.posterUrl,
      stage: movie.stage,
      genres: movie.genres.map(g => ({
        id: g.genre.id,
        name: g.genre.name
      })),
      country: movie.movieCountries[0]?.location?.name || 'Argentina',
      crew: movie.crew?.map(c => ({
        roleId: c.roleId,
        role: c.role?.name || c.role,
        person: c.person
      })) || []
    }))

    const result = {
      movies: formattedMovies,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        currentPage: page,
        totalItems: total
      }
    };
    
    // 4. Guardar en ambos cach√©s
    RedisClient.set(cacheKey, JSON.stringify(result), redisTTL)
      .then(saved => {
        if (saved) {
          console.log(`‚úÖ Listado guardado en Redis con TTL ${redisTTL}s (${redisTTL/60} min)`);
        }
      })
      .catch(err => console.error('Error guardando en Redis:', err));
    
    memoryCache.set(cacheKey, {
      data: result,
      timestamp: now
    });
    
    // Limpiar cach√© de memoria viejo (mantener m√°ximo 200 listados)
    if (memoryCache.size > 200) {
      const oldestKey = memoryCache.keys().next().value;
      if (oldestKey) {
        memoryCache.delete(oldestKey);
      }
    }

    return NextResponse.json(result, {
      headers: {
        'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database'
      }
    });

  } catch (error) {
    console.error('Error fetching movies:', error)
    
    // Intentar servir desde cach√© stale si hay error
    const cacheKey = generateCacheKey(request.nextUrl.searchParams);
    const staleCache = memoryCache.get(cacheKey);
    
    if (staleCache) {
      console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
      return NextResponse.json(staleCache.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }
    
    return NextResponse.json(
      { error: 'Error al obtener las pel√≠culas' },
      { status: 500 }
    )
  }
}

// ============================================
// POST /api/movies - Crear nueva pel√≠cula
// ============================================
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // Limpiar datos antes de validar
    const cleanedData = {
      ...body,
      ratingId: body.ratingId === 0 ? null : body.ratingId,
      // Asegurar que metaKeywords sea un array
      metaKeywords: body.metaKeywords
        ? Array.isArray(body.metaKeywords)
          ? body.metaKeywords
          : typeof body.metaKeywords === 'string'
            ? body.metaKeywords.split(',').map((k: string) => k.trim()).filter(Boolean)
            : []
        : []
    };

    // Validar datos
    const validatedData = movieSchema.parse(cleanedData)

    // Generar slug √∫nico con la funci√≥n actualizada
const slug = await generateUniqueSlug(validatedData.title, 'movie', prisma)

    // Extraer relaciones y campos especiales
    const {
      genres,
      cast,
      crew,
      countries,
      productionCompanies,
      distributionCompanies,
      themes,
      alternativeTitles,
      links,
      screeningVenues,
      colorTypeId,
      ratingId,
      metaKeywords,
      releaseYear,
      releaseMonth,
      releaseDay,
      filmingStartYear,
      filmingStartMonth,
      filmingStartDay,
      filmingEndYear,
      filmingEndMonth,
      filmingEndDay,
      ...movieDataClean
    } = validatedData

    // Asegurar que metaKeywords sea un array
    const processedMetaKeywords = metaKeywords
      ? Array.isArray(metaKeywords)
        ? metaKeywords
        : typeof metaKeywords === 'string'
          ? metaKeywords.split(',').map((k: string) => k.trim()).filter(Boolean)
          : []
      : []

    // Crear pel√≠cula con relaciones
    const movie = await prisma.movie.create({
      data: {
        ...movieDataClean,
        slug,
        metaKeywords: processedMetaKeywords,
        releaseYear: releaseYear ?? null,
        releaseMonth: releaseMonth ?? null,
        releaseDay: releaseDay ?? null,
        filmingStartYear: filmingStartYear ?? null,
        filmingStartMonth: filmingStartMonth ?? null,
        filmingStartDay: filmingStartDay ?? null,
        filmingEndYear: filmingEndYear ?? null,
        filmingEndMonth: filmingEndMonth ?? null,
        filmingEndDay: filmingEndDay ?? null,

        // Relaciones opcionales con connect
        ...(colorTypeId && {
          colorType: { connect: { id: colorTypeId } }
        }),
        ...(ratingId && {
          rating: { connect: { id: ratingId } }
        }),

        // Relaciones many-to-many
        ...(genres && genres.length > 0 && {
          genres: {
            create: genres.map((genreId: number, index: number) => ({
              genreId,
              isPrimary: index === 0
            }))
          }
        }),

        ...(cast && cast.length > 0 && {
          cast: {
            create: cast.map((item: any) => ({
              personId: item.personId,
              characterName: item.characterName || null,
              billingOrder: item.billingOrder || 0,
              isPrincipal: item.isPrincipal || false
            }))
          }
        }),

        ...(crew && crew.length > 0 && {
          crew: {
            create: crew.map((item: any) => ({
              personId: item.personId,
              roleId: item.roleId,
              billingOrder: item.billingOrder || 0
            }))
          }
        }),

        ...(countries && countries.length > 0 && {
          movieCountries: {
            create: countries.map((countryId: number, index: number) => ({
              countryId,
              isPrimary: index === 0
            }))
          }
        }),

        ...(productionCompanies && productionCompanies.length > 0 && {
          productionCompanies: {
            create: productionCompanies.map((companyId: number, index: number) => ({
              companyId,
              isPrimary: index === 0
            }))
          }
        }),

        ...(distributionCompanies && distributionCompanies.length > 0 && {
          distributionCompanies: {
            create: distributionCompanies.map((companyId: number) => ({
              companyId,
              territory: 'Argentina'
            }))
          }
        }),

        ...(themes && themes.length > 0 && {
          themes: {
            create: themes.map((themeId: number) => ({
              themeId
            }))
          }
        }),

        ...(alternativeTitles && alternativeTitles.length > 0 && {
          alternativeTitles: {
            create: alternativeTitles.map((title: any) => ({
              title: title.title,
              description: title.description || null
            }))
          }
        }),

        ...(links && links.length > 0 && {
          links: {
            create: links.map((link: any) => ({
              type: link.type,
              url: link.url,
              title: link.title || null,
              isActive: link.isActive !== false
            }))
          }
        }),

        ...(screeningVenues && screeningVenues.length > 0 && {
          screenings: {
            create: screeningVenues.map((sv: any) => ({
              venueId: sv.venueId,
              screeningDate: sv.screeningDate ? new Date(sv.screeningDate) : null,
              isPremiere: sv.isPremiere || false,
              isExclusive: sv.isExclusive || false
            }))
          }
        })
      },
      include: {
        genres: {
          include: {
            genre: true
          }
        },
        cast: {
          include: {
            person: true
          }
        },
        crew: {
          include: {
            person: true
          }
        }
      }
    })

    // INVALIDAR CACH√âS de listados despu√©s de crear
    console.log('üóëÔ∏è Invalidando cach√©s de listados tras crear pel√≠cula');
    
    const redisClient = RedisClient.getInstance();
    if (redisClient) {
      try {
        const keys = await redisClient.keys('movies:list:*');
        if (keys.length > 0) {
          await redisClient.del(...keys);
          console.log(`‚úÖ ${keys.length} cach√©s de listados invalidados en Redis`);
        }
      } catch (err) {
        console.error('Error invalidando cach√©s de Redis:', err);
      }
    }
    
    // Limpiar memoria tambi√©n
    let memoryKeysDeleted = 0;
    for (const key of memoryCache.keys()) {
      if (key.startsWith('movies:list:')) {
        memoryCache.delete(key);
        memoryKeysDeleted++;
      }
    }
    if (memoryKeysDeleted > 0) {
      console.log(`‚úÖ ${memoryKeysDeleted} cach√©s de listados invalidados en memoria`);
    }

    return NextResponse.json(movie, { status: 201 })

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.errors },
        { status: 400 }
      )
    }

    console.error('Error creating movie:', error)
    return NextResponse.json(
      { error: 'Error al crear la pel√≠cula' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/movies/[id]/route-debug.ts
// ==================================================
// src/app/api/movies/[id]/route-debug.ts

import { prisma } from '@/lib/prisma'
import { NextResponse } from 'next/server'

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const measurements: any = {}
  const id = parseInt(params.id)
  
  console.log('üîç Starting performance debug for movie ID:', id)
  
  // 1. Medir query b√°sica
  let start = Date.now()
  const movieBasic = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      title: true,
      year: true
    }
  })
  measurements.basicQuery = Date.now() - start
  console.log(`‚úì Basic query: ${measurements.basicQuery}ms`)
  
  // 2. Medir query con g√©neros
  start = Date.now()
  const movieWithGenres = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      title: true,
      genres: {
        select: {
          genre: { select: { id: true, name: true }}
        }
      }
    }
  })
  measurements.withGenres = Date.now() - start
  console.log(`‚úì With genres: ${measurements.withGenres}ms`)
  
  // 3. Medir query con cast (sin person)
  start = Date.now()
  const movieWithCastIds = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      cast: {
        select: {
          id: true,
          personId: true,
          characterName: true
        },
        take: 5
      }
    }
  })
  measurements.withCastIds = Date.now() - start
  console.log(`‚úì With cast IDs only: ${measurements.withCastIds}ms`)
  
  // 4. Medir query con cast + person
  start = Date.now()
  const movieWithCastFull = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      cast: {
        select: {
          id: true,
          person: {
            select: { id: true, firstName: true, lastName: true }
          }
        },
        take: 5
      }
    }
  })
  measurements.withCastAndPerson = Date.now() - start
  console.log(`‚úì With cast + person: ${measurements.withCastAndPerson}ms`)
  
  // 5. Medir query con crew
  start = Date.now()
  const movieWithCrew = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      crew: {
        where: { roleId: 2 },
        select: {
          person: {
            select: { id: true, firstName: true, lastName: true }
          }
        },
        take: 1
      }
    }
  })
  measurements.withCrew = Date.now() - start
  console.log(`‚úì With crew: ${measurements.withCrew}ms`)
  
  // 6. Medir la query completa optimizada
  start = Date.now()
  const movieComplete = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      slug: true,
      title: true,
      year: true,
      releaseYear: true,
      releaseMonth: true,
      releaseDay: true,
      duration: true,
      synopsis: true,
      posterUrl: true,
      
      genres: {
        select: {
          genre: { select: { id: true, name: true }}
        }
      },
      
      cast: {
        where: { isPrincipal: true },
        take: 5,
        select: {
          characterName: true,
          person: {
            select: { id: true, firstName: true, lastName: true }
          }
        }
      },
      
      crew: {
        where: { roleId: 2 },
        take: 1,
        select: {
          person: {
            select: { id: true, firstName: true, lastName: true }
          }
        }
      }
    }
  })
  measurements.completeOptimized = Date.now() - start
  console.log(`‚úì Complete optimized: ${measurements.completeOptimized}ms`)
  
  // 7. Probar con queries separadas
  start = Date.now()
  const movie = await prisma.movie.findUnique({
    where: { id },
    select: {
      id: true,
      slug: true,
      title: true,
      year: true,
      synopsis: true
    }
  })
  
  const genres = await prisma.movieGenre.findMany({
    where: { movieId: id },
    select: {
      genre: { select: { id: true, name: true }}
    }
  })
  
  const cast = await prisma.movieCast.findMany({
    where: { movieId: id, isPrincipal: true },
    take: 5,
    select: {
      characterName: true,
      person: { select: { id: true, firstName: true, lastName: true }}
    }
  })
  measurements.separateQueries = Date.now() - start
  console.log(`‚úì Separate queries: ${measurements.separateQueries}ms`)
  
  // 8. Test de conexi√≥n a DB
  start = Date.now()
  await prisma.$queryRaw`SELECT 1`
  measurements.dbPing = Date.now() - start
  console.log(`‚úì DB ping: ${measurements.dbPing}ms`)
  
  console.log('\nüìä RESUMEN:')
  console.log('================')
  Object.entries(measurements).forEach(([key, value]) => {
    console.log(`${key}: ${value}ms`)
  })
  
  return NextResponse.json({
    measurements,
    analysis: {
      dbLatency: measurements.dbPing,
      joinOverhead: measurements.withCastAndPerson - measurements.withCastIds,
      totalTime: measurements.completeOptimized,
      isSlow: measurements.completeOptimized > 200
    }
  })
}

// ==================================================
// src/app/api/movies/[id]/route.ts
// ==================================================
// ==================================================
// src/app/api/movies/[id]/route.ts - CON ALTERNATIVE_NAME_ID ‚úÖ
// ==================================================
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'
import { movieSchema } from '@/lib/schemas'
import RedisClient from '@/lib/redis'
import { revalidatePath, revalidateTag } from 'next/cache'

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 60 * 60 * 1000; // 1 hora en ms
const REDIS_CACHE_TTL = 3600; // 1 hora en segundos

// GET /api/movies/[id] - Obtener pel√≠cula por ID o slug
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const idOrSlug = params.id
    const isId = /^\d+$/.test(idOrSlug)

    // Generar clave de cach√© √∫nica
    const cacheKey = `movie:${isId ? 'id' : 'slug'}:${idOrSlug}:v1`;

    // 1. Intentar obtener de Redis
    try {
      const redisCached = await RedisClient.get(cacheKey);

      if (redisCached) {
        console.log(`‚úÖ Cache HIT desde Redis para pel√≠cula: ${idOrSlug}`);
        return NextResponse.json(
          JSON.parse(redisCached),
          {
            headers: {
              'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
              'X-Cache': 'HIT',
              'X-Cache-Source': 'redis',
              'X-Movie-Id': idOrSlug
            }
          }
        );
      }
    } catch (redisError) {
      console.error('Redis error (non-fatal):', redisError);
    }

    // 2. Verificar cach√© en memoria como fallback
    const now = Date.now();
    const memoryCached = memoryCache.get(cacheKey);

    if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
      console.log(`‚úÖ Cache HIT desde memoria para pel√≠cula: ${idOrSlug}`);

      // Intentar guardar en Redis para pr√≥ximas requests
      RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), REDIS_CACHE_TTL)
        .catch(err => console.error('Error guardando en Redis:', err));

      return NextResponse.json(memoryCached.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory',
          'X-Movie-Id': idOrSlug
        }
      });
    }

    // 3. No hay cach√©, consultar base de datos
    console.log(`üìÑ Cache MISS - Consultando BD para pel√≠cula: ${idOrSlug}`);

    const movie = await prisma.movie.findUnique({
      where: isId ? { id: parseInt(idOrSlug) } : { slug: idOrSlug },
      select: {
        // Campos b√°sicos de la pel√≠cula
        id: true,
        slug: true,
        title: true,
        year: true,
        releaseYear: true,
        releaseMonth: true,
        releaseDay: true,
        duration: true,
        durationSeconds: true,
        synopsis: true,
        synopsisLocked: true, // ‚úÖ Campo synopsisLocked
        tagline: true,
        notes: true,
        posterUrl: true,
        trailerUrl: true,
        imdbId: true,
        stage: true,
        dataCompleteness: true,
        tipoDuracion: true,
        metaDescription: true,
        metaKeywords: true,
        filmingStartYear: true,
        filmingStartMonth: true,
        filmingStartDay: true,
        filmingEndYear: true,
        filmingEndMonth: true,
        filmingEndDay: true,
        soundType: true,
        rating: true,
        ratingId: true,
        createdAt: true,
        updatedAt: true,

        // Relaciones - solo traer los campos necesarios
        colorType: true,

        genres: {
          select: {
            genre: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          }
        },

        // üÜï Cast con alternativeNameId
        cast: {
          orderBy: { billingOrder: 'asc' },
          select: {
            characterName: true,
            billingOrder: true,
            isPrincipal: true,
            isActor: true,
            notes: true,
            alternativeNameId: true,  // üÜï
            alternativeName: {         // üÜï
              select: {
                id: true,
                fullName: true
              }
            },
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                slug: true,
                photoUrl: true,
                alternativeNames: {     // üÜï Para mostrar opciones en el formulario
                  select: {
                    id: true,
                    fullName: true
                  },
                  orderBy: { createdAt: 'asc' }
                }
              }
            }
          }
        },

        // üÜï Crew con alternativeNameId
        crew: {
          orderBy: { billingOrder: 'asc' },
          select: {
            roleId: true,
            billingOrder: true,
            notes: true,
            alternativeNameId: true,  // üÜï
            alternativeName: {         // üÜï
              select: {
                id: true,
                fullName: true
              }
            },
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                slug: true,
                alternativeNames: {     // üÜï Para mostrar opciones en el formulario
                  select: {
                    id: true,
                    fullName: true
                  },
                  orderBy: { createdAt: 'asc' }
                }
              }
            },
            role: true
          }
        },

        movieCountries: {
          select: {
            location: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            },
            countryId: true,
            isPrimary: true

          }
        },

        productionCompanies: {
          select: {
            company: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },

        distributionCompanies: {
          select: {
            company: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },

        themes: {
          select: {
            theme: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            }
          }
        },

        images: {
          orderBy: { createdAt: 'desc' },
          include: {
            people: {
              include: {
                person: {
                  select: {
                    id: true,
                    firstName: true,
                    lastName: true
                  }
                }
              },
              orderBy: {
                position: 'asc'
              }
            }
          }
        },

        videos: {
          orderBy: { isPrimary: 'desc' }
        },

        awards: {
          include: {
            award: true,
            recipient: true
          }
        },

        links: {
          where: { isActive: true },
          orderBy: { type: 'asc' }
        },

        screenings: {
          include: {
            venue: true
          }
        }
      }
    })

    if (!movie) {
      return NextResponse.json(
        { error: 'Pel√≠cula no encontrada' },
        { status: 404 }
      )
    }

    // 4. Guardar en ambos cach√©s
    // Redis con TTL de 1 hora
    RedisClient.set(cacheKey, JSON.stringify(movie), REDIS_CACHE_TTL)
      .then(saved => {
        if (saved) {
          console.log(`‚úÖ Pel√≠cula ${idOrSlug} guardada en Redis`);
        }
      })
      .catch(err => console.error('Error guardando en Redis:', err));

    // Memoria como fallback
    memoryCache.set(cacheKey, {
      data: movie,
      timestamp: now
    });

    // Limpiar cach√© de memoria viejo (mantener m√°ximo 100 pel√≠culas)
    if (memoryCache.size > 100) {
      const oldestKey = memoryCache.keys().next().value;
      if (oldestKey) {
        memoryCache.delete(oldestKey);
      }
    }

    return NextResponse.json(movie, {
      headers: {
        'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database',
        'X-Movie-Id': idOrSlug
      }
    })
  } catch (error) {
    console.error('Error fetching movie:', error)

    // Intentar servir desde cach√© stale si hay error
    const cacheKey = `movie:${/^\d+$/.test(params.id) ? 'id' : 'slug'}:${params.id}:v1`;
    const staleCache = memoryCache.get(cacheKey);

    if (staleCache) {
      console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
      return NextResponse.json(staleCache.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }

    return NextResponse.json(
      { error: 'Error al obtener la pel√≠cula' },
      { status: 500 }
    )
  }
}

// PUT /api/movies/[id] - Actualizar pel√≠cula
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()

    // Limpiar datos antes de validar
    const cleanedData = {
      ...body,
      ratingId: body.ratingId === 0 ? null : body.ratingId,
      genres: Array.isArray(body.genres)
        ? body.genres.filter((g: any) => g != null && g !== 0 && !isNaN(Number(g)))
        : [],
      countries: Array.isArray(body.countries)
        ? body.countries.filter((c: any) => c != null && c !== 0 && !isNaN(Number(c)))
        : body.countries || [],
      productionCompanies: Array.isArray(body.productionCompanies)
        ? body.productionCompanies.filter((pc: any) => pc != null && pc !== 0 && !isNaN(Number(pc)))
        : [],
      distributionCompanies: Array.isArray(body.distributionCompanies)
        ? body.distributionCompanies.filter((dc: any) => dc != null && dc !== 0 && !isNaN(Number(dc)))
        : [],
      themes: Array.isArray(body.themes)
        ? body.themes.filter((t: any) => t != null && t !== 0 && !isNaN(Number(t)))
        : [],
      metaKeywords: body.metaKeywords
        ? Array.isArray(body.metaKeywords)
          ? body.metaKeywords
          : typeof body.metaKeywords === 'string'
            ? body.metaKeywords.split(',').map((k: string) => k.trim()).filter(Boolean)
            : []
        : []
    };

    // Validar datos
    const validatedData = movieSchema.parse(cleanedData)

    if (validatedData.duration === 0) {
      validatedData.duration = null;
    }
    if (validatedData.durationSeconds === 0) {
      validatedData.durationSeconds = null;
    }

    // Verificar que la pel√≠cula existe y obtener slug para invalidar cach√©
    const existingMovie = await prisma.movie.findUnique({
      where: { id },
      select: { slug: true }
    })

    if (!existingMovie) {
      return NextResponse.json(
        { error: 'Pel√≠cula no encontrada' },
        { status: 404 }
      )
    }

    // Extraer relaciones
    const {
      genres,
      cast,
      crew,
      countries,
      productionCompanies,
      distributionCompanies,
      themes,
      alternativeTitles,
      links,
      screeningVenues,
      ...movieData
    } = validatedData

    // Usar transacci√≥n para actualizar todo
    const movie = await prisma.$transaction(async (tx) => {
      // üîß CORRECCI√ìN CR√çTICA: Extraer synopsisLocked ANTES de crear movieDataClean
      const {
        colorTypeId,
        ratingId,
        releaseYear,
        releaseMonth,
        releaseDay,
        filmingStartYear,
        filmingStartMonth,
        filmingStartDay,
        filmingEndYear,
        filmingEndMonth,
        filmingEndDay,
        metaKeywords,
        synopsisLocked,  // ‚úÖ Extraer synopsisLocked expl√≠citamente
        ...movieDataClean
      } = movieData

      // 1. Actualizar datos b√°sicos de la pel√≠cula
      const updatedMovie = await tx.movie.update({
        where: { id },
        data: {
          ...movieDataClean,
          synopsisLocked: synopsisLocked ?? false, // ‚úÖ Usar variable directa (CORREGIDO)
          metaKeywords: Array.isArray(metaKeywords)
            ? metaKeywords
            : typeof metaKeywords === 'string'
              ? metaKeywords.split(',').map((k: string) => k.trim()).filter(Boolean)
              : [],
          releaseYear: releaseYear !== undefined ? releaseYear : null,
          releaseMonth: releaseMonth !== undefined ? releaseMonth : null,
          releaseDay: releaseDay !== undefined ? releaseDay : null,
          filmingStartYear: filmingStartYear !== undefined ? filmingStartYear : null,
          filmingStartMonth: filmingStartMonth !== undefined ? filmingStartMonth : null,
          filmingStartDay: filmingStartDay !== undefined ? filmingStartDay : null,
          filmingEndYear: filmingEndYear !== undefined ? filmingEndYear : null,
          filmingEndMonth: filmingEndMonth !== undefined ? filmingEndMonth : null,
          filmingEndDay: filmingEndDay !== undefined ? filmingEndDay : null,
          ...(ratingId !== undefined && {
            rating: (ratingId === null || ratingId === 0)
              ? { disconnect: true }
              : { connect: { id: ratingId } }
          }),
          ...(colorTypeId && {
            colorType: { connect: { id: colorTypeId } }
          })
        }
      })

      // 2. Actualizar g√©neros
      if (genres) {
        await tx.movieGenre.deleteMany({ where: { movieId: id } })
        if (genres.length > 0) {
          await tx.movieGenre.createMany({
            data: genres.map((genreId, index) => ({
              movieId: id,
              genreId,
              isPrimary: index === 0
            }))
          })
        }
      }

      // 3. Actualizar cast - üÜï CON alternativeNameId
      if (cast) {
        await tx.movieCast.deleteMany({ where: { movieId: id } })
        if (cast.length > 0) {
          await tx.movieCast.createMany({
            data: cast.map((item, index) => ({
              movieId: id,
              personId: item.personId,
              alternativeNameId: item.alternativeNameId || null,  // üÜï
              characterName: item.characterName || null,
              billingOrder: item.billingOrder || index + 1,
              isPrincipal: item.isPrincipal || false,
              isActor: item.isActor !== undefined ? item.isActor : true,
              notes: item.notes || null
            }))
          })
        }
      }

      // 4. Actualizar crew - üÜï CON alternativeNameId
      if (crew) {
        await tx.movieCrew.deleteMany({ where: { movieId: id } })
        if (crew.length > 0) {
          await tx.movieCrew.createMany({
            data: crew.map((item, index) => ({
              movieId: id,
              personId: item.personId,
              alternativeNameId: item.alternativeNameId || null,  // üÜï
              role: item.role,
              roleId: item.roleId,
              billingOrder: item.billingOrder || index + 1,
              notes: item.notes || null
            }))
          })
        }
      }

      // 5. Actualizar pa√≠ses
      if (countries) {
        await tx.movieCountry.deleteMany({ where: { movieId: id } })
        if (countries.length > 0) {
          await tx.movieCountry.createMany({
            data: countries.map((countryId, index) => ({
              movieId: id,
              countryId,
              isPrimary: index === 0
            }))
          })
        }
      }

      // 6. Actualizar productoras
      if (productionCompanies) {
        await tx.movieProductionCompany.deleteMany({ where: { movieId: id } })
        if (productionCompanies.length > 0) {
          await tx.movieProductionCompany.createMany({
            data: productionCompanies.map((companyId, index) => ({
              movieId: id,
              companyId,
              isPrimary: index === 0
            }))
          })
        }
      }

      // 7. Actualizar distribuidoras
      if (distributionCompanies) {
        await tx.movieDistributionCompany.deleteMany({ where: { movieId: id } })
        if (distributionCompanies.length > 0) {
          await tx.movieDistributionCompany.createMany({
            data: distributionCompanies.map(companyId => ({
              movieId: id,
              companyId,
              territory: 'Argentina'
            }))
          })
        }
      }

      // 8. Actualizar temas
      if (themes) {
        await tx.movieTheme.deleteMany({ where: { movieId: id } })
        if (themes.length > 0) {
          await tx.movieTheme.createMany({
            data: themes.map(themeId => ({
              movieId: id,
              themeId
            }))
          })
        }
      }

      // 9. Actualizar t√≠tulos alternativos
      if (alternativeTitles !== undefined) {
        await tx.movieAlternativeTitle.deleteMany({ where: { movieId: id } })
        if (alternativeTitles && alternativeTitles.length > 0) {
          await tx.movieAlternativeTitle.createMany({
            data: alternativeTitles.map(title => ({
              movieId: id,
              title: title.title,
              description: title.description || null
            }))
          })
        }
      }

      // 10. Actualizar links oficiales
      if (links !== undefined) {
        await tx.movieLink.deleteMany({ where: { movieId: id } })
        if (links && links.length > 0) {
          await tx.movieLink.createMany({
            data: links.map((link: any) => ({
              movieId: id,
              type: link.type,
              url: link.url,
              title: link.title || null,
              isActive: link.isActive !== false
            }))
          })
        }
      }

      // 11. Actualizar screening venues
      if (screeningVenues !== undefined) {
        await tx.movieScreening.deleteMany({ where: { movieId: id } })
        if (screeningVenues && screeningVenues.length > 0) {
          await tx.movieScreening.createMany({
            data: screeningVenues.map((sv: any) => ({
              movieId: id,
              venueId: sv.venueId,
              screeningDate: sv.screeningDate ? new Date(sv.screeningDate) : null,
              isPremiere: sv.isPremiere || false,
              isExclusive: sv.isExclusive || false
            }))
          })
        }
      }

      // 12. Retornar la pel√≠cula actualizada con todas las relaciones
      return await tx.movie.findUnique({
        where: { id },
        include: {
          genres: {
            include: {
              genre: true
            }
          },
          cast: {
            include: {
              person: true,
              alternativeName: true  // üÜï
            }
          },
          crew: {
            include: {
              person: true,
              alternativeName: true  // üÜï
            }
          },
          themes: {
            include: {
              theme: true
            }
          },
          movieCountries: {
            include: {
              location: true
            }
          },
          productionCompanies: {
            include: {
              company: true
            }
          },
          distributionCompanies: {
            include: {
              company: true
            }
          },
          links: true,
          screenings: {
            include: {
              venue: true
            }
          },
          colorType: true,
        }
      })
    }, {
      maxWait: 10000,
      timeout: 30000,
    })

    // ‚≠ê‚≠ê‚≠ê INVALIDACI√ìN COMPLETA DE CACH√âS ‚≠ê‚≠ê‚≠ê
    console.log('üóëÔ∏è Invalidando cach√©s para pel√≠cula actualizada');

    // 1. Invalidar Redis
    const cacheKeysToInvalidate = [
      `movie:id:${id}:v1`,
      `movie:slug:${existingMovie.slug}:v1`,
      'home-feed:movies:v1'
    ];

    await Promise.all(
      cacheKeysToInvalidate.map(key =>
        RedisClient.del(key).catch(err =>
          console.error(`Error invalidando Redis key ${key}:`, err)
        )
      )
    );

    // 2. Invalidar cach√© en memoria
    cacheKeysToInvalidate.forEach(key => memoryCache.delete(key));

    // 3. Invalidar cach√© de Next.js (por si acaso, aunque ya no lo usamos principalmente)
    try {
      revalidateTag('movies');
      revalidateTag(`movie-${existingMovie.slug}`);
      revalidatePath(`/pelicula/${existingMovie.slug}`);
      revalidatePath('/');
      revalidatePath('/listados/peliculas');

      console.log(`‚úÖ Next.js cache invalidado para: /pelicula/${existingMovie.slug}`);
    } catch (revalidateError) {
      console.log('‚ÑπÔ∏è Next.js revalidation skipped (using Redis cache primarily)');
    }

    console.log(`‚úÖ Todos los cach√©s invalidados para pel√≠cula: ${existingMovie.slug}`);

    return NextResponse.json(movie)
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.log('=== ERRORES DE VALIDACI√ìN ZOD ===')
      console.log(JSON.stringify(error.errors, null, 2))
      console.log('=================================')
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.errors },
        { status: 400 }
      )
    }

    console.error('Error updating movie:', error)
    return NextResponse.json(
      { error: 'Error al actualizar la pel√≠cula' },
      { status: 500 }
    )
  }
}

// DELETE /api/movies/[id] - Eliminar pel√≠cula
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)

    // Verificar que la pel√≠cula existe y obtener slug para invalidar cach√©
    const movie = await prisma.movie.findUnique({
      where: { id },
      select: { slug: true }
    })

    if (!movie) {
      return NextResponse.json(
        { error: 'Pel√≠cula no encontrada' },
        { status: 404 }
      )
    }

    // Eliminar pel√≠cula (las relaciones se eliminan en cascada)
    await prisma.movie.delete({
      where: { id }
    })

    // ‚≠ê INVALIDAR CACH√âS despu√©s de eliminar ‚≠ê
    console.log('üóëÔ∏è Invalidando cach√©s para pel√≠cula eliminada');

    // 1. Invalidar Redis
    const cacheKeysToInvalidate = [
      `movie:id:${id}:v1`,
      `movie:slug:${movie.slug}:v1`,
      'home-feed:movies:v1'
    ];

    await Promise.all(
      cacheKeysToInvalidate.map(key =>
        RedisClient.del(key).catch(err =>
          console.error(`Error invalidando Redis key ${key}:`, err)
        )
      )
    );

    // 2. Invalidar en memoria
    cacheKeysToInvalidate.forEach(key => memoryCache.delete(key));

    // 3. Invalidar cach√© de Next.js
    try {
      revalidateTag('movies');
      revalidateTag(`movie-${movie.slug}`);
      revalidatePath(`/pelicula/${movie.slug}`);
      revalidatePath('/');
      revalidatePath('/listados/peliculas');

      console.log(`‚úÖ Next.js cache invalidado para pel√≠cula eliminada: ${movie.slug}`);
    } catch (revalidateError) {
      console.log('‚ÑπÔ∏è Next.js revalidation skipped (using Redis cache primarily)');
    }

    console.log(`‚úÖ Todos los cach√©s invalidados tras eliminar: ${movie.slug}`);

    return NextResponse.json(
      { message: 'Pel√≠cula eliminada exitosamente' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting movie:', error)
    return NextResponse.json(
      { error: 'Error al eliminar la pel√≠cula' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/people/death-years/route.ts
// ==================================================
// src/app/api/people/death-years/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import RedisClient from '@/lib/redis';

// Esta ruta debe ser din√°mica
export const dynamic = 'force-dynamic';

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 horas en ms

/**
 * GET /api/people/death-years
 * Obtiene todos los a√±os √∫nicos en que hay personas fallecidas
 * Retorna array ordenado descendente (m√°s reciente primero)
 * 
 * CACH√â: 24 horas (los a√±os hist√≥ricos no cambian)
 */
export async function GET() {
  const cacheKey = 'people:death-years:v1';
  const redisTTL = 86400; // 24 horas
  const now = Date.now();

  try {
    // 1. Intentar obtener de Redis
    try {
      const redisCached = await RedisClient.get(cacheKey);
      
      if (redisCached) {
        console.log('‚úÖ Cache HIT desde Redis para death-years');
        return NextResponse.json(
          JSON.parse(redisCached),
          {
            headers: {
              'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
              'X-Cache': 'HIT',
              'X-Cache-Source': 'redis'
            }
          }
        );
      }
    } catch (redisError) {
      console.error('Redis error (non-fatal):', redisError);
    }
    
    // 2. Verificar cach√© en memoria como fallback
    const memoryCached = memoryCache.get(cacheKey);
    
    if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
      console.log('‚úÖ Cache HIT desde memoria para death-years');
      
      // Intentar guardar en Redis para pr√≥ximas requests
      RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), redisTTL)
        .catch(err => console.error('Error guardando en Redis:', err));
      
      return NextResponse.json(memoryCached.data, {
        headers: {
          'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory'
        }
      });
    }
    
    // 3. No hay cach√©, consultar base de datos
    console.log('üîÑ Cache MISS - Consultando BD para death-years');
    
    // Obtener a√±os √∫nicos de defunci√≥n
    const result = await prisma.person.findMany({
      where: {
        deathYear: {
          not: null
        }
      },
      select: {
        deathYear: true
      },
      distinct: ['deathYear'],
      orderBy: {
        deathYear: 'desc'
      }
    });

    // Extraer solo los a√±os y filtrar nulls
    const years = result
      .map(r => r.deathYear)
      .filter((year): year is number => year !== null);

    const response = {
      years,
      count: years.length
    };
    
    // 4. Guardar en ambos cach√©s
    RedisClient.set(cacheKey, JSON.stringify(response), redisTTL)
      .then(saved => {
        if (saved) {
          console.log(`‚úÖ Death-years guardado en Redis con TTL ${redisTTL}s (24h)`);
        }
      })
      .catch(err => console.error('Error guardando en Redis:', err));
    
    memoryCache.set(cacheKey, {
      data: response,
      timestamp: now
    });

    return NextResponse.json(response, {
      headers: {
        'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database'
      }
    });

  } catch (error) {
    console.error('Error fetching death years:', error);
    
    // Intentar servir desde cach√© stale si hay error
    const staleCache = memoryCache.get(cacheKey);
    
    if (staleCache) {
      console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
      return NextResponse.json(staleCache.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }
    
    return NextResponse.json(
      { error: 'Error al obtener a√±os de defunci√≥n' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/filters/route.ts
// ==================================================
// src/app/api/people/filters/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Esta ruta debe ser din√°mica para evitar errores en build
export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    // Ejecutar todas las consultas en paralelo
    const [
      birthLocations,
      deathLocations,
      nationalities,
      roles,
      yearRanges
    ] = await Promise.all([
      // Ubicaciones de nacimiento con path completo y conteo incluyendo descendientes
      prisma.$queryRaw<Array<{ id: number; name: string; full_path: string; count: number }>>`
        WITH RECURSIVE 
        -- Primero: construir el path completo de cada ubicaci√≥n
        location_path AS (
          SELECT 
            l.id,
            l.name,
            l.parent_id,
            l.name::text as path
          FROM locations l
          
          UNION ALL
          
          SELECT 
            lp.id,
            lp.name,
            l.parent_id,
            lp.path || ', ' || l.name
          FROM location_path lp
          INNER JOIN locations l ON lp.parent_id = l.id
        ),
        -- Segundo: obtener todos los descendientes de cada ubicaci√≥n
        location_descendants AS (
          SELECT 
            id as ancestor_id,
            id as descendant_id
          FROM locations
          
          UNION ALL
          
          SELECT 
            ld.ancestor_id,
            l.id as descendant_id
          FROM location_descendants ld
          INNER JOIN locations l ON l.parent_id = ld.descendant_id
        ),
        -- Tercero: contar personas nacidas en cada ubicaci√≥n + sus descendientes
        location_counts AS (
          SELECT 
            ld.ancestor_id as location_id,
            COUNT(DISTINCT p.id) as person_count
          FROM location_descendants ld
          INNER JOIN people p ON p.birth_location_id = ld.descendant_id AND p.is_active = true
          GROUP BY ld.ancestor_id
        ),
        -- Cuarto: obtener el path m√°s largo para cada ubicaci√≥n
        full_paths AS (
          SELECT DISTINCT ON (id)
            id,
            path as full_path
          FROM location_path
          ORDER BY id, LENGTH(path) DESC
        )
        SELECT 
          l.id,
          l.name,
          fp.full_path,
          COALESCE(lc.person_count, 0)::int as count
        FROM locations l
        INNER JOIN full_paths fp ON fp.id = l.id
        LEFT JOIN location_counts lc ON lc.location_id = l.id
        WHERE COALESCE(lc.person_count, 0) > 0
        ORDER BY LOWER(unaccent(l.name)) ASC
      `,
      
      // Ubicaciones de muerte con path completo y conteo incluyendo descendientes
      prisma.$queryRaw<Array<{ id: number; name: string; full_path: string; count: number }>>`
        WITH RECURSIVE 
        -- Primero: construir el path completo de cada ubicaci√≥n
        location_path AS (
          SELECT 
            l.id,
            l.name,
            l.parent_id,
            l.name::text as path
          FROM locations l
          
          UNION ALL
          
          SELECT 
            lp.id,
            lp.name,
            l.parent_id,
            lp.path || ', ' || l.name
          FROM location_path lp
          INNER JOIN locations l ON lp.parent_id = l.id
        ),
        -- Segundo: obtener todos los descendientes de cada ubicaci√≥n
        location_descendants AS (
          SELECT 
            id as ancestor_id,
            id as descendant_id
          FROM locations
          
          UNION ALL
          
          SELECT 
            ld.ancestor_id,
            l.id as descendant_id
          FROM location_descendants ld
          INNER JOIN locations l ON l.parent_id = ld.descendant_id
        ),
        -- Tercero: contar personas fallecidas en cada ubicaci√≥n + sus descendientes
        location_counts AS (
          SELECT 
            ld.ancestor_id as location_id,
            COUNT(DISTINCT p.id) as person_count
          FROM location_descendants ld
          INNER JOIN people p ON p.death_location_id = ld.descendant_id AND p.is_active = true
          GROUP BY ld.ancestor_id
        ),
        -- Cuarto: obtener el path m√°s largo para cada ubicaci√≥n
        full_paths AS (
          SELECT DISTINCT ON (id)
            id,
            path as full_path
          FROM location_path
          ORDER BY id, LENGTH(path) DESC
        )
        SELECT 
          l.id,
          l.name,
          fp.full_path,
          COALESCE(lc.person_count, 0)::int as count
        FROM locations l
        INNER JOIN full_paths fp ON fp.id = l.id
        LEFT JOIN location_counts lc ON lc.location_id = l.id
        WHERE COALESCE(lc.person_count, 0) > 0
        ORDER BY LOWER(unaccent(l.name)) ASC
      `,
      
      // Nacionalidades (pa√≠ses con personas)
      prisma.$queryRaw<Array<{ id: number; name: string; count: number }>>`
        SELECT 
          l.id,
          l.name,
          COUNT(DISTINCT pn.person_id)::int as count
        FROM locations l
        INNER JOIN person_nationalities pn ON pn.location_id = l.id
        GROUP BY l.id, l.name
        ORDER BY LOWER(unaccent(l.name)) ASC
      `,
      
      // Roles t√©cnicos (de la tabla roles)
      prisma.$queryRaw<Array<{ id: number; name: string; department: string; count: number }>>`
        SELECT 
          r.id,
          r.name,
          r.department,
          COUNT(DISTINCT mc.person_id)::int as count
        FROM roles r
        INNER JOIN movie_crew mc ON mc.role_id = r.id
        WHERE r.is_active = true
        GROUP BY r.id, r.name, r.department
        HAVING COUNT(DISTINCT mc.person_id) > 0
        ORDER BY count DESC
      `,
      
      // Rangos de a√±os
      prisma.$queryRaw<Array<{
        birth_year_min: number | null;
        birth_year_max: number | null;
        death_year_min: number | null;
        death_year_max: number | null;
      }>>`
        SELECT 
          MIN(birth_year) as birth_year_min,
          MAX(birth_year) as birth_year_max,
          MIN(death_year) as death_year_min,
          MAX(death_year) as death_year_max
        FROM people
        WHERE is_active = true
      `
    ]);

    // Contar actores (personas en movie_cast con is_actor = true)
    const actorCount = await prisma.$queryRaw<Array<{ count: number }>>`
      SELECT COUNT(DISTINCT person_id)::int as count
      FROM movie_cast
      WHERE is_actor = true
    `;

    // Contar apariciones como s√≠ mismo (personas en movie_cast con is_actor = false)
    const selfCount = await prisma.$queryRaw<Array<{ count: number }>>`
      SELECT COUNT(DISTINCT person_id)::int as count
      FROM movie_cast
      WHERE is_actor = false
    `;

    // Formatear respuesta
    const response = {
      birthLocations: birthLocations.map(loc => ({
        id: loc.id,
        name: loc.name,
        fullPath: loc.full_path,
        count: loc.count
      })),
      
      deathLocations: deathLocations.map(loc => ({
        id: loc.id,
        name: loc.name,
        fullPath: loc.full_path,
        count: loc.count
      })),
      
      nationalities: nationalities.map(nat => ({
        id: nat.id,
        name: nat.name,
        count: nat.count
      })),
      
      roles: [
        // Actor/Actriz como primera opci√≥n especial
        {
          id: 'ACTOR',
          name: 'Actor / Actriz',
          department: 'ACTUACION',
          isActor: true,
          count: actorCount[0]?.count || 0
        },
        // Apariciones como s√≠ mismo/a
        {
          id: 'SELF',
          name: 'Como s√≠ mismo/a',
          department: 'ACTUACION',
          isActor: false,
          count: selfCount[0]?.count || 0
        },
        // Luego los roles t√©cnicos
        ...roles.map(role => ({
          id: role.id,
          name: role.name,
          department: role.department,
          isActor: false,
          count: role.count
        }))
      ],
      
      years: {
        birthYearMin: yearRanges[0]?.birth_year_min || null,
        birthYearMax: yearRanges[0]?.birth_year_max || null,
        deathYearMin: yearRanges[0]?.death_year_min || null,
        deathYearMax: yearRanges[0]?.death_year_max || null
      }
    };

    return NextResponse.json(response, {
      headers: {
        // Cachear por 1 hora ya que estos datos no cambian frecuentemente
        'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200'
      }
    });
    
  } catch (error) {
    console.error('Error fetching filter options:', error);
    return NextResponse.json(
      { message: 'Error al obtener opciones de filtros' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/list/route.ts
// ==================================================
// src/app/api/people/list/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { Prisma } from '@prisma/client';

// Esta ruta usa searchParams, debe ser din√°mica
export const dynamic = 'force-dynamic';

/**
 * Obtiene todos los IDs de ubicaciones descendientes (hijos, nietos, etc.) de una ubicaci√≥n dada,
 * incluyendo la ubicaci√≥n original.
 */
async function getLocationDescendantIds(locationId: number): Promise<number[]> {
  const descendants = await prisma.$queryRaw<Array<{ id: number }>>`
    WITH RECURSIVE location_descendants AS (
      -- Caso base: la ubicaci√≥n seleccionada
      SELECT id
      FROM locations
      WHERE id = ${locationId}
      
      UNION ALL
      
      -- Caso recursivo: todos los hijos
      SELECT l.id
      FROM locations l
      INNER JOIN location_descendants ld ON l.parent_id = ld.id
    )
    SELECT id FROM location_descendants
  `;
  
  return descendants.map(d => d.id);
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    
    // Par√°metros de filtrado
    const search = searchParams.get('search');
    const gender = searchParams.get('gender');
    const birthLocationId = searchParams.get('birthLocationId');
    const deathLocationId = searchParams.get('deathLocationId');
    const nationalityId = searchParams.get('nationalityId');
    const roleId = searchParams.get('roleId');
    const birthYearFrom = searchParams.get('birthYearFrom');
    const birthYearTo = searchParams.get('birthYearTo');
    const deathYearFrom = searchParams.get('deathYearFrom');
    const deathYearTo = searchParams.get('deathYearTo');
    
    // Par√°metros de ordenamiento y paginaci√≥n
    const sortBy = searchParams.get('sortBy') || 'id';
    const sortOrder = searchParams.get('sortOrder') || 'desc';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '60');
    const skip = (page - 1) * limit;

    // Obtener IDs de ubicaciones descendientes si hay filtros de ubicaci√≥n
    let birthLocationIds: number[] = [];
    let deathLocationIds: number[] = [];
    
    if (birthLocationId) {
      birthLocationIds = await getLocationDescendantIds(parseInt(birthLocationId));
    }
    if (deathLocationId) {
      deathLocationIds = await getLocationDescendantIds(parseInt(deathLocationId));
    }

    // Construir WHERE clause
    const where: Prisma.PersonWhereInput = {
      isActive: true
    };

    // Filtro de b√∫squeda por nombre
    if (search && search.trim().length >= 2) {
      const searchTerms = search.trim().split(/\s+/);
      
      if (searchTerms.length === 1) {
        where.OR = [
          { firstName: { contains: search, mode: 'insensitive' } },
          { lastName: { contains: search, mode: 'insensitive' } },
          { realName: { contains: search, mode: 'insensitive' } },
        ];
      } else {
        where.OR = [
          { realName: { contains: search, mode: 'insensitive' } },
          {
            AND: searchTerms.map(term => ({
              OR: [
                { firstName: { contains: term, mode: 'insensitive' } },
                { lastName: { contains: term, mode: 'insensitive' } },
              ]
            }))
          }
        ];
      }
    }

    // Filtro de g√©nero
    if (gender === 'MALE' || gender === 'FEMALE' || gender === 'OTHER') {
      where.gender = gender;
    }

    // Filtro de ubicaci√≥n de nacimiento (ahora incluye descendientes)
    if (birthLocationIds.length > 0) {
      where.birthLocationId = { in: birthLocationIds };
    }

    // Filtro de ubicaci√≥n de muerte (ahora incluye descendientes)
    if (deathLocationIds.length > 0) {
      where.deathLocationId = { in: deathLocationIds };
    }

    // Filtro de nacionalidad
    if (nationalityId) {
      where.nationalities = {
        some: {
          locationId: parseInt(nationalityId)
        }
      };
    }

    // Filtro de rol (Actor, Como s√≠ mismo, o rol t√©cnico)
    if (roleId) {
      if (roleId === 'ACTOR') {
        // Actuaciones reales (is_actor = true)
        where.castRoles = {
          some: {
            isActor: true
          }
        };
      } else if (roleId === 'SELF') {
        // Apariciones como s√≠ mismo (is_actor = false)
        where.castRoles = {
          some: {
            isActor: false
          }
        };
      } else {
        // Roles t√©cnicos
        where.crewRoles = {
          some: {
            roleId: parseInt(roleId)
          }
        };
      }
    }

    // Filtro de rango de a√±o de nacimiento
    if (birthYearFrom || birthYearTo) {
      where.birthYear = {};
      if (birthYearFrom) {
        where.birthYear.gte = parseInt(birthYearFrom);
      }
      if (birthYearTo) {
        where.birthYear.lte = parseInt(birthYearTo);
      }
    }

    // Filtro de rango de a√±o de muerte
    if (deathYearFrom || deathYearTo) {
      where.deathYear = {};
      if (deathYearFrom) {
        where.deathYear.gte = parseInt(deathYearFrom);
      }
      if (deathYearTo) {
        where.deathYear.lte = parseInt(deathYearTo);
      }
    }

    // Si ordenamos por fecha de nacimiento, excluir personas sin fecha de nacimiento
    if (sortBy === 'birthDate') {
      where.birthYear = where.birthYear || {};
      where.birthYear.not = null;
    }

    // Si ordenamos por fecha de muerte, excluir personas sin fecha de muerte
    if (sortBy === 'deathDate') {
      where.deathYear = where.deathYear || {};
      where.deathYear.not = null;
    }

    // Construir filtros SQL para queries raw
    const buildWhereClause = () => {
      const conditions: Prisma.Sql[] = [Prisma.sql`p.is_active = true`];
      
      // Filtro de ubicaci√≥n de nacimiento (con descendientes)
      if (birthLocationIds.length > 0) {
        conditions.push(Prisma.sql`p.birth_location_id = ANY(${birthLocationIds})`);
      }
      // Filtro de ubicaci√≥n de muerte (con descendientes)
      if (deathLocationIds.length > 0) {
        conditions.push(Prisma.sql`p.death_location_id = ANY(${deathLocationIds})`);
      }
      if (gender) {
        conditions.push(Prisma.sql`p.gender = ${gender}::"Gender"`);
      }
      if (birthYearFrom) {
        conditions.push(Prisma.sql`p.birth_year >= ${parseInt(birthYearFrom)}`);
      }
      if (birthYearTo) {
        conditions.push(Prisma.sql`p.birth_year <= ${parseInt(birthYearTo)}`);
      }
      if (deathYearFrom) {
        conditions.push(Prisma.sql`p.death_year >= ${parseInt(deathYearFrom)}`);
      }
      if (deathYearTo) {
        conditions.push(Prisma.sql`p.death_year <= ${parseInt(deathYearTo)}`);
      }
      if (nationalityId) {
        conditions.push(Prisma.sql`EXISTS (SELECT 1 FROM person_nationalities pn WHERE pn.person_id = p.id AND pn.location_id = ${parseInt(nationalityId)})`);
      }
      if (roleId === 'ACTOR') {
        // Actuaciones reales (is_actor = true)
        conditions.push(Prisma.sql`EXISTS (SELECT 1 FROM movie_cast mc WHERE mc.person_id = p.id AND mc.is_actor = true)`);
      }
      if (roleId === 'SELF') {
        // Apariciones como s√≠ mismo (is_actor = false)
        conditions.push(Prisma.sql`EXISTS (SELECT 1 FROM movie_cast mc WHERE mc.person_id = p.id AND mc.is_actor = false)`);
      }
      if (roleId && roleId !== 'ACTOR' && roleId !== 'SELF') {
        // Roles t√©cnicos
        conditions.push(Prisma.sql`EXISTS (SELECT 1 FROM movie_crew mcr WHERE mcr.person_id = p.id AND mcr.role_id = ${parseInt(roleId)})`);
      }
      if (sortBy === 'birthDate') {
        conditions.push(Prisma.sql`p.birth_year IS NOT NULL`);
      }
      if (sortBy === 'deathDate') {
        conditions.push(Prisma.sql`p.death_year IS NOT NULL`);
      }
      // B√∫squeda por nombre
      if (search && search.trim().length >= 2) {
        const searchTerm = `%${search.trim()}%`;
        conditions.push(Prisma.sql`(
          unaccent(p.first_name) ILIKE unaccent(${searchTerm}) OR
          unaccent(p.last_name) ILIKE unaccent(${searchTerm}) OR
          unaccent(p.real_name) ILIKE unaccent(${searchTerm})
        )`);
      }
      
      return Prisma.sql`WHERE ${Prisma.join(conditions, ' AND ')}`;
    };

    // Si el ordenamiento es alfab√©tico, usar query raw con unaccent
    if (sortBy === 'lastName') {
      const whereClause = buildWhereClause();
      const orderDirection = sortOrder === 'desc' ? Prisma.sql`DESC` : Prisma.sql`ASC`;
      
      const peopleIds = await prisma.$queryRaw<Array<{ id: number }>>`
        SELECT p.id
        FROM people p
        ${whereClause}
        ORDER BY LOWER(unaccent(COALESCE(p.last_name, ''))) ${orderDirection}, 
                 LOWER(unaccent(COALESCE(p.first_name, ''))) ${orderDirection},
                 p.id DESC
        LIMIT ${limit}
        OFFSET ${skip}
      `;

      const personIds = peopleIds.map(p => p.id);
      
      if (personIds.length === 0) {
        return NextResponse.json({
          data: [],
          totalCount: 0,
          page,
          totalPages: 0,
          hasMore: false
        });
      }

      const people = await prisma.person.findMany({
        where: { id: { in: personIds } },
        include: {
          nationalities: {
            include: { location: true }
          },
          birthLocation: {
            include: { parent: true }
          },
          deathLocation: {
            include: { parent: true }
          }
        }
      });

      // Mantener el orden del query
      const orderedPeople = personIds.map(id => people.find(p => p.id === id)!).filter(Boolean);
      const peopleWithMovies = await addFeaturedMovies(orderedPeople);
      const totalCount = await prisma.person.count({ where });
      const totalPages = Math.ceil(totalCount / limit);

      return NextResponse.json({
        data: peopleWithMovies,
        totalCount,
        page,
        totalPages,
        hasMore: page < totalPages
      });
    }

    // Si el ordenamiento es por cantidad de pel√≠culas
    if (sortBy === 'movieCount') {
      const whereClause = buildWhereClause();
      const orderDirection = sortOrder === 'desc' ? Prisma.sql`DESC` : Prisma.sql`ASC`;
      
      const peopleWithMovieCount = await prisma.$queryRaw<Array<{ id: number; movie_count: number }>>`
        SELECT 
          p.id,
          (
            SELECT COUNT(DISTINCT movie_id) FROM (
              SELECT movie_id FROM movie_cast WHERE person_id = p.id
              UNION
              SELECT movie_id FROM movie_crew WHERE person_id = p.id
            ) all_movies
          )::int as movie_count
        FROM people p
        ${whereClause}
        ORDER BY movie_count ${orderDirection}, p.id DESC
        LIMIT ${limit}
        OFFSET ${skip}
      `;

      const personIds = peopleWithMovieCount.map(p => p.id);
      
      if (personIds.length === 0) {
        return NextResponse.json({
          data: [],
          totalCount: 0,
          page,
          totalPages: 0,
          hasMore: false
        });
      }

      const people = await prisma.person.findMany({
        where: { id: { in: personIds } },
        include: {
          nationalities: {
            include: { location: true }
          },
          birthLocation: {
            include: { parent: true }
          },
          deathLocation: {
            include: { parent: true }
          }
        }
      });

      const orderedPeople = personIds.map(id => people.find(p => p.id === id)!).filter(Boolean);
      const peopleWithMovies = await addFeaturedMovies(orderedPeople);
      const totalCount = await prisma.person.count({ where });
      const totalPages = Math.ceil(totalCount / limit);

      return NextResponse.json({
        data: peopleWithMovies,
        totalCount,
        page,
        totalPages,
        hasMore: page < totalPages
      });
    }

    // Query normal para id, birthDate, deathDate
    let orderBy: Prisma.PersonOrderByWithRelationInput | Prisma.PersonOrderByWithRelationInput[];
    
    switch (sortBy) {
      case 'birthDate':
        orderBy = [
          { birthYear: sortOrder as Prisma.SortOrder },
          { birthMonth: sortOrder as Prisma.SortOrder },
          { birthDay: sortOrder as Prisma.SortOrder }
        ];
        break;
      case 'deathDate':
        orderBy = [
          { deathYear: sortOrder as Prisma.SortOrder },
          { deathMonth: sortOrder as Prisma.SortOrder },
          { deathDay: sortOrder as Prisma.SortOrder }
        ];
        break;
      case 'id':
      default:
        orderBy = { id: sortOrder as Prisma.SortOrder };
        break;
    }

    const [people, totalCount] = await Promise.all([
      prisma.person.findMany({
        where,
        include: {
          nationalities: {
            include: { location: true }
          },
          birthLocation: {
            include: { parent: true }
          },
          deathLocation: {
            include: { parent: true }
          }
        },
        orderBy,
        skip,
        take: limit
      }),
      prisma.person.count({ where })
    ]);

    const peopleWithMovies = await addFeaturedMovies(people);
    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      data: peopleWithMovies,
      totalCount,
      page,
      totalPages,
      hasMore: page < totalPages
    });

  } catch (error) {
    console.error('Error fetching people list:', error);
    return NextResponse.json(
      { message: 'Error al obtener listado de personas' },
      { status: 500 }
    );
  }
}

/**
 * Agrega la pel√≠cula destacada (m√°s reciente) y conteo correcto a cada persona
 */
async function addFeaturedMovies(people: any[]): Promise<any[]> {
  if (people.length === 0) return [];

  const personIds = people.map(p => p.id);

  // Obtener paths completos de ubicaciones de nacimiento y muerte
  const locationPaths = await prisma.$queryRaw<Array<{
    person_id: number;
    birth_location_path: string | null;
    death_location_path: string | null;
  }>>`
    WITH RECURSIVE location_tree AS (
      SELECT 
        id,
        name,
        parent_id,
        name::text as path
      FROM locations
      
      UNION ALL
      
      SELECT 
        lt.id,
        lt.name,
        l.parent_id,
        lt.path || ', ' || l.name
      FROM location_tree lt
      INNER JOIN locations l ON lt.parent_id = l.id
    ),
    full_paths AS (
      SELECT 
        id,
        (SELECT path FROM location_tree WHERE id = lt.id ORDER BY LENGTH(path) DESC LIMIT 1) as full_path
      FROM location_tree lt
      GROUP BY id
    )
    SELECT 
      p.id as person_id,
      bp.full_path as birth_location_path,
      dp.full_path as death_location_path
    FROM people p
    LEFT JOIN full_paths bp ON p.birth_location_id = bp.id
    LEFT JOIN full_paths dp ON p.death_location_id = dp.id
    WHERE p.id = ANY(${personIds})
  `;

  const locationPathMap = new Map(locationPaths.map(lp => [
    lp.person_id, 
    { birthPath: lp.birth_location_path, deathPath: lp.death_location_path }
  ]));

  const castMovies = await prisma.$queryRaw<Array<{
    person_id: number;
    movie_id: number;
    movie_slug: string;
    movie_title: string;
    movie_year: number | null;
  }>>`
    SELECT DISTINCT ON (mc.person_id)
      mc.person_id,
      m.id as movie_id,
      m.slug as movie_slug,
      m.title as movie_title,
      m.year as movie_year
    FROM movie_cast mc
    INNER JOIN movies m ON m.id = mc.movie_id
    WHERE mc.person_id = ANY(${personIds})
    ORDER BY mc.person_id, m.year DESC NULLS LAST, m.id DESC
  `;

  const crewMovies = await prisma.$queryRaw<Array<{
    person_id: number;
    movie_id: number;
    movie_slug: string;
    movie_title: string;
    movie_year: number | null;
    role_name: string;
  }>>`
    SELECT DISTINCT ON (mcr.person_id)
      mcr.person_id,
      m.id as movie_id,
      m.slug as movie_slug,
      m.title as movie_title,
      m.year as movie_year,
      r.name as role_name
    FROM movie_crew mcr
    INNER JOIN movies m ON m.id = mcr.movie_id
    INNER JOIN roles r ON r.id = mcr.role_id
    WHERE mcr.person_id = ANY(${personIds})
    ORDER BY mcr.person_id, m.year DESC NULLS LAST, m.id DESC
  `;

  const movieCounts = await prisma.$queryRaw<Array<{ person_id: number; movie_count: number }>>`
    SELECT 
      person_id,
      COUNT(DISTINCT movie_id)::int as movie_count
    FROM (
      SELECT person_id, movie_id FROM movie_cast WHERE person_id = ANY(${personIds})
      UNION ALL
      SELECT person_id, movie_id FROM movie_crew WHERE person_id = ANY(${personIds})
    ) all_roles
    GROUP BY person_id
  `;

  const castMap = new Map(castMovies.map(c => [c.person_id, c]));
  const crewMap = new Map(crewMovies.map(c => [c.person_id, c]));
  const movieCountMap = new Map(movieCounts.map(c => [c.person_id, c.movie_count]));

  return people.map(person => {
    const castMovie = castMap.get(person.id);
    const crewMovie = crewMap.get(person.id);
    const paths = locationPathMap.get(person.id);

    let featuredMovie = null;

    if (castMovie && crewMovie) {
      const castYear = castMovie.movie_year || 0;
      const crewYear = crewMovie.movie_year || 0;
      
      if (castYear >= crewYear) {
        featuredMovie = {
          id: castMovie.movie_id,
          slug: castMovie.movie_slug,
          title: castMovie.movie_title,
          year: castMovie.movie_year,
          role: 'Actor'
        };
      } else {
        featuredMovie = {
          id: crewMovie.movie_id,
          slug: crewMovie.movie_slug,
          title: crewMovie.movie_title,
          year: crewMovie.movie_year,
          role: crewMovie.role_name
        };
      }
    } else if (castMovie) {
      featuredMovie = {
        id: castMovie.movie_id,
        slug: castMovie.movie_slug,
        title: castMovie.movie_title,
        year: castMovie.movie_year,
        role: 'Actor'
      };
    } else if (crewMovie) {
      featuredMovie = {
        id: crewMovie.movie_id,
        slug: crewMovie.movie_slug,
        title: crewMovie.movie_title,
        year: crewMovie.movie_year,
        role: crewMovie.role_name
      };
    }

    return {
      ...person,
      name: `${person.firstName || ''} ${person.lastName || ''}`.trim() || person.realName || 'Sin nombre',
      featuredMovie,
      movieCount: movieCountMap.get(person.id) || 0,
      birthLocationPath: paths?.birthPath || null,
      deathLocationPath: paths?.deathPath || null
    };
  });
}

// ==================================================
// src/app/api/people/review-names/route.ts
// ==================================================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Esta ruta debe ser din√°mica
export const dynamic = 'force-dynamic';

// GET: Obtener casos para revisar
export async function GET() {
  try {
    // Funci√≥n para contar palabras
    const countWords = (str: string | null) => {
      if (!str) return 0;
      return str.trim().split(/\s+/).length;
    };

    // Obtener todas las personas
    const allPeople = await prisma.person.findMany({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        slug: true,
        _count: {
          select: {
            castRoles: true,
            crewRoles: true,
          }
        }
      },
      orderBy: {
        id: 'asc'
      }
    });

    // Filtrar casos con m√°s de 3 palabras
    const casesToReview = allPeople.filter(person => {
      const firstNameWords = countWords(person.firstName);
      const lastNameWords = countWords(person.lastName);
      
      return firstNameWords > 3 || lastNameWords > 3;
    });

    // Formatear para la respuesta
    const formattedCases = casesToReview.map(person => ({
      id: person.id,
      firstName: person.firstName || '',
      lastName: person.lastName || '',
      slug: person.slug,
      totalRoles: person._count.castRoles + person._count.crewRoles,
      firstNameWords: countWords(person.firstName),
      lastNameWords: countWords(person.lastName)
    }));

    return NextResponse.json({
      cases: formattedCases,
      total: formattedCases.length
    });

  } catch (error) {
    console.error('Error fetching cases to review:', error);
    return NextResponse.json(
      { error: 'Error al obtener casos para revisar' },
      { status: 500 }
    );
  }
}

// PUT: Actualizar nombre de persona
export async function PUT(request: Request) {
  try {
    const { id, firstName, lastName } = await request.json();

    if (!id) {
      return NextResponse.json(
        { error: 'ID es requerido' },
        { status: 400 }
      );
    }

    // Generar nuevo slug basado en los nombres actualizados
    const generateSlug = (first: string, last: string) => {
      const parts = [];
      if (first) parts.push(first);
      if (last) parts.push(last);
      
      return parts
        .join('-')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9-]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    };

    const newSlug = generateSlug(firstName, lastName);

    // Verificar si el slug ya existe (excluyendo el ID actual)
    const existingPerson = await prisma.person.findFirst({
      where: {
        slug: newSlug,
        NOT: {
          id: id
        }
      }
    });

    // Si existe, agregar sufijo num√©rico
    let finalSlug = newSlug;
    if (existingPerson) {
      const count = await prisma.person.count({
        where: {
          slug: {
            startsWith: newSlug
          }
        }
      });
      finalSlug = `${newSlug}-${count + 1}`;
    }

    // Actualizar persona
    const updatedPerson = await prisma.person.update({
      where: { id },
      data: {
        firstName,
        lastName,
        slug: finalSlug,
        updatedAt: new Date()
      }
    });

    return NextResponse.json({
      success: true,
      person: updatedPerson
    });

  } catch (error) {
    console.error('Error updating person:', error);
    return NextResponse.json(
      { error: 'Error al actualizar persona' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/route.ts
// ==================================================
// src/app/api/people/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { generatePersonSlug } from '@/lib/people/peopleUtils';
import { splitFullName } from '@/lib/people/nameUtils';
import RedisClient from '@/lib/redis';

// ============================================
// CACHE CONFIGURATION
// ============================================

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 60 * 60 * 1000; // 1 hora en ms

// TTL diferenciado seg√∫n tipo de consulta
function getRedisTTL(searchParams: URLSearchParams): number {
  const deathYear = searchParams.get('deathYear');
  
  // Obituarios de a√±os pasados: 24 horas (no cambian)
  if (deathYear) {
    const year = parseInt(deathYear);
    const currentYear = new Date().getFullYear();
    
    if (year < currentYear) {
      return 86400; // 24 horas
    } else {
      return 900; // 1 hora para a√±o actual
    }
  }
  
  // Por defecto: 1 hora
  return 3600;
}

// Genera clave √∫nica basada en los par√°metros de b√∫squeda
function generateCacheKey(searchParams: URLSearchParams): string {
  const relevantParams = [
    'page',
    'limit',
    'search',
    'gender',
    'isActive',
    'hasLinks',
    'hasDeathDate',
    'deathYear',
    'sortBy',
    'sortOrder'
  ];
  
  const keyParts = relevantParams
    .map(param => {
      const value = searchParams.get(param);
      return value ? `${param}:${value}` : null;
    })
    .filter(Boolean);
  
  return `people:list:${keyParts.join(':')}:v1`;
}

// Verificar si debe cachear esta consulta
function shouldCache(searchParams: URLSearchParams): boolean {
  // Solo cachear obituarios (deathYear presente)
  return searchParams.has('deathYear');
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const search = searchParams.get('search');
    const gender = searchParams.get('gender');
    const isActive = searchParams.get('isActive');
    const hasLinks = searchParams.get('hasLinks');
    const hasDeathDate = searchParams.get('hasDeathDate');
    const deathYear = searchParams.get('deathYear'); // üÜï NUEVO FILTRO
    const sortBy = searchParams.get('sortBy') || 'last_name';
    const sortOrder = searchParams.get('sortOrder') || 'asc';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');

    // ============================================
    // CACHE LOGIC (solo para obituarios)
    // ============================================
    if (shouldCache(searchParams)) {
      const cacheKey = generateCacheKey(searchParams);
      const redisTTL = getRedisTTL(searchParams);
      const now = Date.now();
      
      // 1. Intentar obtener de Redis
      try {
        const redisCached = await RedisClient.get(cacheKey);
        
        if (redisCached) {
          console.log(`‚úÖ Cache HIT desde Redis para obituarios: ${cacheKey.substring(0, 60)}...`);
          return NextResponse.json(
            JSON.parse(redisCached),
            {
              headers: {
                'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
                'X-Cache': 'HIT',
                'X-Cache-Source': 'redis'
              }
            }
          );
        }
      } catch (redisError) {
        console.error('Redis error (non-fatal):', redisError);
      }
      
      // 2. Verificar cach√© en memoria como fallback
      const memoryCached = memoryCache.get(cacheKey);
      
      if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
        console.log(`‚úÖ Cache HIT desde memoria para obituarios: ${cacheKey.substring(0, 60)}...`);
        
        // Intentar guardar en Redis para pr√≥ximas requests
        RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), redisTTL)
          .catch(err => console.error('Error guardando en Redis:', err));
        
        return NextResponse.json(memoryCached.data, {
          headers: {
            'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
            'X-Cache': 'HIT',
            'X-Cache-Source': 'memory'
          }
        });
      }
      
      // 3. No hay cach√©, consultar base de datos
      console.log(`üîÑ Cache MISS - Consultando BD para obituarios: ${cacheKey.substring(0, 60)}...`);
    }
    
    // ============================================
    // QUERY LOGIC (existente)
    // ============================================

    // Si hay b√∫squeda, usar SQL con unaccent para b√∫squeda mejorada
    if (search && search.trim().length >= 2) {
      try {
        const searchPattern = `%${search.toLowerCase().trim()}%`;
        const searchTerms = search.toLowerCase().trim().split(/\s+/);
        const skip = (page - 1) * limit;
        
        // ============================================
        // B√öSQUEDA MEJORADA CON NOMBRES ALTERNATIVOS
        // ============================================
        // Busca en nombre principal Y en nombres alternativos
        // Retorna informaci√≥n sobre qu√© nombre hizo match
        const peopleResults = await prisma.$queryRaw<any[]>`
          WITH search_results AS (
            -- B√∫squeda en nombre principal
            SELECT 
              id,
              NULL::integer as matched_alternative_id,
              NULL::text as matched_alternative_name,
              1 as source_priority,
              CASE 
                WHEN unaccent(LOWER(CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')))) = unaccent(${search.toLowerCase().trim()}) THEN 1
                WHEN unaccent(LOWER(CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')))) LIKE unaccent(${search.toLowerCase().trim() + '%'}) THEN 2
                WHEN unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${searchPattern}) OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${searchPattern}) THEN 3
                ELSE 4
              END as match_rank
            FROM people
            WHERE 
              unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(COALESCE(real_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(CONCAT(COALESCE(last_name, ''), ' ', COALESCE(first_name, '')))) LIKE unaccent(${searchPattern})
            
            UNION ALL
            
            -- B√∫squeda en nombres alternativos
            SELECT 
              p.id,
              pan.id as matched_alternative_id,
              pan.full_name as matched_alternative_name,
              2 as source_priority,
              CASE 
                WHEN unaccent(LOWER(pan.full_name)) = unaccent(${search.toLowerCase().trim()}) THEN 1
                WHEN unaccent(LOWER(pan.full_name)) LIKE unaccent(${search.toLowerCase().trim() + '%'}) THEN 2
                ELSE 3
              END as match_rank
            FROM people p
            INNER JOIN people_alternative_names pan ON p.id = pan.person_id
            WHERE unaccent(LOWER(pan.full_name)) LIKE unaccent(${searchPattern})
          ),
          -- Eliminar duplicados manteniendo el mejor match
          ranked_results AS (
            SELECT 
              id,
              matched_alternative_id,
              matched_alternative_name,
              ROW_NUMBER() OVER (
                PARTITION BY id 
                ORDER BY source_priority ASC, match_rank ASC
              ) as rn
            FROM search_results
          )
          SELECT id, matched_alternative_id, matched_alternative_name
          FROM ranked_results
          WHERE rn = 1
          ORDER BY 
            CASE WHEN matched_alternative_id IS NULL THEN 0 ELSE 1 END,
            id
          LIMIT ${limit}
          OFFSET ${skip}
        `;

        // Obtener el total para paginaci√≥n (incluyendo nombres alternativos)
        const countResult = await prisma.$queryRaw<{count: number}[]>`
          SELECT COUNT(DISTINCT person_id)::int as count
          FROM (
            -- Conteo de matches en nombre principal
            SELECT id as person_id
            FROM people
            WHERE 
              unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(COALESCE(real_name, ''))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')))) LIKE unaccent(${searchPattern})
              OR unaccent(LOWER(CONCAT(COALESCE(last_name, ''), ' ', COALESCE(first_name, '')))) LIKE unaccent(${searchPattern})
            
            UNION
            
            -- Conteo de matches en nombres alternativos
            SELECT p.id as person_id
            FROM people p
            INNER JOIN people_alternative_names pan ON p.id = pan.person_id
            WHERE unaccent(LOWER(pan.full_name)) LIKE unaccent(${searchPattern})
          ) combined
        `;
        
        const totalCount = countResult[0]?.count || 0;
        const peopleIds = peopleResults.map(p => p.id);

        if (peopleIds.length === 0) {
          return NextResponse.json({
            data: [],
            totalCount: 0,
            page,
            totalPages: 0,
            hasMore: false,
          });
        }

        // Crear mapa de matches alternativos para enriquecer resultados
        const alternativeMatchMap = new Map<number, { id: number; name: string }>();
        for (const result of peopleResults) {
          if (result.matched_alternative_id) {
            alternativeMatchMap.set(result.id, {
              id: result.matched_alternative_id,
              name: result.matched_alternative_name
            });
          }
        }

        // Obtener datos completos con Prisma
        const people = await prisma.person.findMany({
          where: { id: { in: peopleIds } },
          include: {
            nationalities: {
              include: { location: true }
            },
            birthLocation: {
              include: { parent: true }
            },
            deathLocation: {
              include: { parent: true }
            },
            links: {
              where: { isActive: true },
              orderBy: { displayOrder: 'asc' }
            },
            alternativeNames: {
              orderBy: { createdAt: 'asc' }
            },
            _count: {
              select: {
                links: true,
                castRoles: true,
                crewRoles: true,
              },
            },
          },
          orderBy: [
            { lastName: 'asc' },
            { firstName: 'asc' }
          ]
        });

        // IMPORTANTE: Agregar el campo 'name' formateado y info de match alternativo
        const peopleWithName = people.map(person => {
          const altMatch = alternativeMatchMap.get(person.id);
          return {
            ...person,
            name: `${person.firstName || ''} ${person.lastName || ''}`.trim() || person.realName || 'Sin nombre',
            // Info del match alternativo (si aplica)
            matchedAlternativeName: altMatch?.name || null,
            matchedAlternativeNameId: altMatch?.id || null
          };
        });

        return NextResponse.json({
          data: peopleWithName,
          totalCount,
          page,
          totalPages: Math.ceil(totalCount / limit),
          hasMore: page < Math.ceil(totalCount / limit),
        });

      } catch (err) {
        console.error('Error with unaccent:', err);
        // Continuar con b√∫squeda normal
      }
    }

    // B√∫squeda normal sin unaccent o cuando no hay b√∫squeda
    const where: any = {};

    if (search && search.trim().length >= 2) {
      // B√∫squeda mejorada usando Prisma OR (incluye nombres alternativos)
      const searchTerms = search.trim().split(/\s+/);
      
      if (searchTerms.length === 1) {
        // Un solo t√©rmino: buscar en cada campo Y en nombres alternativos
        where.OR = [
          { firstName: { contains: search, mode: 'insensitive' } },
          { lastName: { contains: search, mode: 'insensitive' } },
          { realName: { contains: search, mode: 'insensitive' } },
          // Buscar en nombres alternativos
          { alternativeNames: { some: { fullName: { contains: search, mode: 'insensitive' } } } },
        ];
      } else {
        // M√∫ltiples t√©rminos: buscar combinaciones
        where.OR = [
          // Buscar en nombre real
          { realName: { contains: search, mode: 'insensitive' } },
          // Buscar cada t√©rmino en nombre o apellido
          {
            AND: searchTerms.map(term => ({
              OR: [
                { firstName: { contains: term, mode: 'insensitive' } },
                { lastName: { contains: term, mode: 'insensitive' } },
              ]
            }))
          },
          // Buscar en nombres alternativos (b√∫squeda completa)
          { alternativeNames: { some: { fullName: { contains: search, mode: 'insensitive' } } } },
        ];
      }
    }

    if (gender) where.gender = gender;
    if (isActive !== null && isActive !== '') where.isActive = isActive === 'true';
    if (hasLinks !== null && hasLinks !== '') where.hasLinks = hasLinks === 'true';
    
    // üÜï NUEVO: Filtro por a√±o de defunci√≥n espec√≠fico
    if (deathYear) {
      where.deathYear = parseInt(deathYear);
    } else if (hasDeathDate === 'true') {
      // Si no se especifica a√±o pero se pide hasDeathDate, filtrar los que tienen
      where.deathYear = { not: null };
    } else if (hasDeathDate === 'false') {
      where.deathYear = null;
    }

    let orderBy: any = {};
    if (sortBy === 'deathDate' || sortBy === 'deathYear') {
      // üÜï MEJORADO: Ordenar por a√±o de muerte considerando mes y d√≠a
      orderBy = [
        { deathYear: sortOrder },
        { deathMonth: sortOrder },
        { deathDay: sortOrder }
      ];
    } else if (sortBy === 'birthDate') {
      orderBy = [
        { birthYear: sortOrder },
        { birthMonth: sortOrder },
        { birthDay: sortOrder }
      ];
    } else if (sortBy === 'createdAt') {
      orderBy = { createdAt: sortOrder };
    } else if (sortBy === 'updatedAt') {
      orderBy = { updatedAt: sortOrder };
    } else if (sortBy === 'name') {
      orderBy = [
        { lastName: sortOrder },
        { firstName: sortOrder }
      ];
    } else {
      orderBy = [
        { lastName: 'asc' },
        { firstName: 'asc' }
      ];
    }

    const totalCount = await prisma.person.count({ where });

    const people = await prisma.person.findMany({
      where,
      include: {
        nationalities: {
          include: { location: true }
        },
        birthLocation: {
          include: { parent: true }
        },
        deathLocation: {
          include: { parent: true }
        },
        links: {
          where: { isActive: true },
          orderBy: { displayOrder: 'asc' }
        },
        alternativeNames: {
          orderBy: { createdAt: 'asc' }
        },
        _count: {
          select: {
            links: true,
            castRoles: true,
            crewRoles: true,
          },
        },
      },
      orderBy,
      skip: (page - 1) * limit,
      take: limit,
    });

    console.log('Found people:', people.length);
    console.log('Where clause:', where);
    console.log('Skip:', (page - 1) * limit);
    console.log('Take:', limit);

    const totalPages = Math.ceil(totalCount / limit);

    // IMPORTANTE: Agregar el campo 'name' formateado a cada persona
    // Tambi√©n identificar si alg√∫n nombre alternativo hizo match (para Prisma fallback)
    const peopleWithName = people.map(person => {
      let matchedAlternativeName: string | null = null;
      let matchedAlternativeNameId: number | null = null;
      
      // Si hay b√∫squeda, verificar si el match fue en un nombre alternativo
      if (search && search.trim().length >= 2 && person.alternativeNames?.length) {
        const searchLower = search.toLowerCase().trim();
        const mainName = `${person.firstName || ''} ${person.lastName || ''}`.toLowerCase().trim();
        
        // Si el nombre principal no contiene el t√©rmino de b√∫squeda,
        // buscar cu√°l nombre alternativo hizo match
        if (!mainName.includes(searchLower) && 
            !(person.firstName?.toLowerCase().includes(searchLower)) &&
            !(person.lastName?.toLowerCase().includes(searchLower))) {
          for (const alt of person.alternativeNames) {
            if (alt.fullName.toLowerCase().includes(searchLower)) {
              matchedAlternativeName = alt.fullName;
              matchedAlternativeNameId = alt.id;
              break;
            }
          }
        }
      }
      
      return {
        ...person,
        name: `${person.firstName || ''} ${person.lastName || ''}`.trim() || person.realName || 'Sin nombre',
        matchedAlternativeName,
        matchedAlternativeNameId
      };
    });

    const result = {
      data: peopleWithName,
      totalCount,
      page,
      totalPages,
      hasMore: page < totalPages,
    };
    
    // ============================================
    // SAVE TO CACHE (solo para obituarios)
    // ============================================
    const useCache = shouldCache(request.nextUrl.searchParams);
    
    if (useCache) {
      const cacheKey = generateCacheKey(request.nextUrl.searchParams);
      const redisTTL = getRedisTTL(request.nextUrl.searchParams);
      const now = Date.now();
      
      console.log(`üíæ Guardando en cach√©: ${cacheKey.substring(0, 60)}...`);
      
      // Guardar en Redis
      RedisClient.set(cacheKey, JSON.stringify(result), redisTTL)
        .then(saved => {
          if (saved) {
            console.log(`‚úÖ Obituarios guardados en Redis con TTL ${redisTTL}s (${redisTTL/60} min)`);
          }
        })
        .catch(err => console.error('Error guardando en Redis:', err));
      
      // Guardar en memoria
      memoryCache.set(cacheKey, {
        data: result,
        timestamp: now
      });
      
      // Limpiar cach√© de memoria viejo (mantener m√°ximo 200 listados)
      if (memoryCache.size > 200) {
        const oldestKey = memoryCache.keys().next().value;
        if (oldestKey) {
          memoryCache.delete(oldestKey);
        }
      }
    }

    // Retornar con headers apropiados
    if (useCache) {
      const redisTTL = getRedisTTL(request.nextUrl.searchParams);
      return NextResponse.json(result, {
        headers: {
          'Cache-Control': `public, s-maxage=${redisTTL}, stale-while-revalidate=${redisTTL * 2}`,
          'X-Cache': 'MISS',
          'X-Cache-Source': 'database'
        }
      });
    }

    // Sin cach√© (b√∫squedas normales)
    return NextResponse.json(result);
    
  } catch (error) {
    console.error('Error fetching people:', error);
    
    // Intentar servir desde cach√© stale si hay error (solo obituarios)
    if (shouldCache(request.nextUrl.searchParams)) {
      const cacheKey = generateCacheKey(request.nextUrl.searchParams);
      const staleCache = memoryCache.get(cacheKey);
      
      if (staleCache) {
        console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
        return NextResponse.json(staleCache.data, {
          headers: {
            'Cache-Control': 'public, s-maxage=60',
            'X-Cache': 'STALE',
            'X-Cache-Source': 'memory-fallback'
          }
        });
      }
    }
    
    return NextResponse.json(
      { message: 'Error al obtener personas' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();

    // ‚ú® SEPARACI√ìN INTELIGENTE DE NOMBRES
    // Usa FirstNameGender para identificar qu√© palabras son nombres
    if (data.name && !data.firstName && !data.lastName) {
      const { firstName, lastName } = await splitFullName(data.name, prisma);
      data.firstName = firstName;
      data.lastName = lastName;
    }

    let baseSlug = generatePersonSlug(data.firstName, data.lastName);
    let slug = baseSlug;
    let counter = 1;

    while (await prisma.person.findUnique({ where: { slug } })) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    const personData: any = {
      slug,
      firstName: data.firstName || null,
      lastName: data.lastName || null,
      realName: data.realName || null,
      birthYear: data.birthYear || null,
      birthMonth: data.birthMonth || null,
      birthDay: data.birthDay || null,
      deathYear: data.deathYear || null,
      deathMonth: data.deathMonth || null,
      deathDay: data.deathDay || null,
      birthLocationId: data.birthLocationId || null,
      deathLocationId: data.deathLocationId || null,
      biography: data.biography || null,
      photoUrl: data.photoUrl || null,
      photoPublicId: data.photoPublicId || null,
      gender: data.gender || null,
      hideAge: data.hideAge || false,
      isActive: data.isActive ?? true,
      hasLinks: data.links && data.links.length > 0,
    };

    const person = await prisma.$transaction(async (tx) => {
      const newPerson = await tx.person.create({
        data: personData,
      });

      if (data.links && data.links.length > 0) {
        await tx.personLink.createMany({
          data: data.links.map((link: any, index: number) => ({
            personId: newPerson.id,
            type: link.type,
            url: link.url,
            title: link.title || null,
            displayOrder: link.displayOrder ?? index,
            isVerified: link.isVerified || false,
            isActive: link.isActive ?? true,
          })),
        });
      }

      if (data.nationalities && data.nationalities.length > 0) {
        await tx.personNationality.createMany({
          data: data.nationalities.map((locationId: number) => ({
            personId: newPerson.id,
            locationId: locationId,
          })),
        });
      }

      // üÜï Crear nombres alternativos si se enviaron
      if (data.alternativeNames && data.alternativeNames.length > 0) {
        const validNames = data.alternativeNames.filter(
          (alt: any) => alt.fullName && alt.fullName.trim()
        );
        if (validNames.length > 0) {
          await tx.personAlternativeName.createMany({
            data: validNames.map((alt: any) => ({
              personId: newPerson.id,
              fullName: alt.fullName.trim(),
            })),
          });
        }
      }

      return tx.person.findUnique({
        where: { id: newPerson.id },
        include: {
          links: true,
          nationalities: {
            include: { location: true }
          },
          birthLocation: {
            include: { parent: true }
          },
          deathLocation: {
            include: { parent: true }
          },
          alternativeNames: {
            orderBy: { createdAt: 'asc' }
          },
          _count: {
            select: {
              links: true,
              castRoles: true,
              crewRoles: true,
            },
          },
        },
      });
    });

    // IMPORTANTE: Agregar el campo 'name' al resultado
    const personWithName = {
      ...person,
      name: `${person?.firstName || ''} ${person?.lastName || ''}`.trim() || person?.realName || 'Sin nombre'
    };

    // ============================================
    // INVALIDAR CACH√âS si es un obituario
    // ============================================
    if (person?.deathYear) {
      console.log('üóëÔ∏è Invalidando cach√©s de obituarios tras crear persona fallecida');
      
      const redisClient = RedisClient.getInstance();
      if (redisClient) {
        try {
          const keys = await redisClient.keys('people:list:*deathYear*');
          if (keys.length > 0) {
            await redisClient.del(...keys);
            console.log(`‚úÖ ${keys.length} cach√©s de obituarios invalidados en Redis`);
          }
          
          // Tambi√©n invalidar death-years
          await redisClient.del('people:death-years:v1');
          console.log('‚úÖ Cach√© de death-years invalidado en Redis');
        } catch (err) {
          console.error('Error invalidando cach√©s de Redis:', err);
        }
      }
      
      // Limpiar memoria tambi√©n
      let memoryKeysDeleted = 0;
      for (const key of memoryCache.keys()) {
        if (key.includes('deathYear') || key === 'people:death-years:v1') {
          memoryCache.delete(key);
          memoryKeysDeleted++;
        }
      }
      if (memoryKeysDeleted > 0) {
        console.log(`‚úÖ ${memoryKeysDeleted} cach√©s de obituarios invalidados en memoria`);
      }
    }

    return NextResponse.json(personWithName, { status: 201 });
  } catch (error) {
    console.error('Error creating person:', error);
    return NextResponse.json(
      { message: 'Error al crear persona' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/slug/[slug]/route.ts
// ==================================================
// src/app/api/people/slug/[slug]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const person = await prisma.person.findFirst({
      where: {
        slug: params.slug,
        isActive: true
      },
      include: {
        birthLocation: {
          include: {
            parent: {
              include: {
                parent: {
                  include: {
                    parent: true
                  }
                }
              }
            }
          }
        },
        deathLocation: {
          include: {
            parent: {
              include: {
                parent: {
                  include: {
                    parent: true
                  }
                }
              }
            }
          }
        },
        links: {
          where: {
            isActive: true
          },
          orderBy: {
            displayOrder: 'asc'
          }
        },
        nationalities: {
          include: {
            location: true
          }
        },
        alternativeNames: {
          orderBy: {
            createdAt: 'asc'
          }
        },
        // Im√°genes en las que aparece la persona
        imageAppearances: {
          include: {
            image: {
              include: {
                movie: {
                  select: {
                    id: true,
                    title: true,
                    releaseYear: true
                  }
                },
                people: {
                  include: {
                    person: {
                      select: {
                        id: true,
                        firstName: true,
                        lastName: true
                      }
                    }
                  },
                  orderBy: {
                    position: 'asc'
                  }
                }
              }
            }
          }
        }
      }
    });

    if (!person) {
      return NextResponse.json(
        { error: 'Person not found' },
        { status: 404 }
      );
    }

    // Transformar im√°genes al formato esperado por el componente ImageGallery
    const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;
    const galleryImages = person.imageAppearances.map((appearance) => {
      const img = appearance.image;
      return {
        id: img.id,
        url: `https://res.cloudinary.com/${cloudName}/image/upload/w_1280,q_auto,f_auto/${img.cloudinaryPublicId}`,
        cloudinaryPublicId: img.cloudinaryPublicId,
        type: img.type,
        eventName: img.eventName,
        people: img.people.map((p) => ({
          personId: p.personId,
          position: p.position,
          person: {
            id: p.person.id,
            firstName: p.person.firstName,
            lastName: p.person.lastName
          }
        })),
        movie: img.movie ? {
          id: img.movie.id,
          title: img.movie.title,
          releaseYear: img.movie.releaseYear
        } : null
      };
    });

    // Retornar persona con im√°genes transformadas
    const { imageAppearances, ...personData } = person;
    return NextResponse.json({
      ...personData,
      galleryImages
    });
  } catch (error) {
    console.error('Error fetching person by slug:', error);
    return NextResponse.json(
      { error: 'Failed to fetch person' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/[id]/filmography/route.ts
// ==================================================
// src/app/api/people/[id]/filmography/route.ts - ACTUALIZADO
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import RedisClient from '@/lib/redis';

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 60 * 60 * 1000; // 1 hora en ms
const REDIS_CACHE_TTL = 3600; // 1 hora en segundos

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const personId = parseInt(params.id);
    
    // Generar clave de cach√© √∫nica - VERSI√ìN v2 para invalidar cache anterior
    const cacheKey = `person:filmography:${personId}:v2`;

    // 1. Intentar obtener de Redis
    try {
      const redisCached = await RedisClient.get(cacheKey);

      if (redisCached) {
        console.log(`‚úÖ Cache HIT desde Redis para filmograf√≠a de persona: ${personId}`);
        return NextResponse.json(
          JSON.parse(redisCached),
          {
            headers: {
              'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
              'X-Cache': 'HIT',
              'X-Cache-Source': 'redis',
              'X-Person-Id': params.id
            }
          }
        );
      }
    } catch (redisError) {
      console.error('Redis error (non-fatal):', redisError);
    }

    // 2. Verificar cach√© en memoria como fallback
    const now = Date.now();
    const memoryCached = memoryCache.get(cacheKey);

    if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
      console.log(`‚úÖ Cache HIT desde memoria para filmograf√≠a de persona: ${personId}`);

      // Intentar guardar en Redis para pr√≥ximas requests
      RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), REDIS_CACHE_TTL)
        .catch(err => console.error('Error guardando en Redis:', err));

      return NextResponse.json(memoryCached.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
          'X-Cache': 'HIT',
          'X-Cache-Source': 'memory',
          'X-Person-Id': params.id
        }
      });
    }

    // 3. No hay cach√©, consultar base de datos
    console.log(`üîÑ Cache MISS - Consultando BD para filmograf√≠a de persona: ${personId}`);

    // Obtener roles como actor/actriz
    const castRoles = await prisma.movieCast.findMany({
      where: {
        personId: personId
      },
      select: {
        id: true,
        characterName: true,
        billingOrder: true,
        isPrincipal: true,
        isActor: true, // Para diferenciar actuaciones de apariciones como si mismo
        movie: {
          select: {
            id: true,
            slug: true,
            title: true,
            year: true,
            releaseYear: true,
            releaseMonth: true,
            releaseDay: true,
            posterUrl: true,
            stage: true,
            tipoDuracion: true
          }
        }
      },
      orderBy: [
        { movie: { releaseYear: 'desc' } },
        { movie: { year: 'desc' } }
      ]
    });

    // Obtener roles en el equipo t√©cnico
    const crewRoles = await prisma.movieCrew.findMany({
      where: {
        personId: personId
      },
      include: {
        movie: {
          select: {
            id: true,
            slug: true,
            title: true,
            year: true,
            releaseYear: true,
            releaseMonth: true,
            releaseDay: true,
            posterUrl: true,
            stage: true,
            tipoDuracion: true // ‚úÖ AGREGADO
          }
        },
        role: true // Incluir la referencia al rol si existe
      },
      orderBy: [
        { movie: { releaseYear: 'desc' } },
        { movie: { year: 'desc' } }
      ]
    });

    const filmography = {
      castRoles,
      crewRoles,
      totalMovies: [...new Set([
        ...castRoles.map(r => r.movie.id),
        ...crewRoles.map(r => r.movie.id)
      ])].length
    };

    // 4. Guardar en ambos cach√©s
    // Redis con TTL de 1 hora
    RedisClient.set(cacheKey, JSON.stringify(filmography), REDIS_CACHE_TTL)
      .then(saved => {
        if (saved) {
          console.log(`‚úÖ Filmograf√≠a de persona ${personId} guardada en Redis`);
        }
      })
      .catch(err => console.error('Error guardando en Redis:', err));

    // Memoria como fallback
    memoryCache.set(cacheKey, {
      data: filmography,
      timestamp: now
    });

    // Limpiar cach√© de memoria viejo (mantener m√°ximo 50 filmograf√≠as)
    if (memoryCache.size > 50) {
      const oldestKey = memoryCache.keys().next().value;
      if (oldestKey) {
        memoryCache.delete(oldestKey);
      }
    }

    return NextResponse.json(filmography, {
      headers: {
        'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
        'X-Cache': 'MISS',
        'X-Cache-Source': 'database',
        'X-Person-Id': params.id
      }
    });
  } catch (error) {
    console.error('Error fetching person filmography:', error);

    // Intentar servir desde cach√© stale si hay error
    const cacheKey = `person:filmography:${parseInt(params.id)}:v2`;
    const staleCache = memoryCache.get(cacheKey);

    if (staleCache) {
      console.log('‚ö†Ô∏è Sirviendo cach√© stale de filmograf√≠a debido a error');
      return NextResponse.json(staleCache.data, {
        headers: {
          'Cache-Control': 'public, s-maxage=60',
          'X-Cache': 'STALE',
          'X-Cache-Source': 'memory-fallback'
        }
      });
    }

    return NextResponse.json(
      { error: 'Failed to fetch filmography' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/people/[id]/route.ts
// ==================================================
// src/app/api/people/[id]/route.ts - CON REDIS CACHE
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { generatePersonSlug } from '@/lib/people/peopleUtils';
import RedisClient from '@/lib/redis';

// Cache en memoria como fallback
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const MEMORY_CACHE_TTL = 60 * 60 * 1000; // 1 hora en ms
const REDIS_CACHE_TTL = 3600; // 1 hora en segundos

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { id } = await params;
        const personId = parseInt(id);

        // Generar clave de cach√© √∫nica
        const cacheKey = `person:id:${personId}:v1`;

        // 1. Intentar obtener de Redis
        try {
            const redisCached = await RedisClient.get(cacheKey);

            if (redisCached) {
                console.log(`‚úÖ Cache HIT desde Redis para persona: ${personId}`);
                return NextResponse.json(
                    JSON.parse(redisCached),
                    {
                        headers: {
                            'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
                            'X-Cache': 'HIT',
                            'X-Cache-Source': 'redis',
                            'X-Person-Id': id
                        }
                    }
                );
            }
        } catch (redisError) {
            console.error('Redis error (non-fatal):', redisError);
        }

        // 2. Verificar cach√© en memoria como fallback
        const now = Date.now();
        const memoryCached = memoryCache.get(cacheKey);

        if (memoryCached && (now - memoryCached.timestamp) < MEMORY_CACHE_TTL) {
            console.log(`‚úÖ Cache HIT desde memoria para persona: ${personId}`);

            // Intentar guardar en Redis para pr√≥ximas requests
            RedisClient.set(cacheKey, JSON.stringify(memoryCached.data), REDIS_CACHE_TTL)
                .catch(err => console.error('Error guardando en Redis:', err));

            return NextResponse.json(memoryCached.data, {
                headers: {
                    'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
                    'X-Cache': 'HIT',
                    'X-Cache-Source': 'memory',
                    'X-Person-Id': id
                }
            });
        }

        // 3. No hay cach√©, consultar base de datos
        console.log(`üîÑ Cache MISS - Consultando BD para persona: ${personId}`);

        const person = await prisma.person.findUnique({
            where: { id: personId },
            include: {
                links: {
                    orderBy: { displayOrder: 'asc' },
                },
                alternativeNames: {
                    orderBy: { createdAt: 'asc' },
                },
                nationalities: {
                    include: {
                        location: true
                    }
                },
                birthLocation: {
                    include: {
                        parent: {
                            include: {
                                parent: {
                                    include: {
                                        parent: true
                                    }
                                }
                            }
                        }
                    }
                },
                deathLocation: {
                    include: {
                        parent: {
                            include: {
                                parent: {
                                    include: {
                                        parent: true
                                    }
                                }
                            }
                        }
                    }
                },
                _count: {
                    select: {
                        castRoles: true,
                        crewRoles: true,
                        awards: true,
                    },
                },
            },
        });

        if (!person) {
            return NextResponse.json(
                { message: 'Persona no encontrada' },
                { status: 404 }
            );
        }

        // 4. Guardar en ambos cach√©s
        // Redis con TTL de 1 hora
        RedisClient.set(cacheKey, JSON.stringify(person), REDIS_CACHE_TTL)
            .then(saved => {
                if (saved) {
                    console.log(`‚úÖ Persona ${personId} guardada en Redis`);
                }
            })
            .catch(err => console.error('Error guardando en Redis:', err));

        // Memoria como fallback
        memoryCache.set(cacheKey, {
            data: person,
            timestamp: now
        });

        // Limpiar cach√© de memoria viejo (mantener m√°ximo 100 personas)
        if (memoryCache.size > 100) {
            const oldestKey = memoryCache.keys().next().value;
            if (oldestKey) {
                memoryCache.delete(oldestKey);
            }
        }

        return NextResponse.json(person, {
            headers: {
                'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=7200',
                'X-Cache': 'MISS',
                'X-Cache-Source': 'database',
                'X-Person-Id': id
            }
        });
    } catch (error) {
        console.error('Error fetching person:', error);

        // Intentar servir desde cach√© stale si hay error
        const { id } = await params;
        const cacheKey = `person:id:${parseInt(id)}:v1`;
        const staleCache = memoryCache.get(cacheKey);

        if (staleCache) {
            console.log('‚ö†Ô∏è Sirviendo cach√© stale debido a error');
            return NextResponse.json(staleCache.data, {
                headers: {
                    'Cache-Control': 'public, s-maxage=60',
                    'X-Cache': 'STALE',
                    'X-Cache-Source': 'memory-fallback'
                }
            });
        }

        return NextResponse.json(
            { message: 'Error al obtener persona' },
            { status: 500 }
        );
    }
}

export async function PUT(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { id } = await params;
        const data = await request.json();
        const personId = parseInt(id);

        console.log('Data received in API:', data);
        console.log('Nationalities received:', data.nationalities);

        // Verificar si necesitamos actualizar el slug
        let slug = undefined;
        const currentPerson = await prisma.person.findUnique({
            where: { id: personId },
            select: { firstName: true, lastName: true, slug: true },
        });

        if (!currentPerson) {
            return NextResponse.json(
                { message: 'Persona no encontrada' },
                { status: 404 }
            );
        }

        const nameChanged =
            currentPerson.firstName !== data.firstName ||
            currentPerson.lastName !== data.lastName;

        if (nameChanged) {
            // Generar nuevo slug si cambi√≥ el nombre
            let baseSlug = generatePersonSlug(data.firstName, data.lastName);
            slug = baseSlug;
            let counter = 1;

            // Verificar que el nuevo slug no exista (excepto para la persona actual)
            while (true) {
                const existing = await prisma.person.findUnique({
                    where: { slug },
                    select: { id: true },
                });

                if (!existing || existing.id === personId) break;

                slug = `${baseSlug}-${counter}`;
                counter++;
            }
        }

        // Preparar datos de actualizaci√≥n con campos de fecha parciales
        const updateData: any = {
            ...(slug && { slug }),
            firstName: data.firstName || null,
            lastName: data.lastName || null,
            realName: data.realName || null,
            birthYear: data.birthYear || null,
            birthMonth: data.birthMonth || null,
            birthDay: data.birthDay || null,
            deathYear: data.deathYear || null,
            deathMonth: data.deathMonth || null,
            deathDay: data.deathDay || null,
            birthLocation: data.birthLocationId
                ? { connect: { id: data.birthLocationId } }
                : { disconnect: true },
            deathLocation: data.deathLocationId
                ? { connect: { id: data.deathLocationId } }
                : { disconnect: true },
            biography: data.biography || null,
            photoUrl: data.photoUrl || null,
            photoPublicId: data.photoPublicId || null,
            gender: data.gender || null,
            hideAge: data.hideAge || false,
            isActive: data.isActive ?? true,
            hasLinks: data.links && data.links.length > 0,
        };

        console.log('Update data prepared:', updateData);

        // Actualizar persona, links y nacionalidades en una transacci√≥n
        const person = await prisma.$transaction(async (tx) => {
            // Actualizar la persona
            const updatedPerson = await tx.person.update({
                where: { id: personId },
                data: updateData,
            });

            // Eliminar links existentes
            await tx.personLink.deleteMany({
                where: { personId },
            });

            // Crear nuevos links si existen
            if (data.links && data.links.length > 0) {
                await tx.personLink.createMany({
                    data: data.links.map((link: any, index: number) => ({
                        personId,
                        type: link.type,
                        url: link.url,
                        title: link.title || null,
                        displayOrder: link.displayOrder ?? index,
                        isVerified: link.isVerified || false,
                        isActive: link.isActive ?? true,
                    })),
                });
            }

            // Eliminar nacionalidades existentes
            await tx.personNationality.deleteMany({
                where: { personId },
            });

            // Crear nuevas nacionalidades si existen
            if (data.nationalities && data.nationalities.length > 0) {
                await tx.personNationality.createMany({
                    data: data.nationalities.map((locationId: number) => ({
                        personId,
                        locationId: locationId,
                    })),
                });
            }

            // Eliminar nombres alternativos existentes
            await tx.personAlternativeName.deleteMany({
                where: { personId },
            });

            // Crear nuevos nombres alternativos si existen
            if (data.alternativeNames && data.alternativeNames.length > 0) {
                await tx.personAlternativeName.createMany({
                    data: data.alternativeNames
                        .filter((alt: any) => alt.fullName && alt.fullName.trim() !== '')
                        .map((alt: any) => ({
                            personId,
                            fullName: alt.fullName.trim(),
                        })),
                });
            }

            // Retornar la persona actualizada con sus relaciones
            return tx.person.findUnique({
                where: { id: personId },
                include: {
                    links: true,
                    alternativeNames: true,
                    nationalities: {
                        include: {
                            location: true
                        }
                    },
                    birthLocation: {
                        include: {
                            parent: {
                                include: {
                                    parent: {
                                        include: {
                                            parent: true
                                        }
                                    }
                                }
                            }
                        }
                    },
                    deathLocation: {
                        include: {
                            parent: {
                                include: {
                                    parent: {
                                        include: {
                                            parent: true
                                        }
                                    }
                                }
                            }
                        }
                    },
                    _count: {
                        select: {
                            links: true,
                            castRoles: true,
                            crewRoles: true,
                        },
                    },
                },
            });
        });

        // INVALIDAR CACH√âS despu√©s de actualizar exitosamente
        console.log('üóëÔ∏è Invalidando cach√©s para persona actualizada');

        const cacheKeysToInvalidate = [
            `person:id:${personId}:v1`,
            `person:slug:${currentPerson.slug}:v1`,
            `person:filmography:${personId}:v1`, // Tambi√©n invalidar filmograf√≠a
            'people-list:v1' // Lista de personas si existe
        ];

        // Si el slug cambi√≥, tambi√©n invalidar el nuevo slug
        if (slug && slug !== currentPerson.slug) {
            cacheKeysToInvalidate.push(`person:slug:${slug}:v1`);
        }

        // Invalidar en Redis
        await Promise.all(
            cacheKeysToInvalidate.map(key =>
                RedisClient.del(key).catch(err =>
                    console.error(`Error invalidando Redis key ${key}:`, err)
                )
            )
        );

        // Invalidar en memoria
        cacheKeysToInvalidate.forEach(key => memoryCache.delete(key));

        console.log(`‚úÖ Cach√©s invalidados: ${cacheKeysToInvalidate.join(', ')}`);

        return NextResponse.json(person);
    } catch (error) {
        console.error('Error updating person:', error);
        return NextResponse.json(
            { message: 'Error al actualizar persona' },
            { status: 500 }
        );
    }
}

export async function DELETE(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { id } = await params;
        const personId = parseInt(id);

        // Verificar si la persona tiene pel√≠culas asociadas
        const person = await prisma.person.findUnique({
            where: { id: personId },
            select: {
                slug: true,
                _count: {
                    select: {
                        castRoles: true,
                        crewRoles: true,
                    },
                },
            }
        });

        if (!person) {
            return NextResponse.json(
                { message: 'Persona no encontrada' },
                { status: 404 }
            );
        }

        const totalRoles = person._count.castRoles + person._count.crewRoles;
        if (totalRoles > 0) {
            return NextResponse.json(
                {
                    message: `No se puede eliminar esta persona porque est√° asociada a ${totalRoles} pel√≠cula(s)`
                },
                { status: 400 }
            );
        }

        // Eliminar la persona (los links y nacionalidades se eliminan en cascada)
        await prisma.person.delete({
            where: { id: personId },
        });

        // INVALIDAR CACH√âS despu√©s de eliminar
        console.log('üóëÔ∏è Invalidando cach√©s para persona eliminada');

        const cacheKeysToInvalidate = [
            `person:id:${personId}:v1`,
            `person:slug:${person.slug}:v1`,
            `person:filmography:${personId}:v1`,
            'people-list:v1'
        ];

        // Invalidar en Redis
        await Promise.all(
            cacheKeysToInvalidate.map(key =>
                RedisClient.del(key).catch(err =>
                    console.error(`Error invalidando Redis key ${key}:`, err)
                )
            )
        );

        // Invalidar en memoria
        cacheKeysToInvalidate.forEach(key => memoryCache.delete(key));

        console.log(`‚úÖ Cach√©s invalidados tras eliminar: ${cacheKeysToInvalidate.join(', ')}`);

        return NextResponse.json({ message: 'Persona eliminada correctamente' });
    } catch (error) {
        console.error('Error deleting person:', error);
        return NextResponse.json(
            { message: 'Error al eliminar persona' },
            { status: 500 }
        );
    }
}

// ==================================================
// src/app/api/project-structure/route.ts
// ==================================================
// src/app/api/project-structure/route.ts
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

export async function GET(request: Request) {
  // Verificar clave de seguridad
  const { searchParams } = new URL(request.url);
  const key = searchParams.get('key');
  
  if (key !== 'cinenacional2024') {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Funci√≥n para escanear directorio
  function scanDir(dir: string, base = ''): any {
    try {
      const items = fs.readdirSync(dir);
      const result: any = {};
      
      items.forEach(item => {
        // Ignorar archivos y carpetas que no necesitamos
        if (item.startsWith('.') || 
            item === 'node_modules' || 
            item === '.next' ||
            item === 'out' ||
            item === 'coverage' ||
            item === '.vercel') return;
        
        const fullPath = path.join(dir, item);
        try {
          const stats = fs.statSync(fullPath);
          
          if (stats.isDirectory()) {
            const subResult = scanDir(fullPath, path.join(base, item));
            // Solo incluir directorios que tengan contenido
            if (Object.keys(subResult).length > 0) {
              result[item] = subResult;
            }
          } else if (item.match(/\.(ts|tsx|js|jsx|json|css|scss|md|sql|prisma)$/)) {
            // Crear URL de GitHub para cada archivo
            result[item] = `https://raw.githubusercontent.com/diegopapic/cinenacional/main/${path.join(base, item).replace(/\\/g, '/')}`;
          }
        } catch (error) {
          console.error(`Error reading ${fullPath}:`, error);
        }
      });
      
      return result;
    } catch (error) {
      console.error(`Error scanning directory ${dir}:`, error);
      return {};
    }
  }
  
  try {
    const projectRoot = process.cwd();
    const structure = scanDir(projectRoot);
    
    // Agregar algunos archivos importantes en la ra√≠z manualmente si no fueron escaneados
    const rootFiles = ['package.json', 'tsconfig.json', 'next.config.js', 'next.config.mjs', '.env.example', 'README.md'];
    const quickLinks: any = {};
    
    rootFiles.forEach(file => {
      const filePath = path.join(projectRoot, file);
      if (fs.existsSync(filePath)) {
        quickLinks[file] = `https://raw.githubusercontent.com/diegopapic/cinenacional/main/${file}`;
      }
    });
    
    return NextResponse.json({
      timestamp: new Date().toISOString(),
      repository: "https://github.com/diegopapic/cinenacional",
      structure,
      quickLinks,
      totalFiles: countFiles(structure)
    });
  } catch (error) {
    // Si hay alg√∫n error al escanear, devolver una respuesta de error informativa
    return NextResponse.json({
      error: 'Error scanning project',
      details: error instanceof Error ? error.message : 'Unknown error',
      // Proporcionar al menos los enlaces b√°sicos
      quickLinks: {
        package: "https://raw.githubusercontent.com/diegopapic/cinenacional/main/package.json",
        tsconfig: "https://raw.githubusercontent.com/diegopapic/cinenacional/main/tsconfig.json"
      }
    });
  }
}

// Funci√≥n auxiliar para contar archivos
function countFiles(obj: any): number {
  let count = 0;
  for (const key in obj) {
    if (typeof obj[key] === 'string') {
      count++;
    } else if (typeof obj[key] === 'object') {
      count += countFiles(obj[key]);
    }
  }
  return count;
}

// ==================================================
// src/app/api/roles/route.ts
// ==================================================
// src/app/api/roles/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { roleSchema, Department } from '@/lib/roles/rolesTypes';
import { generateSlug } from '@/lib/utils/slugs';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const department = searchParams.get('department') as Department;
    const isActive = searchParams.get('isActive');
    const isMainRole = searchParams.get('isMainRole');
    const exportFormat = searchParams.get('export');
    const sortBy = searchParams.get('sortBy') || 'usage';
    const sortOrder = searchParams.get('sortOrder') || 'desc';

    const offset = (page - 1) * limit;

    // Si hay b√∫squeda, usar unaccent
    if (search && search.trim().length >= 2) {
      try {
        const searchPattern = `%${search.toLowerCase().trim()}%`;
        
        // Buscar con unaccent
        const rolesWithSearch = await prisma.$queryRaw<{id: number}[]>`
          SELECT id
          FROM roles
          WHERE 
            unaccent(LOWER(name)) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(description, ''))) LIKE unaccent(${searchPattern})
        `;
        
        if (rolesWithSearch.length === 0) {
          return NextResponse.json({
            data: [],
            totalCount: 0,
            page,
            totalPages: 0,
            hasMore: false
          });
        }
        
        // Construir where para los IDs encontrados
        const where: any = {
          id: { in: rolesWithSearch.map(r => r.id) }
        };
        
        // Agregar filtros adicionales
        if (department && Object.values(Department).includes(department)) {
          where.department = department;
        }
        
        if (isActive !== null && isActive !== '') {
          where.isActive = isActive === 'true';
        }
        
        if (isMainRole !== null && isMainRole !== '') {
          where.isMainRole = isMainRole === 'true';
        }
        
        // Obtener roles completos
        const roles = await prisma.role.findMany({
          where,
          include: {
            _count: {
              select: {
                crewRoles: true
              }
            }
          }
        });
        
        // Ordenar seg√∫n sortBy
        if (sortBy === 'usage') {
          roles.sort((a, b) => {
            const countA = a._count?.crewRoles || 0;
            const countB = b._count?.crewRoles || 0;
            return sortOrder === 'desc' ? countB - countA : countA - countB;
          });
        } else if (sortBy === 'name') {
          roles.sort((a, b) => {
            return sortOrder === 'desc' 
              ? b.name.localeCompare(a.name)
              : a.name.localeCompare(b.name);
          });
        }
        
        // Paginar manualmente
        const paginatedRoles = roles.slice(offset, offset + limit);
        const totalCount = roles.length;
        const totalPages = Math.ceil(totalCount / limit);
        
        if (exportFormat === 'csv') {
          const csv = [
            'ID,Nombre,Departamento,Descripci√≥n,Principal,Activo,Usos',
            ...roles.map(role => 
              `${role.id},"${role.name}","${role.department}","${role.description || ''}",${role.isMainRole ? 'S√≠' : 'No'},${role.isActive ? 'S√≠' : 'No'},${role._count.crewRoles}`
            )
          ].join('\n');

          return new NextResponse(csv, {
            headers: {
              'Content-Type': 'text/csv',
              'Content-Disposition': `attachment; filename="roles_${new Date().toISOString().split('T')[0]}.csv"`
            }
          });
        }
        
        return NextResponse.json({
          data: paginatedRoles,
          totalCount,
          page,
          totalPages,
          hasMore: page < totalPages
        });
        
      } catch (error) {
        console.error('Error con unaccent:', error);
        // Continuar con b√∫squeda normal
      }
    }

    // B√∫squeda normal sin unaccent
    const where: any = {};

    if (search) {
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } }
      ];
    }

    if (department && Object.values(Department).includes(department)) {
      where.department = department;
    }

    if (isActive !== null && isActive !== '') {
      where.isActive = isActive === 'true';
    }

    if (isMainRole !== null && isMainRole !== '') {
      where.isMainRole = isMainRole === 'true';
    }

    // El resto del c√≥digo contin√∫a igual...
    let orderBy: any;
    
    if (sortBy === 'usage') {
      // Para ordenar por uso necesitamos hacerlo manualmente
      const rolesWithCount = await prisma.role.findMany({
        where,
        include: {
          _count: {
            select: {
              crewRoles: true
            }
          }
        }
      });

      rolesWithCount.sort((a, b) => {
        const countA = a._count?.crewRoles || 0;
        const countB = b._count?.crewRoles || 0;
        return sortOrder === 'desc' ? countB - countA : countA - countB;
      });

      const paginatedRoles = rolesWithCount.slice(offset, offset + limit);
      const totalCount = rolesWithCount.length;
      const totalPages = Math.ceil(totalCount / limit);

      if (exportFormat === 'csv') {
        const csv = [
          'ID,Nombre,Departamento,Descripci√≥n,Principal,Activo,Usos',
          ...rolesWithCount.map(role => 
            `${role.id},"${role.name}","${role.department}","${role.description || ''}",${role.isMainRole ? 'S√≠' : 'No'},${role.isActive ? 'S√≠' : 'No'},${role._count.crewRoles}`
          )
        ].join('\n');

        return new NextResponse(csv, {
          headers: {
            'Content-Type': 'text/csv',
            'Content-Disposition': `attachment; filename="roles_${new Date().toISOString().split('T')[0]}.csv"`
          }
        });
      }

      return NextResponse.json({
        data: paginatedRoles,
        totalCount,
        page,
        totalPages,
        hasMore: page < totalPages
      });
      
    } else {
      if (sortBy === 'name') {
        orderBy = { name: sortOrder };
      } else if (sortBy === 'department') {
        orderBy = [
          { department: sortOrder },
          { name: 'asc' }
        ];
      } else if (sortBy === 'createdAt') {
        orderBy = { createdAt: sortOrder };
      } else {
        orderBy = [
          { department: 'asc' },
          { name: 'asc' }
        ];
      }

      if (exportFormat === 'csv') {
        const roles = await prisma.role.findMany({
          where,
          include: {
            _count: {
              select: {
                crewRoles: true
              }
            }
          },
          orderBy
        });

        const csv = [
          'ID,Nombre,Departamento,Descripci√≥n,Principal,Activo,Usos',
          ...roles.map(role => 
            `${role.id},"${role.name}","${role.department}","${role.description || ''}",${role.isMainRole ? 'S√≠' : 'No'},${role.isActive ? 'S√≠' : 'No'},${role._count.crewRoles}`
          )
        ].join('\n');

        return new NextResponse(csv, {
          headers: {
            'Content-Type': 'text/csv',
            'Content-Disposition': `attachment; filename="roles_${new Date().toISOString().split('T')[0]}.csv"`
          }
        });
      }

      const [roles, totalCount] = await Promise.all([
        prisma.role.findMany({
          where,
          include: {
            _count: {
              select: {
                crewRoles: true
              }
            }
          },
          orderBy,
          skip: offset,
          take: limit
        }),
        prisma.role.count({ where })
      ]);

      const totalPages = Math.ceil(totalCount / limit);

      return NextResponse.json({
        data: roles,
        totalCount,
        page,
        totalPages,
        hasMore: page < totalPages
      });
    }

  } catch (error) {
    console.error('Error fetching roles:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    const validatedData = roleSchema.parse(body);
    
    const baseSlug = generateSlug(validatedData.name);
    let slug = baseSlug;
    let counter = 1;
    
    while (await prisma.role.findUnique({ where: { slug } })) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    const role = await prisma.role.create({
      data: {
        ...validatedData,
        slug,
        isActive: validatedData.isActive ?? true,
        isMainRole: validatedData.isMainRole ?? false
      },
      include: {
        _count: {
          select: {
            crewRoles: true
          }
        }
      }
    });

    return NextResponse.json(role, { status: 201 });

  } catch (error) {
    console.error('Error creating role:', error);
    
    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/roles/seed/route.ts
// ==================================================
// src/app/api/roles/seed/route.ts

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { Department } from '@/lib/roles/rolesTypes';
import { generateSlug } from '@/lib/utils/slugs';

// Roles iniciales por departamento
const INITIAL_ROLES_BY_DEPARTMENT = {
  [Department.DIRECCION]: [
    'Director',
    'Codirector', 
    'Primer Asistente de Direcci√≥n',
    'Segundo Asistente de Direcci√≥n',
    'Tercer Asistente de Direcci√≥n',
    'Ayudante de Direcci√≥n',
    'Continuista',
    'Script',
    'Director de Casting',
    'Asistente de Casting',
    'Casting'
  ],
  
  [Department.PRODUCCION]: [
    'Productor Ejecutivo',
    'Productor',
    'Coproductor',
    'Productor Asociado',
    'Producci√≥n Ejecutiva',
    'Jefe de Producci√≥n',
    'Direcci√≥n de Producci√≥n',
    'Coordinaci√≥n de Producci√≥n',
    'Asistente de Producci√≥n',
    'Dise√±o de Producci√≥n',
    'Coordinador General',
    'Jefe de Locaciones',
    'Chofer',
    'Transporte',
    'Localizaci√≥n'
  ],
  
  [Department.GUION]: [
    'Guionista',
    'Coguionista',
    'Adaptaci√≥n',
    'Argumento',
    'Historia Original',
    'Colaboraci√≥n en Gui√≥n',
    'Gui√≥n y Continuidad'
  ],
  
  [Department.FOTOGRAFIA]: [
    'Director de Fotograf√≠a',
    'Operador de C√°mara',
    'Primer Asistente de C√°mara',
    'Segundo Asistente de C√°mara',
    'Gaffer',
    'Electricista',
    'C√°mara y Electricidad'
  ],
  
  [Department.ARTE]: [
    'Director de Arte',
    'Dise√±ador de Producci√≥n',
    'Ambientador',
    'Escen√≥grafo',
    'Utilero',
    'Props Master',
    'Decoraci√≥n',
    'Especialistas'
  ],
  
  [Department.MONTAJE]: [
    'Editor',
    'Montajista',
    'Asistente de Montaje',
    'Edici√≥n',
    'Colorista'
  ],
  
  [Department.SONIDO]: [
    'Director de Sonido',
    'Sonidista',
    'Microfonista',
    'Dise√±ador de Sonido',
    'Editor de Di√°logos',
    'Mezclador'
  ],
  
  [Department.MUSICA]: [
    'Compositor',
    'Director Musical',
    'Arreglador',
    'Supervisor Musical',
    'M√∫sica',
    'Composici√≥n'
  ],
  
  [Department.VESTUARIO]: [
    'Dise√±ador de Vestuario',
    'Vestuarista',
    'Asistente de Vestuario',
    'Ambientador de Vestuario'
  ],
  
  [Department.MAQUILLAJE]: [
    'Maquillador Principal',
    'Caracterizador',
    'Efectos Especiales de Maquillaje',
    'Peluquero',
    'Asistente de Maquillaje',
    'Maquillaje'
  ],
  
  [Department.EFECTOS]: [
    'Supervisor de Efectos Especiales',
    'Efectos Especiales',
    'Pirotecnia',
    'Efectos Mec√°nicos',
    'Supervisor de VFX',
    'Artista VFX',
    'Coordinador VFX',
    'Editor VFX',
    'Efectos Visuales',
    'Director de Animaci√≥n',
    'Animador',
    'Asistente de Animaci√≥n',
    'Animaci√≥n'
  ]
} as const;

// Roles principales (primeros de cada departamento + algunos espec√≠ficos)
const MAIN_ROLES = [
  'Director',
  'Productor Ejecutivo',
  'Productor',
  'Guionista',
  'Director de Fotograf√≠a',
  'Director de Arte',
  'Editor',
  'Director de Sonido',
  'Compositor',
  'Dise√±ador de Vestuario',
  'Maquillador Principal',
  'Supervisor de Efectos Especiales',
  'Supervisor de VFX'
];

export async function POST() {
  try {
    let created = 0;
    let skipped = 0;

    console.log('üå± Iniciando seeding de roles...');

    for (const [department, roleNames] of Object.entries(INITIAL_ROLES_BY_DEPARTMENT)) {
      console.log(`\nüìÅ Procesando departamento: ${department}`);
      
      for (let i = 0; i < roleNames.length; i++) {
        const roleName = roleNames[i];
        const roleSlug = generateSlug(roleName);
        
        // Verificar si el rol ya existe
        const existingRole = await prisma.role.findUnique({
          where: { slug: roleSlug }
        });

        if (existingRole) {
          console.log(`‚è≠Ô∏è Rol "${roleName}" ya existe`);
          skipped++;
          continue;
        }

        // Determinar si es rol principal
        const isMainRole = MAIN_ROLES.includes(roleName);

        // Crear rol
        await prisma.role.create({
          data: {
            name: roleName,
            slug: roleSlug,
            department: department as Department,
            isMainRole,
            isActive: true
          }
        });

        console.log(`‚úÖ Creado rol: ${roleName}${isMainRole ? ' (Principal)' : ''}`);
        created++;
      }
    }

    console.log(`\nüéâ Seeding completado: ${created} roles creados, ${skipped} omitidos`);

    return NextResponse.json({
      success: true,
      created,
      skipped,
      message: `Se crearon ${created} roles nuevos (${skipped} ya exist√≠an)`
    });

  } catch (error) {
    console.error('‚ùå Error en seeding:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Error interno del servidor',
        details: error instanceof Error ? error.message : 'Error desconocido'
      },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/roles/[id]/route.ts
// ==================================================
// src/app/api/roles/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { roleSchema } from '@/lib/roles/rolesTypes';
import { generateSlug } from '@/lib/utils/slugs';

interface RouteContext {
  params: {
    id: string;
  };
}

export async function GET(
  request: NextRequest,
  { params }: RouteContext
) {
  try {
    const id = parseInt(params.id);

    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      );
    }

    const role = await prisma.role.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            crewRoles: true
          }
        }
      }
    });

    if (!role) {
      return NextResponse.json(
        { error: 'Rol no encontrado' },
        { status: 404 }
      );
    }

    return NextResponse.json(role);

  } catch (error) {
    console.error('Error fetching role:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: RouteContext
) {
  try {
    const id = parseInt(params.id);

    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      );
    }

    const body = await request.json();
    const validatedData = roleSchema.parse(body);

    // Verificar que el rol existe
    const existingRole = await prisma.role.findUnique({
      where: { id }
    });

    if (!existingRole) {
      return NextResponse.json(
        { error: 'Rol no encontrado' },
        { status: 404 }
      );
    }

    // Generar nuevo slug si cambi√≥ el nombre
    let slug = existingRole.slug;
    if (validatedData.name !== existingRole.name) {
      const baseSlug = generateSlug(validatedData.name);
      slug = baseSlug;
      let counter = 1;
      
      while (await prisma.role.findFirst({ 
        where: { 
          slug,
          id: { not: id }
        } 
      })) {
        slug = `${baseSlug}-${counter}`;
        counter++;
      }
    }

    // Actualizar rol
    const role = await prisma.role.update({
      where: { id },
      data: {
        ...validatedData,
        slug
      },
      include: {
        _count: {
          select: {
            crewRoles: true
          }
        }
      }
    });

    return NextResponse.json(role);

  } catch (error) {
    console.error('Error updating role:', error);
    
    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: RouteContext
) {
  try {
    const id = parseInt(params.id);

    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'ID inv√°lido' },
        { status: 400 }
      );
    }

    // Verificar que el rol existe
    const existingRole = await prisma.role.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            crewRoles: true
          }
        }
      }
    });

    if (!existingRole) {
      return NextResponse.json(
        { error: 'Rol no encontrado' },
        { status: 404 }
      );
    }

    // Verificar si tiene relaciones activas
    if (existingRole._count.crewRoles > 0) {
      return NextResponse.json(
        { 
          error: 'No se puede eliminar el rol porque est√° asignado a pel√≠culas'
        },
        { status: 400 }
      );
    }

    // Eliminar rol
    await prisma.role.delete({
      where: { id }
    });

    return new NextResponse(null, { status: 204 });

  } catch (error) {
    console.error('Error deleting role:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

// ==================================================
// src/app/api/screening-venues/route.ts
// ==================================================
// src/app/api/screening-venues/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'
import { z } from 'zod'

// Schema de validaci√≥n
const screeningVenueSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: z.enum(['CINEMA', 'STREAMING', 'TV_CHANNEL', 'OTHER']),
  description: z.string().optional(),
  logoUrl: z.string().url().optional().or(z.literal('')),
  website: z.string().url().optional().or(z.literal('')),
  address: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  country: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  isActive: z.boolean().optional()
})

// GET /api/screening-venues - Listar pantallas de estreno
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const search = searchParams.get('search') || ''
    const type = searchParams.get('type') || ''
    const isActive = searchParams.get('isActive')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '20')

    const skip = (page - 1) * limit

    // Construir filtros
    const where: any = {}

    if (search) {
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } }
      ]
    }

    if (type) {
      where.type = type
    }

    if (isActive !== null && isActive !== '') {
      where.isActive = isActive === 'true'
    }

    // Obtener total
    const total = await prisma.screeningVenue.count({ where })

    // Obtener venues CON el conteo real de pel√≠culas asociadas
    const venues = await prisma.screeningVenue.findMany({
      where,
      skip,
      take: limit,
      orderBy: [
        { type: 'asc' },
        { name: 'asc' }
      ],
      include: {
        _count: {
          select: {
            screenings: true  // Conteo real de pel√≠culas asociadas
          }
        }
      }
    })

    return NextResponse.json({
      venues,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Error fetching screening venues:', error)
    return NextResponse.json(
      { error: 'Error al obtener las pantallas de estreno' },
      { status: 500 }
    )
  }
}

// POST /api/screening-venues - Crear nueva pantalla de estreno
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validar datos
    const validatedData = screeningVenueSchema.parse(body)
    
    // Generar slug √∫nico
    let slug = createSlug(validatedData.name)
    let slugExists = await prisma.screeningVenue.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(validatedData.name)}-${counter}`
      slugExists = await prisma.screeningVenue.findUnique({ where: { slug } })
      counter++
    }

    const venue = await prisma.screeningVenue.create({
      data: {
        ...validatedData,
        slug
      },
      include: {
        _count: {
          select: {
            screenings: true
          }
        }
      }
    })

    return NextResponse.json(venue, { status: 201 })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.errors },
        { status: 400 }
      )
    }
    
    console.error('Error creating screening venue:', error)
    return NextResponse.json(
      { error: 'Error al crear la pantalla de estreno' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/screening-venues/[id]/route.ts
// ==================================================
// src/app/api/screening-venues/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'

// Schema de validaci√≥n
const screeningVenueSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: z.enum(['CINEMA', 'STREAMING', 'TV_CHANNEL', 'OTHER']),
  description: z.string().optional(),
  logoUrl: z.string().url().optional().or(z.literal('')),
  website: z.string().url().optional().or(z.literal('')),
  address: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  country: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  isActive: z.boolean().optional()
})

// GET /api/screening-venues/[id] - Obtener pantalla por ID
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    const venue = await prisma.screeningVenue.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            screenings: true  // Conteo real de pel√≠culas asociadas
          }
        }
      }
    })

    if (!venue) {
      return NextResponse.json(
        { error: 'Pantalla de estreno no encontrada' },
        { status: 404 }
      )
    }

    return NextResponse.json(venue)
  } catch (error) {
    console.error('Error fetching screening venue:', error)
    return NextResponse.json(
      { error: 'Error al obtener la pantalla de estreno' },
      { status: 500 }
    )
  }
}

// PUT /api/screening-venues/[id] - Actualizar pantalla
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    
    // Validar datos
    const validatedData = screeningVenueSchema.parse(body)
    
    // Verificar que existe
    const existingVenue = await prisma.screeningVenue.findUnique({
      where: { id }
    })
    
    if (!existingVenue) {
      return NextResponse.json(
        { error: 'Pantalla de estreno no encontrada' },
        { status: 404 }
      )
    }

    const venue = await prisma.screeningVenue.update({
      where: { id },
      data: validatedData,
      include: {
        _count: {
          select: {
            screenings: true
          }
        }
      }
    })

    return NextResponse.json(venue)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.errors },
        { status: 400 }
      )
    }
    
    console.error('Error updating screening venue:', error)
    return NextResponse.json(
      { error: 'Error al actualizar la pantalla de estreno' },
      { status: 500 }
    )
  }
}

// DELETE /api/screening-venues/[id] - Eliminar pantalla
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    // Verificar que existe y obtener conteo de pel√≠culas asociadas
    const venue = await prisma.screeningVenue.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            screenings: true
          }
        }
      }
    })
    
    if (!venue) {
      return NextResponse.json(
        { error: 'Pantalla de estreno no encontrada' },
        { status: 404 }
      )
    }

    // ‚úÖ VERIFICAR SI HAY PEL√çCULAS ASOCIADAS
    if (venue._count.screenings > 0) {
      return NextResponse.json(
        { 
          error: `No se puede eliminar la pantalla de estreno "${venue.name}" porque tiene ${venue._count.screenings} pel√≠cula${venue._count.screenings > 1 ? 's' : ''} asociada${venue._count.screenings > 1 ? 's' : ''}`,
          moviesCount: venue._count.screenings
        },
        { status: 409 }  // 409 Conflict
      )
    }

    // Si no hay pel√≠culas asociadas, proceder con la eliminaci√≥n
    await prisma.screeningVenue.delete({
      where: { id }
    })

    return NextResponse.json(
      { message: 'Pantalla de estreno eliminada exitosamente' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting screening venue:', error)
    return NextResponse.json(
      { error: 'Error al eliminar la pantalla de estreno' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/search/full/route.ts
// ==================================================
// src/app/api/search/full/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const query = searchParams.get('q')

    if (!query || query.length < 2) {
      return NextResponse.json({ 
        movies: [], 
        people: [], 
        totalMovies: 0,
        totalPeople: 0
      })
    }

    const searchQuery = query.toLowerCase().trim()
    const searchPattern = `%${searchQuery}%`

    // Intentar b√∫squeda con unaccent primero
    try {
      // B√∫squeda de pel√≠culas con normalizaci√≥n
      const movies = await prisma.$queryRaw<any[]>`
        SELECT 
          id,
          slug,
          title,
          year,
          release_year as "releaseYear",
          release_month as "releaseMonth",
          release_day as "releaseDay",
          poster_url as "posterUrl",
          synopsis
        FROM movies
        WHERE 
          unaccent(LOWER(title)) LIKE unaccent(${searchPattern})
        ORDER BY 
          COALESCE(year, release_year) DESC NULLS LAST,
          title ASC
        LIMIT 50
      `

      // B√∫squeda de personas con normalizaci√≥n
      const people = await prisma.$queryRaw<any[]>`
        SELECT 
          p.id,
          p.slug,
          p.first_name as "firstName",
          p.last_name as "lastName",
          p.photo_url as "photoUrl",
          p.birth_year as "birthYear",
          p.birth_month as "birthMonth",
          p.birth_day as "birthDay",
          p.death_year as "deathYear",
          p.death_month as "deathMonth",
          p.death_day as "deathDay",
          p.biography,
          (SELECT COUNT(*)::int FROM movie_cast WHERE person_id = p.id) as cast_roles,
          (SELECT COUNT(*)::int FROM movie_crew WHERE person_id = p.id) as crew_roles
        FROM people p
        WHERE p.is_active = true
        AND (
          unaccent(LOWER(COALESCE(p.first_name, ''))) LIKE unaccent(${searchPattern})
          OR unaccent(LOWER(COALESCE(p.last_name, ''))) LIKE unaccent(${searchPattern})
          OR unaccent(LOWER(COALESCE(p.real_name, ''))) LIKE unaccent(${searchPattern})
          OR unaccent(LOWER(COALESCE(p.first_name, '') || ' ' || COALESCE(p.last_name, ''))) LIKE unaccent(${searchPattern})
        )
        ORDER BY 
          (
            (SELECT COUNT(*) FROM movie_cast WHERE person_id = p.id) +
            (SELECT COUNT(*) FROM movie_crew WHERE person_id = p.id)
          ) DESC,
          p.last_name ASC NULLS LAST,
          p.first_name ASC NULLS LAST
        LIMIT 50
      `

      // Formatear personas con _count
      const formattedPeople = people.map(person => ({
        ...person,
        _count: {
          castRoles: person.cast_roles || 0,
          crewRoles: person.crew_roles || 0
        }
      }))

      return NextResponse.json({
        movies: movies,
        people: formattedPeople,
        totalMovies: movies.length,
        totalPeople: formattedPeople.length
      })

    } catch (err) {
      console.log('Unaccent not available, using fallback search')
      
      // Fallback: b√∫squeda est√°ndar sin normalizaci√≥n
      const [movies, people] = await Promise.all([
        prisma.movie.findMany({
          where: {
            OR: [
              { title: { contains: query, mode: 'insensitive' } },
            ]
          },
          select: {
            id: true,
            slug: true,
            title: true,
            year: true,
            releaseYear: true,
            releaseMonth: true,
            releaseDay: true,
            posterUrl: true,
            synopsis: true
          },
          orderBy: [
            { year: 'desc' },
            { releaseYear: 'desc' },
            { title: 'asc' }
          ],
          take: 50
        }),
        
        prisma.person.findMany({
          where: {
            isActive: true,
            OR: [
              { firstName: { contains: query, mode: 'insensitive' } },
              { lastName: { contains: query, mode: 'insensitive' } },
              { realName: { contains: query, mode: 'insensitive' } }
            ]
          },
          select: {
            id: true,
            slug: true,
            firstName: true,
            lastName: true,
            photoUrl: true,
            birthYear: true,
            birthMonth: true,
            birthDay: true,
            deathYear: true,
            deathMonth: true,
            deathDay: true,
            biography: true,
            _count: {
              select: {
                castRoles: true,
                crewRoles: true
              }
            }
          },
          take: 50
        })
      ])

      // Ordenar personas por total de participaciones
      const sortedPeople = people.sort((a, b) => {
        const totalA = (a._count?.castRoles || 0) + (a._count?.crewRoles || 0)
        const totalB = (b._count?.castRoles || 0) + (b._count?.crewRoles || 0)
        return totalB - totalA
      })

      return NextResponse.json({
        movies: movies,
        people: sortedPeople,
        totalMovies: movies.length,
        totalPeople: sortedPeople.length
      })
    }

  } catch (error) {
    console.error('Full search error:', error)
    return NextResponse.json(
      { error: 'Error searching' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/search/route.ts
// ==================================================
// src/app/api/search/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

/**
 * Obtiene el a√±o a mostrar para una pel√≠cula.
 * Prioridad: a√±o de producci√≥n (year) > a√±o de estreno (releaseYear)
 * Retorna null si ambos est√°n vac√≠os o son 0
 */
function getDisplayYear(year: number | null, releaseYear: number | null): number | null {
  // Prioridad 1: a√±o de producci√≥n
  if (year && year > 0) {
    return year
  }
  
  // Prioridad 2: a√±o de estreno
  if (releaseYear && releaseYear > 0) {
    return releaseYear
  }
  
  // Ninguno disponible
  return null
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const query = searchParams.get('q')
    const limit = parseInt(searchParams.get('limit') || '10')

    if (!query || query.length < 2) {
      return NextResponse.json({ 
        movies: [], 
        people: [], 
        total: 0 
      })
    }

    const searchQuery = query.toLowerCase().trim()
    const searchPattern = `%${searchQuery}%`
    
    // B√∫squeda de pel√≠culas con normalizaci√≥n de acentos
    let movies: any[] = []
    try {
      movies = await prisma.$queryRaw`
        SELECT 
          id,
          slug,
          title,
          year,
          release_year as "releaseYear",
          poster_url as "posterUrl"
        FROM movies
        WHERE 
          unaccent(LOWER(title)) LIKE unaccent(${searchPattern})
        ORDER BY 
          CASE 
            WHEN unaccent(LOWER(title)) = unaccent(${searchQuery}) THEN 1
            WHEN unaccent(LOWER(title)) LIKE unaccent(${searchQuery + '%'}) THEN 2
            ELSE 3
          END,
          title ASC
        LIMIT ${limit}
      `
    } catch (err) {
      console.log('Falling back to standard search for movies')
      // Fallback si unaccent no est√° instalado
      const movieResults = await prisma.movie.findMany({
        where: {
          title: { contains: query, mode: 'insensitive' }
        },
        select: {
          id: true,
          slug: true,
          title: true,
          year: true,
          releaseYear: true,
          posterUrl: true
        },
        take: limit,
        orderBy: { title: 'asc' }
      })
      movies = movieResults
    }

    // B√∫squeda de personas con normalizaci√≥n de acentos
    const searchTerms = searchQuery.split(/\s+/).filter(term => term.length > 0)
    let people: any[] = []
    
    try {
      if (searchTerms.length === 1) {
        // B√∫squeda simple con un t√©rmino
        people = await prisma.$queryRaw`
          SELECT 
            id,
            slug,
            first_name,
            last_name,
            real_name,
            photo_url,
            birth_year,
            death_year
          FROM people
          WHERE is_active = true
          AND (
            unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(real_name, ''))) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) LIKE unaccent(${searchPattern})
          )
          ORDER BY 
            CASE 
              WHEN unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) = unaccent(${searchQuery}) THEN 1
              WHEN unaccent(LOWER(COALESCE(first_name, ''))) = unaccent(${searchQuery}) OR unaccent(LOWER(COALESCE(last_name, ''))) = unaccent(${searchQuery}) THEN 2
              WHEN unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) LIKE unaccent(${searchQuery + '%'}) THEN 3
              ELSE 4
            END,
            last_name ASC NULLS LAST,
            first_name ASC NULLS LAST
          LIMIT ${limit}
        `
      } else {
        // B√∫squeda con m√∫ltiples t√©rminos
        const firstTerm = `%${searchTerms[0]}%`
        const secondTerm = `%${searchTerms[1]}%`
        
        people = await prisma.$queryRaw`
          SELECT 
            id,
            slug,
            first_name,
            last_name,
            real_name,
            photo_url,
            birth_year,
            death_year
          FROM people
          WHERE is_active = true
          AND (
            unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(last_name, '') || ' ' || COALESCE(first_name, ''))) LIKE unaccent(${searchPattern})
            OR unaccent(LOWER(COALESCE(real_name, ''))) LIKE unaccent(${searchPattern})
            OR (
              (unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${firstTerm}) OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${firstTerm}))
              AND
              (unaccent(LOWER(COALESCE(first_name, ''))) LIKE unaccent(${secondTerm}) OR unaccent(LOWER(COALESCE(last_name, ''))) LIKE unaccent(${secondTerm}))
            )
          )
          ORDER BY 
            CASE 
              WHEN unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) = unaccent(${searchQuery}) THEN 1
              WHEN unaccent(LOWER(COALESCE(last_name, '') || ' ' || COALESCE(first_name, ''))) = unaccent(${searchQuery}) THEN 2
              WHEN unaccent(LOWER(COALESCE(first_name, '') || ' ' || COALESCE(last_name, ''))) LIKE unaccent(${searchQuery + '%'}) THEN 3
              ELSE 4
            END,
            last_name ASC NULLS LAST,
            first_name ASC NULLS LAST
          LIMIT ${limit}
        `
      }
    } catch (err) {
      console.log('Falling back to standard search for people')
      // Fallback si unaccent no est√° instalado
      const peopleResults = await prisma.person.findMany({
        where: {
          isActive: true,
          OR: [
            { firstName: { contains: query, mode: 'insensitive' } },
            { lastName: { contains: query, mode: 'insensitive' } },
            { realName: { contains: query, mode: 'insensitive' } }
          ]
        },
        select: {
          id: true,
          slug: true,
          firstName: true,
          lastName: true,
          photoUrl: true,
          birthYear: true,
          deathYear: true
        },
        take: limit,
        orderBy: [
          { lastName: 'asc' },
          { firstName: 'asc' }
        ]
      })
      
      people = peopleResults.map(p => ({
        id: p.id,
        slug: p.slug,
        first_name: p.firstName,
        last_name: p.lastName,
        photo_url: p.photoUrl,
        birth_year: p.birthYear,
        death_year: p.deathYear
      }))
    }

    // Formatear resultados
    const formattedMovies = movies.map((movie: any) => ({
      id: movie.id,
      slug: movie.slug,
      title: movie.title,
      // Usar l√≥gica de prioridad: a√±o de producci√≥n > a√±o de estreno
      year: getDisplayYear(movie.year, movie.releaseYear),
      posterUrl: movie.posterUrl,
      type: 'movie' as const
    }))

    const formattedPeople = people.map(person => ({
      id: person.id,
      slug: person.slug,
      name: `${person.first_name || ''} ${person.last_name || ''}`.trim() || person.real_name || 'Sin nombre',
      photoUrl: person.photo_url,
      birthYear: person.birth_year,
      deathYear: person.death_year,
      type: 'person' as const
    }))

    return NextResponse.json({
      movies: formattedMovies,
      people: formattedPeople,
      total: formattedMovies.length + formattedPeople.length
    })

  } catch (error) {
    console.error('Search error:', error)
    return NextResponse.json(
      { error: 'Error searching' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/search/test/route.ts
// ==================================================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'

export async function GET() {
  try {
    // Test 1: Verificar que Prisma funciona
    const movieCount = await prisma.movie.count()
    const personCount = await prisma.person.count()
    
    // Test 2: Obtener una pel√≠cula de muestra
    const sampleMovie = await prisma.movie.findFirst({
      select: {
        id: true,
        title: true,
        slug: true
      }
    })
    
    // Test 3: Obtener una persona de muestra
    const samplePerson = await prisma.person.findFirst({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        slug: true
      }
    })
    
    return NextResponse.json({
      status: 'ok',
      counts: {
        movies: movieCount,
        people: personCount
      },
      samples: {
        movie: sampleMovie,
        person: samplePerson
      }
    })
  } catch (error) {
    console.error('Test error:', error)
    return NextResponse.json(
      { 
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error',
        errorStack: error instanceof Error ? error.stack : undefined
      },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/stats/route.ts
// ==================================================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'
export const revalidate = 0

export async function GET() {
  try {
    const totalPeliculas = await prisma.movie.count()
    const totalPersonas = await prisma.person.count()

    const efemeridesResult = await prisma.$queryRaw<[{
      total_efemerides: bigint
    }]>`
      WITH counts AS (
        SELECT 
          COUNT(*) FILTER (WHERE release_year IS NOT NULL 
                            AND release_month IS NOT NULL 
                            AND release_day IS NOT NULL) as peliculas_estreno,
          COUNT(*) FILTER (WHERE filming_start_year IS NOT NULL 
                            AND filming_start_month IS NOT NULL 
                            AND filming_start_day IS NOT NULL) as peliculas_inicio_rodaje,
          COUNT(*) FILTER (WHERE filming_end_year IS NOT NULL 
                            AND filming_end_month IS NOT NULL 
                            AND filming_end_day IS NOT NULL) as peliculas_fin_rodaje
        FROM movies
      ),
      people_counts AS (
        SELECT 
          COUNT(*) FILTER (WHERE birth_year IS NOT NULL 
                            AND birth_month IS NOT NULL 
                            AND birth_day IS NOT NULL) as personas_nacimiento,
          COUNT(*) FILTER (WHERE death_year IS NOT NULL 
                            AND death_month IS NOT NULL 
                            AND death_day IS NOT NULL) as personas_muerte
        FROM people
      )
      SELECT 
        (c.peliculas_estreno + c.peliculas_inicio_rodaje + c.peliculas_fin_rodaje + 
         p.personas_nacimiento + p.personas_muerte) as total_efemerides
      FROM counts c, people_counts p
    `
    const totalEfemerides = Number(efemeridesResult[0]?.total_efemerides || 0)

    const totalAfiches = await prisma.movie.count({
      where: {
        posterUrl: { not: null },
        NOT: { posterUrl: '' }
      }
    })

    const totalFotos = await prisma.person.count({
      where: {
        photoUrl: { not: null },
        NOT: { photoUrl: '' }
      }
    })

    return NextResponse.json({
      peliculas: totalPeliculas,
      personas: totalPersonas,
      efemerides: totalEfemerides,
      afiches: totalAfiches,
      fotos: totalFotos,
    })
  } catch (error) {
    console.error('Error fetching stats:', error)
    return NextResponse.json({
      peliculas: 0,
      personas: 0,
      efemerides: 0,
      afiches: 0,
      fotos: 0,
    })
  }
}

// ==================================================
// src/app/api/themes/route.ts
// ==================================================
// src/app/api/themes/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/themes - Listar todos los themes/keywords
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const search = searchParams.get('search') || ''
    const sortBy = searchParams.get('sortBy') || 'name'
    const sortOrder = searchParams.get('sortOrder') || 'asc'

    const where = search ? {
      OR: [
        { name: { contains: search, mode: 'insensitive' as const } },
        { description: { contains: search, mode: 'insensitive' as const } }
      ]
    } : {}

    const themes = await prisma.theme.findMany({
      where,
      orderBy: {
        [sortBy]: sortOrder
      },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })

    // Formatear respuesta con contador de pel√≠culas
    const formattedThemes = themes.map(theme => ({
      ...theme,
      movieCount: theme._count.movies
    }))

    return NextResponse.json(formattedThemes)
  } catch (error) {
    console.error('Error fetching themes:', error)
    return NextResponse.json(
      { error: 'Error al obtener los themes' },
      { status: 500 }
    )
  }
}

// POST /api/themes - Crear nuevo theme/keyword
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validar datos requeridos
    if (!body.name) {
      return NextResponse.json(
        { error: 'El nombre es requerido' },
        { status: 400 }
      )
    }

    // Generar slug √∫nico
    let slug = createSlug(body.name)
    let slugExists = await prisma.theme.findUnique({ where: { slug } })
    let counter = 1
    
    while (slugExists) {
      slug = `${createSlug(body.name)}-${counter}`
      slugExists = await prisma.theme.findUnique({ where: { slug } })
      counter++
    }

    const theme = await prisma.theme.create({
      data: {
        name: body.name,
        slug,
        description: body.description
      }
    })

    return NextResponse.json(theme, { status: 201 })
  } catch (error) {
    console.error('Error creating theme:', error)
    return NextResponse.json(
      { error: 'Error al crear el theme' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/api/themes/[id]/route.ts
// ==================================================
// src/app/api/themes/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createSlug } from '@/lib/utils'

// GET /api/themes/[id] - Obtener theme espec√≠fico
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    const theme = await prisma.theme.findUnique({
      where: { id },
      include: {
        movies: {
          include: {
            movie: {
              select: {
                id: true,
                title: true,
                slug: true,
                year: true,
                posterUrl: true
              }
            }
          }
        },
        _count: {
          select: { movies: true }
        }
      }
    })

    if (!theme) {
      return NextResponse.json(
        { error: 'Theme no encontrado' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      ...theme,
      movieCount: theme._count.movies
    })
  } catch (error) {
    console.error('Error fetching theme:', error)
    return NextResponse.json(
      { error: 'Error al obtener el theme' },
      { status: 500 }
    )
  }
}

// PUT /api/themes/[id] - Actualizar theme
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    const body = await request.json()
    
    // Verificar que existe
    const existingTheme = await prisma.theme.findUnique({
      where: { id }
    })
    
    if (!existingTheme) {
      return NextResponse.json(
        { error: 'Theme no encontrado' },
        { status: 404 }
      )
    }

    // Si se cambia el nombre, generar nuevo slug
    let updateData: any = {
      description: body.description
    }

    if (body.name && body.name !== existingTheme.name) {
      let slug = createSlug(body.name)
      let slugExists = await prisma.theme.findUnique({ 
        where: { 
          slug,
          NOT: { id }
        } 
      })
      let counter = 1
      
      while (slugExists) {
        slug = `${createSlug(body.name)}-${counter}`
        slugExists = await prisma.theme.findUnique({ 
          where: { 
            slug,
            NOT: { id }
          } 
        })
        counter++
      }

      updateData.name = body.name
      updateData.slug = slug
    }

    const theme = await prisma.theme.update({
      where: { id },
      data: updateData
    })

    return NextResponse.json(theme)
  } catch (error) {
    console.error('Error updating theme:', error)
    return NextResponse.json(
      { error: 'Error al actualizar el theme' },
      { status: 500 }
    )
  }
}

// DELETE /api/themes/[id] - Eliminar theme
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id)
    
    // Verificar que no est√© en uso
    const themeWithMovies = await prisma.theme.findUnique({
      where: { id },
      include: {
        _count: {
          select: { movies: true }
        }
      }
    })
    
    if (!themeWithMovies) {
      return NextResponse.json(
        { error: 'Theme no encontrado' },
        { status: 404 }
      )
    }

    if (themeWithMovies._count.movies > 0) {
      return NextResponse.json(
        { error: `No se puede eliminar el theme porque est√° asignado a ${themeWithMovies._count.movies} pel√≠cula(s)` },
        { status: 400 }
      )
    }

    await prisma.theme.delete({
      where: { id }
    })

    return NextResponse.json(
      { message: 'Theme eliminado exitosamente' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting theme:', error)
    return NextResponse.json(
      { error: 'Error al eliminar el theme' },
      { status: 500 }
    )
  }
}

// ==================================================
// src/app/layout.tsx
// ==================================================
// /src/app/layout.tsx
import type { Metadata } from 'next'
import { ReactNode } from 'react'
import './globals.css'

export const metadata: Metadata = {
  title: 'cinenacional.com',
  description: 'Base de datos del cine argentino',
}

export default function RootLayout({
  children,
}: {
  children: ReactNode
}) {
  return (
    <html lang="es">
      <body>
        {children}
      </body>
    </html>
  )
}

// ==================================================
// src/app/test/page.tsx
// ==================================================
// src/app/test/page.tsx
export default function TestPage() {
  return <div>Test</div>;
}

// ==================================================
// src/app/test-env/page.tsx
// ==================================================
// src/app/test-env/page.tsx
export default function TestEnv() {
  return (
    <div className="p-8">
      <h1 className="text-2xl mb-4">Variables de Cloudinary</h1>
      <pre className="bg-gray-100 p-4 rounded">
        {JSON.stringify({
          CLOUD_NAME: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME || 'NO DEFINIDO',
          API_KEY: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY ? 'DEFINIDO' : 'NO DEFINIDO',
          HAS_SECRET: process.env.CLOUDINARY_API_SECRET ? 'SI' : 'NO'
        }, null, 2)}
      </pre>
    </div>
  )
}

// ==================================================
// src/components/admin/AlternativeTitlesManager.tsx
// ==================================================
'use client'

import { useState, useEffect } from 'react'
import { Plus, X, Edit2, Save } from 'lucide-react'

interface AlternativeTitle {
  id?: number
  title: string
  description?: string
}

interface AlternativeTitlesManagerProps {
  onChange: (titles: AlternativeTitle[]) => void
  initialTitles?: AlternativeTitle[]
}

export default function AlternativeTitlesManager({ 
  onChange, 
  initialTitles = [] 
}: AlternativeTitlesManagerProps) {
  const [titles, setTitles] = useState<AlternativeTitle[]>(initialTitles)
  const [showForm, setShowForm] = useState(false)
  const [editingIndex, setEditingIndex] = useState<number | null>(null)
  const [currentTitle, setCurrentTitle] = useState<AlternativeTitle>({
    title: '',
    description: ''
  })

  useEffect(() => {
    onChange(titles)
  }, [titles])

  const handleAdd = () => {
    if (!currentTitle.title.trim()) return
    
    if (editingIndex !== null) {
      const updatedTitles = [...titles]
      updatedTitles[editingIndex] = currentTitle
      setTitles(updatedTitles)
      setEditingIndex(null)
    } else {
      setTitles([...titles, currentTitle])
    }
    
    setCurrentTitle({ title: '', description: '' })
    setShowForm(false)
  }

  const handleEdit = (index: number) => {
    setCurrentTitle(titles[index])
    setEditingIndex(index)
    setShowForm(true)
  }

  const handleDelete = (index: number) => {
    setTitles(titles.filter((_, i) => i !== index))
  }

  const handleCancel = () => {
    setCurrentTitle({ title: '', description: '' })
    setEditingIndex(null)
    setShowForm(false)
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium text-gray-900">T√≠tulos Alternativos</h3>
        {!showForm && (
          <button
            type="button"
            onClick={() => setShowForm(true)}
            className="inline-flex items-center gap-2 px-3 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            <Plus className="w-4 h-4" />
            Agregar T√≠tulo
          </button>
        )}
      </div>

      {/* Lista de t√≠tulos */}
      {titles.length > 0 && (
        <div className="space-y-2">
          {titles.map((title, index) => (
            <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
              <div className="flex-1">
                <p className="font-medium text-gray-900">{title.title}</p>
                {title.description && (
                  <p className="text-sm text-gray-600 mt-1">{title.description}</p>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => handleEdit(index)}
                  className="text-blue-600 hover:text-blue-800 p-1"
                  title="Editar"
                >
                  <Edit2 className="w-4 h-4" />
                </button>
                <button
                  type="button"
                  onClick={() => handleDelete(index)}
                  className="text-red-600 hover:text-red-800 p-1"
                  title="Eliminar"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Formulario */}
      {showForm && (
        <div className="border border-gray-200 rounded-lg p-4 space-y-4 bg-gray-50">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              T√≠tulo alternativo *
            </label>
            <input
              type="text"
              value={currentTitle.title}
              onChange={(e) => setCurrentTitle({ ...currentTitle, title: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              placeholder="Ej: Wild Tales"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Descripci√≥n (opcional)
            </label>
            <input
              type="text"
              value={currentTitle.description || ''}
              onChange={(e) => setCurrentTitle({ ...currentTitle, description: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              placeholder="Ej: T√≠tulo de rodaje, T√≠tulo internacional, T√≠tulo abreviado, etc."
            />
          </div>

          <div className="flex justify-end gap-3">
            <button
              type="button"
              onClick={handleCancel}
              className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
            >
              Cancelar
            </button>
            <button
              type="button"
              onClick={handleAdd}
              disabled={!currentTitle.title.trim()}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
            >
              <Save className="w-4 h-4" />
              {editingIndex !== null ? 'Actualizar' : 'Agregar'}
            </button>
          </div>
        </div>
      )}

      {titles.length === 0 && !showForm && (
        <p className="text-sm text-gray-500 italic">No hay t√≠tulos alternativos agregados</p>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/CloudinaryGallery.tsx
// ==================================================
// src/components/admin/CloudinaryGallery.tsx
'use client'

import { CldUploadWidget } from 'next-cloudinary'
import { useState } from 'react'
import { Plus, X } from 'lucide-react'
import { CloudinaryImage } from '@/components/movies/CloudinaryImage'

interface CloudinaryGalleryProps {
  movieId: number
  images: Array<{
    url: string
    publicId?: string
  }>
  onChange: (images: any[]) => void
}

export function CloudinaryGallery({ movieId, images, onChange }: CloudinaryGalleryProps) {
  const [galleryImages, setGalleryImages] = useState(images)

  const handleUploadSuccess = (result: any) => {
    const newImage = {
      url: result.info.secure_url,
      publicId: result.info.public_id,
      type: 'STILL'
    }
    
    const updated = [...galleryImages, newImage]
    setGalleryImages(updated)
    onChange(updated)
  }

  const handleRemove = (index: number) => {
    const updated = galleryImages.filter((_, i) => i !== index)
    setGalleryImages(updated)
    onChange(updated)
  }

  return (
    <div>
      <h3 className="text-lg font-medium text-gray-900 mb-4">
        Galer√≠a de Im√°genes
      </h3>
      
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        {galleryImages.map((image, index) => (
          <div key={index} className="relative group">
            <CloudinaryImage
              src={image.url}
              alt={`Imagen ${index + 1}`}
              width={300}
              height={200}
              className="w-full aspect-video object-cover rounded-lg"
            />
            <button
              type="button"
              onClick={() => handleRemove(index)}
              className="absolute top-2 right-2 p-1 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        ))}
        
        <CldUploadWidget
          uploadPreset="cinenacional-unsigned"
          options={{
            folder: `cinenacional/gallery/${movieId}`,
            sources: ['local', 'url'],
            multiple: true,
            maxFiles: 10
          }}
          onUpload={handleUploadSuccess}
        >
          {({ open }) => (
            <button
              type="button"
              onClick={() => open()}
              className="aspect-video border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center hover:border-gray-400 transition-colors"
            >
              <div className="text-center">
                <Plus className="w-8 h-8 text-gray-400 mx-auto" />
                <span className="text-sm text-gray-500 mt-2 block">
                  Agregar im√°genes
                </span>
              </div>
            </button>
          )}
        </CldUploadWidget>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/CloudinaryUploadWidget.tsx
// ==================================================
// src/components/admin/CloudinaryUploadWidget.tsx
'use client'

import { CldUploadWidget } from 'next-cloudinary'
import { useState, useEffect, useRef, useCallback } from 'react'
import { Upload, X, ImageIcon } from 'lucide-react'
import { toast } from 'react-hot-toast'

interface CloudinaryUploadWidgetProps {
  value?: string
  onChange: (url: string, publicId?: string) => void
  label: string
  type?: 'poster' | 'backdrop' | 'gallery' | 'person_photo'
  movieId?: string | number
  personId?: string | number
  disabled?: boolean
  aspectRatio?: string
  maxWidth?: number
  maxDisplayHeight?: number
}

export function CloudinaryUploadWidget({ 
  value, 
  onChange, 
  label, 
  type = 'poster',
  movieId,
  personId,
  disabled = false,
  aspectRatio: customAspectRatio,
  maxWidth = 1200,
  maxDisplayHeight
}: CloudinaryUploadWidgetProps) {
  const [imageUrl, setImageUrl] = useState(value || '')
  const [isUploading, setIsUploading] = useState(false)
  
  // Ref para controlar el widget y evitar m√∫ltiples instancias
  const widgetOpenRef = useRef<(() => void) | null>(null)
  const isOpeningRef = useRef(false)
  
  // Sincronizar con el valor externo
  useEffect(() => {
    setImageUrl(value || '')
  }, [value])

  // Limpiar al desmontar el componente
  useEffect(() => {
    return () => {
      // Restaurar el scroll al desmontar
      document.body.style.overflow = ''
      document.documentElement.style.overflow = ''
      document.body.style.position = ''
      // Reset de refs
      widgetOpenRef.current = null
      isOpeningRef.current = false
    }
  }, [])
  
  // Configuraci√≥n seg√∫n el tipo de imagen
  const getUploadPreset = () => {
    switch(type) {
      case 'poster':
        return {
          folder: `cinenacional/posters${movieId ? `/${movieId}` : ''}`,
          transformation: [
            { width: 500, height: 750, crop: 'fill', gravity: 'auto' }
          ],
          format: 'auto',
          quality: 'auto:best'
        }
      case 'backdrop':
        return {
          folder: `cinenacional/backdrops${movieId ? `/${movieId}` : ''}`,
          transformation: [
            { width: 1920, height: 1080, crop: 'fill', gravity: 'auto' }
          ],
          format: 'auto',
          quality: 'auto:best'
        }
      case 'person_photo':
        return {
          folder: `cinenacional/people${personId ? `/${personId}` : ''}`,
          transformation: [
            { width: maxWidth || 800, height: Math.round((maxWidth || 800) * 4/3), crop: 'fill', gravity: 'face' }
          ],
          format: 'auto',
          quality: 'auto:best'
        }
      default:
        return {
          folder: `cinenacional/gallery${movieId ? `/${movieId}` : ''}`,
          transformation: [
            { width: 1200, height: 1200, crop: 'limit' }
          ],
          format: 'auto',
          quality: 'auto:good'
        }
    }
  }

  // Funci√≥n para restaurar el scroll
  const restoreScroll = useCallback(() => {
    console.log('üîÑ Restoring scroll')
    document.body.style.overflow = ''
    document.documentElement.style.overflow = ''
    document.body.style.position = ''
    document.body.classList.remove('overflow-hidden')
    document.documentElement.classList.remove('overflow-hidden')
  }, [])

  // Handler de √©xito - mejorado con cleanup
  const handleUploadSuccess = useCallback((result: any) => {
    console.log('‚úÖ Upload success:', result)
    if (result.info) {
      const { secure_url, public_id } = result.info
      setImageUrl(secure_url)
      onChange(secure_url, public_id)
      toast.success('Imagen subida exitosamente')
    }
    
    // Resetear estado
    setIsUploading(false)
    isOpeningRef.current = false
    
    // Restaurar el scroll despu√©s de un delay
    setTimeout(() => {
      restoreScroll()
    }, 500)
  }, [onChange, restoreScroll])

  // Handler de cierre - mejorado
  const handleClose = useCallback(() => {
    console.log('üö™ Widget closed')
    setIsUploading(false)
    isOpeningRef.current = false
    restoreScroll()
  }, [restoreScroll])

  // Handler de error - mejorado
  const handleError = useCallback((error: any) => {
    console.error('‚ùå Upload error:', error)
    toast.error('Error al subir la imagen')
    setIsUploading(false)
    isOpeningRef.current = false
    restoreScroll()
  }, [restoreScroll])

  // Funci√≥n para abrir el widget - previene m√∫ltiples aperturas
  const openWidget = useCallback(() => {
    // Prevenir m√∫ltiples aperturas simult√°neas
    if (isOpeningRef.current) {
      console.log('‚ö†Ô∏è Widget already opening, skipping')
      return
    }
    
    if (widgetOpenRef.current) {
      console.log('üìÇ Opening widget')
      isOpeningRef.current = true
      setIsUploading(true)
      widgetOpenRef.current()
    }
  }, [])

  const handleRemove = useCallback(() => {
    setImageUrl('')
    onChange('', '')
    setIsUploading(false)
    isOpeningRef.current = false
    restoreScroll()
  }, [onChange, restoreScroll])

  // Determinar aspect ratio y dimensiones
  const aspectRatio = customAspectRatio || (
    type === 'poster' ? '2/3' : 
    type === 'backdrop' ? '16/9' : 
    type === 'person_photo' ? '3/4' :
    '1/1'
  )
  
  const [aspectWidth, aspectHeight] = aspectRatio.split('/').map(Number)
  
  const dimensions = 
    type === 'poster' ? '500x750px' : 
    type === 'backdrop' ? '1920x1080px' : 
    type === 'person_photo' ? '600x800px' :
    '1200x1200px'

  // Calcular dimensiones de display
  let displayWidth = '100%'
  let displayHeight = 'auto'
  
  if (maxDisplayHeight) {
    displayHeight = `${maxDisplayHeight}px`
    displayWidth = `${Math.round(maxDisplayHeight * aspectWidth / aspectHeight)}px`
  }

  return (
    <div>
      {label && (
        <label className="block text-sm font-medium text-gray-700 mb-2">
          {label}
        </label>
      )}
      
      {/* üéØ UNA SOLA INSTANCIA DEL WIDGET */}
      <CldUploadWidget
        uploadPreset="cinenacional-unsigned"
        options={{
          ...getUploadPreset(),
          sources: ['local', 'url', 'google_drive', 'dropbox'],
          multiple: false,
          maxFiles: 1,
          clientAllowedFormats: ['jpg', 'jpeg', 'png', 'webp'],
          maxFileSize: 10000000, // 10MB
          showCompletedButton: true,  
          showUploadMoreButton: false, 
          singleUploadAutoClose: false,
          showSkipCropButton: false,
          showPoweredBy: false,
          autoMinimize: false,
          language: 'es',
          text: {
            es: {
              or: 'O',
              menu: {
                files: 'Mis archivos',
                web: 'Direcci√≥n web',
              },
              selection_counter: {
                selected: 'Seleccionado'
              },
              actions: {
                upload: 'Subir',
                clear_all: 'Limpiar todo',
                log_out: 'Cerrar sesi√≥n',
                done: 'Listo'
              },
              messages: {
                max_files_limit: 'Solo puedes subir 1 archivo',
                min_files_limit: 'Debes subir al menos 1 archivo',
                max_file_size: 'El archivo es demasiado grande (m√°x. 10MB)',
                allowed_formats: 'Formato no permitido. Usa: JPG, PNG, WEBP',
                upload_successful: 'Subida exitosa',
                upload_failed: 'Error al subir'
              },
              local: {
                browse: 'Buscar',
                dd_title_single: 'Arrastra y suelta tu imagen aqu√≠',
                drop_title_single: 'Suelta el archivo para subirlo',
              }
            }
          }
        }}
        onSuccess={handleUploadSuccess}
        onClose={handleClose}
        onError={handleError}
      >
        {({ open }) => {
          // Guardar la funci√≥n open en el ref
          widgetOpenRef.current = open

          return (
            <>
              {!imageUrl ? (
                // Vista sin imagen
                <button
                  type="button"
                  onClick={openWidget}
                  disabled={disabled || isUploading}
                  className="relative block w-full border-2 border-dashed border-gray-300 rounded-lg p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Upload className="mx-auto h-12 w-12 text-gray-400" />
                  <p className="mt-2 text-sm font-medium text-gray-900">
                    {isUploading ? 'Subiendo imagen...' : 'Click para subir o arrastra una imagen aqu√≠'}
                  </p>
                  <p className="mt-1 text-xs text-gray-500">
                    JPG, PNG o WEBP hasta 10MB
                  </p>
                  <p className="mt-1 text-xs text-gray-400">
                    Tama√±o recomendado: {dimensions}
                  </p>
                </button>
              ) : (
                // Vista con imagen
                <div className="space-y-2">
                  {/* Preview de la imagen */}
                  <div className="flex justify-center">
                    <div 
                      onClick={openWidget}
                      className="relative rounded-lg overflow-hidden bg-gray-100 shadow-lg cursor-pointer border-2 border-transparent hover:border-blue-500 transition-all group"
                      style={{ 
                        width: displayWidth,
                        height: displayHeight,
                        maxWidth: '100%'
                      }}
                    >
                      <img
                        src={imageUrl}
                        alt={label || 'Imagen'}
                        className="w-full h-full object-cover"
                        style={{
                          display: 'block',
                          width: '100%',
                          height: '100%',
                          objectFit: maxDisplayHeight ? 'contain' : 'cover'
                        }}
                      />
                      
                      {/* Overlay al hacer hover */}
                      <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-40 transition-all flex items-center justify-center opacity-0 group-hover:opacity-100 pointer-events-none">
                        <p className="text-white font-medium text-lg drop-shadow-lg">
                          {isUploading ? 'Subiendo...' : 'Click para cambiar'}
                        </p>
                      </div>
                    </div>
                  </div>
                  
                  {/* Botones de acci√≥n */}
                  <div className="flex gap-2">
                    <button
                      type="button"
                      onClick={openWidget}
                      disabled={isUploading || disabled}
                      className="flex-1 bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <ImageIcon className="w-4 h-4" />
                      <span>{isUploading ? 'Subiendo...' : 'Cambiar imagen'}</span>
                    </button>
                    
                    <button
                      type="button"
                      onClick={handleRemove}
                      disabled={isUploading || disabled}
                      className="bg-red-100 text-red-700 px-4 py-2 rounded-lg hover:bg-red-200 transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <X className="w-4 h-4" />
                      <span>Eliminar</span>
                    </button>
                  </div>
                  
                  {/* Info de la imagen */}
                  <div className="text-xs text-gray-500 text-center">
                    Imagen subida correctamente ‚Ä¢ {dimensions}
                  </div>
                  <div className="text-xs text-gray-400 text-center">
                    Puedes hacer click en la imagen o usar los botones para cambiarla
                  </div>
                </div>
              )}
            </>
          )
        }}
      </CldUploadWidget>
    </div>
  )
}

// ==================================================
// src/components/admin/CountrySelector.tsx
// ==================================================
// src/components/admin/CountrySelector.tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import { X, Globe, Search } from 'lucide-react'

interface Country {
  id: number
  name: string
  code?: string
}

interface CountrySelectorProps {
  availableCountries: Country[]
  selectedCountries: number[]
  onChange: (countries: number[]) => void
  placeholder?: string
}

export function CountrySelector({
  availableCountries,
  selectedCountries,
  onChange,
  placeholder = "Buscar pa√≠s..."
}: CountrySelectorProps) {
  const [searchTerm, setSearchTerm] = useState('')
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [highlightedIndex, setHighlightedIndex] = useState(-1)
  const inputRef = useRef<HTMLInputElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  // Pa√≠ses frecuentes para mostrar primero
  const frequentCountries = ['Argentina', 'Espa√±a', 'Francia', 'Brasil', 'M√©xico', 'Chile', 'Uruguay', 'Estados Unidos', 'Italia', 'Alemania']

  // Obtener los objetos de pa√≠ses seleccionados
  const selectedCountryObjects = selectedCountries
    .map(id => availableCountries.find(c => c.id === id))
    .filter(Boolean) as Country[]

  // Filtrar pa√≠ses disponibles (excluyendo los ya seleccionados)
  const filteredCountries = availableCountries
    .filter(country => !selectedCountries.includes(country.id))
    .filter(country => 
      searchTerm === '' || 
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
    )
    .sort((a, b) => {
      // Priorizar pa√≠ses frecuentes
      const aIsFrequent = frequentCountries.includes(a.name)
      const bIsFrequent = frequentCountries.includes(b.name)
      
      if (aIsFrequent && !bIsFrequent) return -1
      if (!aIsFrequent && bIsFrequent) return 1
      
      // Luego ordenar alfab√©ticamente
      return a.name.localeCompare(b.name)
    })

  // Manejar click fuera del componente
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setShowSuggestions(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Manejar navegaci√≥n con teclado
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault()
      setHighlightedIndex(prev => 
        prev < filteredCountries.length - 1 ? prev + 1 : prev
      )
    } else if (e.key === 'ArrowUp') {
      e.preventDefault()
      setHighlightedIndex(prev => prev > 0 ? prev - 1 : -1)
    } else if (e.key === 'Enter') {
      e.preventDefault()
      if (highlightedIndex >= 0 && highlightedIndex < filteredCountries.length) {
        handleSelectCountry(filteredCountries[highlightedIndex])
      }
    } else if (e.key === 'Escape') {
      setShowSuggestions(false)
      setHighlightedIndex(-1)
    }
  }

  const handleSelectCountry = (country: Country) => {
    onChange([...selectedCountries, country.id])
    setSearchTerm('')
    setShowSuggestions(false)
    setHighlightedIndex(-1)
    inputRef.current?.focus()
  }

  const handleRemoveCountry = (countryId: number) => {
    onChange(selectedCountries.filter(id => id !== countryId))
  }

  return (
    <div ref={containerRef} className="space-y-3">
      {/* Campo de b√∫squeda */}
      <div className="relative">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
          <input
            ref={inputRef}
            type="text"
            value={searchTerm}
            onChange={(e) => {
              setSearchTerm(e.target.value)
              setShowSuggestions(true)
              setHighlightedIndex(-1)
            }}
            onFocus={() => setShowSuggestions(true)}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
          />
        </div>

        {/* Lista de sugerencias */}
        {showSuggestions && (searchTerm || filteredCountries.length > 0) && (
          <div className="absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg max-h-60 overflow-auto">
            {filteredCountries.length === 0 ? (
              <div className="px-4 py-3 text-sm text-gray-500">
                No se encontraron pa√≠ses
              </div>
            ) : (
              <>
                {searchTerm === '' && (
                  <div className="px-4 py-2 text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-100">
                    Pa√≠ses frecuentes
                  </div>
                )}
                {filteredCountries.map((country, index) => {
                  const isFrequent = searchTerm === '' && frequentCountries.includes(country.name)
                  const isHighlighted = index === highlightedIndex
                  
                  return (
                    <div
                      key={country.id}
                      onClick={() => handleSelectCountry(country)}
                      className={`px-4 py-2 cursor-pointer transition-colors ${
                        isHighlighted 
                          ? 'bg-blue-50 text-blue-700' 
                          : 'hover:bg-gray-50 text-gray-900'
                      } ${!isFrequent && searchTerm === '' && index === frequentCountries.filter(fc => 
                        availableCountries.some(ac => ac.name === fc && !selectedCountries.includes(ac.id))
                      ).length ? 'border-t border-gray-100' : ''}`}
                    >
                      <div className="flex items-center justify-between">
                        <span className="text-sm">{country.name}</span>
                        {isFrequent && searchTerm === '' && (
                          <span className="text-xs text-gray-400">Frecuente</span>
                        )}
                      </div>
                    </div>
                  )
                })}
              </>
            )}
          </div>
        )}
      </div>

      {/* Pa√≠ses seleccionados como chips */}
      {selectedCountryObjects.length > 0 && (
        <div className="flex flex-wrap gap-2">
          {selectedCountryObjects.map((country) => (
            <div
              key={country.id}
              className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm"
            >
              <Globe className="w-3 h-3" />
              <span>{country.name}</span>
              <button
                type="button"
                onClick={() => handleRemoveCountry(country.id)}
                className="ml-1 hover:text-blue-900 transition-colors"
              >
                <X className="w-3 h-3" />
              </button>
            </div>
          ))}
        </div>
      )}

      {/* Texto de ayuda */}
      <p className="text-xs text-gray-500">
        {selectedCountryObjects.length === 0 
          ? "Comienza a escribir para buscar pa√≠ses coproductores" 
          : `${selectedCountryObjects.length} ${selectedCountryObjects.length === 1 ? 'pa√≠s seleccionado' : 'pa√≠ses seleccionados'}`
        }
      </p>
    </div>
  )
}

// ==================================================
// src/components/admin/locations/LocationForm.tsx
// ==================================================
// src/components/admin/locations/LocationForm.tsx

'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import Link from 'next/link'
import { X } from 'lucide-react'
import { useDebounce } from '@/hooks/useDebounce'

interface Location {
  id: number
  name: string
  slug: string
  parentId: number | null
  parent?: {
    id: number
    name: string
  }
  latitude?: string | null
  longitude?: string | null
  path?: string
}

interface LocationFormProps {
  location?: Location
}

export default function LocationForm({ location }: LocationFormProps) {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const [slug, setSlug] = useState(location?.slug || '')
  const [isCheckingSlug, setIsCheckingSlug] = useState(false)
  
  // Estados para el autocomplete
  const [parentSearch, setParentSearch] = useState('')
  const [selectedParent, setSelectedParent] = useState<Location | null>(null)
  const [suggestions, setSuggestions] = useState<Location[]>([])
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [isSearching, setIsSearching] = useState(false)
  const autocompleteRef = useRef<HTMLDivElement>(null)
  
  // Usar el hook useDebounce para el t√©rmino de b√∫squeda
  const debouncedSearchTerm = useDebounce(parentSearch, 300)
  
  // Obtener parentId de la URL si existe
  const urlParentId = searchParams.get('parentId')
  
  const [formData, setFormData] = useState({
    name: location?.name || '',
    parentId: location?.parentId || urlParentId || '',
    latitude: location?.latitude || '',
    longitude: location?.longitude || ''
  })

  // Cargar el lugar padre si existe
  useEffect(() => {
    if (location?.parent || urlParentId) {
      loadInitialParent()
    }
  }, [])

  // Efecto para buscar cuando cambia el t√©rmino debounced
  useEffect(() => {
    if (debouncedSearchTerm.length >= 2) {
      searchLocations(debouncedSearchTerm)
    } else if (debouncedSearchTerm.length === 0) {
      setSuggestions([])
      setShowSuggestions(false)
    }
  }, [debouncedSearchTerm])

  // Manejar clics fuera del autocomplete
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (autocompleteRef.current && !autocompleteRef.current.contains(event.target as Node)) {
        setShowSuggestions(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Verificar slug cuando cambia el nombre
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (formData.name && formData.name !== location?.name) {
        checkSlugAvailability()
      }
    }, 500)

    return () => clearTimeout(timeoutId)
  }, [formData.name])

  const loadInitialParent = async () => {
    try {
      let parentId = location?.parentId || urlParentId
      if (!parentId) return

      const response = await fetch(`/api/locations/${parentId}`)
      if (response.ok) {
        const parentData = await response.json()
        setSelectedParent(parentData)
        setParentSearch(parentData.name)
      }
    } catch (error) {
      console.error('Error loading parent location:', error)
    }
  }

  const checkSlugAvailability = async () => {
    setIsCheckingSlug(true)
    try {
      const response = await fetch('/api/locations/check-slug', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: formData.name,
          excludeId: location?.id
        })
      })
      
      if (response.ok) {
        const data = await response.json()
        setSlug(data.slug)
      }
    } catch (error) {
      console.error('Error checking slug:', error)
    } finally {
      setIsCheckingSlug(false)
    }
  }

  // Funci√≥n de b√∫squeda
  const searchLocations = async (searchTerm: string) => {
    setIsSearching(true)
    try {
      const params = new URLSearchParams({
        q: searchTerm,
        limit: '10'
      })
      
      if (location?.id) {
        params.append('excludeId', location.id.toString())
      }

      const response = await fetch(`/api/locations/search?${params}`)
      if (response.ok) {
        const data = await response.json()
        setSuggestions(data)
        setShowSuggestions(true)
      }
    } catch (error) {
      console.error('Error searching locations:', error)
    } finally {
      setIsSearching(false)
    }
  }

  const handleParentSearchChange = (value: string) => {
    setParentSearch(value)
    setSelectedParent(null)
    setFormData(prev => ({ ...prev, parentId: '' }))
    
    if (!value.trim()) {
      setSuggestions([])
      setShowSuggestions(false)
    }
  }

  const handleSelectParent = (parent: Location) => {
    setSelectedParent(parent)
    setParentSearch(parent.name)
    setFormData(prev => ({ ...prev, parentId: parent.id.toString() }))
    setShowSuggestions(false)
    setSuggestions([])
  }

  const handleClearParent = () => {
    setSelectedParent(null)
    setParentSearch('')
    setFormData(prev => ({ ...prev, parentId: '' }))
    setSuggestions([])
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setIsLoading(true)

    try {
      const url = location 
        ? `/api/locations/${location.id}`
        : '/api/locations'
      
      const method = location ? 'PUT' : 'POST'
      
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...formData,
          parentId: formData.parentId || null
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Error al guardar el lugar')
      }

      router.push(`/admin/locations?refresh=${Date.now()}`)
      router.refresh()
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Error al guardar el lugar')
    } finally {
      setIsLoading(false)
    }
  }

  const handleChange = (field: keyof typeof formData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }))
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded">
          {error}
        </div>
      )}

      <div>
        <label htmlFor="name" className="block text-sm font-medium text-gray-700">
          Nombre *
        </label>
        <input
          type="text"
          id="name"
          value={formData.name}
          onChange={(e) => handleChange('name', e.target.value)}
          required
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
        />
        {slug && (
          <p className="mt-1 text-sm text-gray-500">
            Slug: {slug} {isCheckingSlug && '(verificando...)'}
          </p>
        )}
      </div>

      <div ref={autocompleteRef}>
        <label htmlFor="parentSearch" className="block text-sm font-medium text-gray-700">
          Lugar padre (opcional)
        </label>
        <div className="relative mt-1">
          <div className="relative">
            <input
              type="text"
              id="parentSearch"
              value={parentSearch}
              onChange={(e) => handleParentSearchChange(e.target.value)}
              placeholder="Buscar lugar padre..."
              className="block w-full px-3 py-2 pr-10 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
            />
            {(parentSearch || selectedParent) && (
              <button
                type="button"
                onClick={handleClearParent}
                className="absolute inset-y-0 right-0 flex items-center pr-3"
              >
                <X className="h-4 w-4 text-gray-400 hover:text-gray-600" />
              </button>
            )}
          </div>
          
          {selectedParent && selectedParent.path && (
            <p className="mt-1 text-sm text-gray-500">
              Ubicaci√≥n: {selectedParent.path}
            </p>
          )}

          {/* Dropdown de sugerencias */}
          {showSuggestions && (
            <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
              {isSearching ? (
                <div className="px-3 py-2 text-sm text-gray-500">Buscando...</div>
              ) : suggestions.length > 0 ? (
                <ul className="py-1">
                  {suggestions.map((suggestion) => (
                    <li
                      key={suggestion.id}
                      onClick={() => handleSelectParent(suggestion)}
                      className="px-3 py-2 hover:bg-gray-100 cursor-pointer"
                    >
                      <div className="text-sm font-medium text-gray-900">
                        {suggestion.name}
                      </div>
                      {suggestion.path && suggestion.path !== suggestion.name && (
                        <div className="text-xs text-gray-500">
                          {suggestion.path}
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <div className="px-3 py-2 text-sm text-gray-500">
                  No se encontraron lugares
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label htmlFor="latitude" className="block text-sm font-medium text-gray-700">
            Latitud (opcional)
          </label>
          <input
            type="number"
            id="latitude"
            value={formData.latitude}
            onChange={(e) => handleChange('latitude', e.target.value)}
            step="0.00000001"
            min="-90"
            max="90"
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        <div>
          <label htmlFor="longitude" className="block text-sm font-medium text-gray-700">
            Longitud (opcional)
          </label>
          <input
            type="number"
            id="longitude"
            value={formData.longitude}
            onChange={(e) => handleChange('longitude', e.target.value)}
            step="0.00000001"
            min="-180"
            max="180"
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>
      </div>

      <div className="flex justify-end gap-4">
        <Link
          href="/admin/locations"
          className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
        >
          Cancelar
        </Link>
        <button
          type="submit"
          disabled={isLoading || !formData.name}
          className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? 'Guardando...' : (location ? 'Actualizar' : 'Crear')}
        </button>
      </div>
    </form>
  )
}

// ==================================================
// src/components/admin/locations/LocationTree.tsx
// ==================================================
// src/components/admin/locations/LocationTree.tsx

'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import LocationTreeNode from './LocationTreeNode'
import { Search, Loader2, RefreshCw } from 'lucide-react'

interface LocationNode {
  id: number
  name: string
  slug: string
  children: LocationNode[]
  _count: {
    children: number
    peopleBornHere: number
    peopleDiedHere: number
  }
}

export default function LocationTree() {
  const router = useRouter()
  const [locations, setLocations] = useState<LocationNode[]>([])
  const [filteredLocations, setFilteredLocations] = useState<LocationNode[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [deleteModal, setDeleteModal] = useState<{ id: number; name: string } | null>(null)

  useEffect(() => {
    loadLocationTree()
  }, [])

  useEffect(() => {
    filterLocations()
  }, [searchTerm, locations])

  const loadLocationTree = async () => {
    setIsLoading(true)
    try {
      // Agregar timestamp para evitar cach√©
      const response = await fetch(`/api/locations/tree?t=${Date.now()}`, {
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
        },
      })
      if (response.ok) {
        const data = await response.json()
        setLocations(data)
      }
    } catch (error) {
      console.error('Error loading location tree:', error)
    } finally {
      setIsLoading(false)
    }
  }

  const filterLocations = () => {
    if (!searchTerm.trim()) {
      setFilteredLocations(locations)
      return
    }

    const term = searchTerm.toLowerCase()
    
    const filterNode = (node: LocationNode): LocationNode | null => {
      // Verificar si el nodo actual coincide
      const nodeMatches = node.name.toLowerCase().includes(term)
      
      // Filtrar recursivamente los hijos
      const filteredChildren = node.children
        .map(child => filterNode(child))
        .filter((child): child is LocationNode => child !== null)
      
      // Incluir el nodo si coincide o si tiene hijos que coinciden
      if (nodeMatches || filteredChildren.length > 0) {
        return {
          ...node,
          children: filteredChildren
        }
      }
      
      return null
    }
    
    const filtered = locations
      .map(node => filterNode(node))
      .filter((node): node is LocationNode => node !== null)
    
    setFilteredLocations(filtered)
  }

  const handleDelete = async (id: number, name: string) => {
    setDeleteModal({ id, name })
  }

  const confirmDelete = async () => {
    if (!deleteModal) return

    try {
      const response = await fetch(`/api/locations/${deleteModal.id}`, {
        method: 'DELETE'
      })

      const data = await response.json()

      if (!response.ok) {
        alert(data.error || 'Error al eliminar el lugar')
        return
      }

      // Recargar el √°rbol
      await loadLocationTree()
      router.refresh()
    } catch (error) {
      console.error('Error deleting location:', error)
      alert('Error al eliminar el lugar')
    } finally {
      setDeleteModal(null)
    }
  }

  return (
    <div className="space-y-4">
      {/* Barra de b√∫squeda y bot√≥n refrescar */}
      <div className="flex gap-2">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
          <input
            type="text"
            placeholder="Buscar lugares..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
          />
        </div>
        <button
          onClick={loadLocationTree}
          disabled={isLoading}
          className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors flex items-center gap-2 disabled:opacity-50"
          title="Refrescar lista"
        >
          <RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} />
          Refrescar
        </button>
      </div>

      {/* √Årbol de lugares */}
      {isLoading ? (
        <div className="flex justify-center items-center py-12">
          <Loader2 className="w-8 h-8 animate-spin text-gray-500" />
        </div>
      ) : filteredLocations.length === 0 ? (
        <div className="text-center py-12 text-gray-500">
          {searchTerm ? 'No se encontraron lugares que coincidan con la b√∫squeda' : 'No hay lugares cargados'}
        </div>
      ) : (
        <div className="bg-white rounded-lg shadow-sm border border-gray-200">
          {filteredLocations.map((location) => (
            <LocationTreeNode
              key={location.id}
              node={location}
              level={0}
              onDelete={handleDelete}
            />
          ))}
        </div>
      )}

      {/* Modal de confirmaci√≥n de eliminaci√≥n */}
      {deleteModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <h3 className="text-lg font-semibold mb-4">Confirmar eliminaci√≥n</h3>
            <p className="text-gray-600 mb-6">
              ¬øEst√°s seguro de que quieres eliminar "{deleteModal.name}"?
            </p>
            <div className="flex justify-end gap-3">
              <button
                onClick={() => setDeleteModal(null)}
                className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
              >
                Cancelar
              </button>
              <button
                onClick={confirmDelete}
                className="px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700 transition-colors"
              >
                Eliminar
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/locations/LocationTreeNode.tsx
// ==================================================
// src/components/admin/locations/LocationTreeNode.tsx

'use client'

import { useState } from 'react'
import Link from 'next/link'
import { ChevronRight, ChevronDown, MapPin, Edit, Trash2, Plus, Users } from 'lucide-react'

interface LocationNode {
  id: number
  name: string
  slug: string
  children: LocationNode[]
  _count: {
    children: number
    peopleBornHere: number
    peopleDiedHere: number
  }
}

interface LocationTreeNodeProps {
  node: LocationNode
  level: number
  onDelete: (id: number, name: string) => void
}

export default function LocationTreeNode({ node, level, onDelete }: LocationTreeNodeProps) {
  const [isExpanded, setIsExpanded] = useState(level < 1) // Expandir solo el primer nivel por defecto
  const hasChildren = node.children.length > 0

  const handleToggle = () => {
    if (hasChildren) {
      setIsExpanded(!isExpanded)
    }
  }

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    onDelete(node.id, node.name)
  }

  // Determinar si tiene relaciones que impiden su eliminaci√≥n
  const hasRelations = 
    node._count.children > 0 ||
    node._count.peopleBornHere > 0 ||
    node._count.peopleDiedHere > 0

  // Construir tooltip con informaci√≥n de relaciones
  const getRelationsTooltip = () => {
    const relations = []
    if (node._count.children > 0) relations.push(`${node._count.children} lugares`)
    if (node._count.peopleBornHere > 0) relations.push(`${node._count.peopleBornHere} nacimientos`)
    if (node._count.peopleDiedHere > 0) relations.push(`${node._count.peopleDiedHere} fallecimientos`)
    return relations.join(', ')
  }

  return (
    <div className="select-none">
      <div
        className={`flex items-center gap-2 py-2 px-3 hover:bg-gray-50 rounded-lg cursor-pointer group`}
        style={{ paddingLeft: `${level * 1.5 + 0.75}rem` }}
      >
        {/* Chevron para expandir/colapsar */}
        <button
          onClick={handleToggle}
          className={`p-0.5 ${!hasChildren ? 'invisible' : ''}`}
        >
          {isExpanded ? (
            <ChevronDown className="w-4 h-4 text-gray-500" />
          ) : (
            <ChevronRight className="w-4 h-4 text-gray-500" />
          )}
        </button>

        {/* Icono de lugar */}
        <MapPin className="w-4 h-4 text-gray-400" />

        {/* Nombre del lugar */}
        <span className="flex-1 text-sm font-medium text-gray-900">
          {node.name}
        </span>

        {/* Badges de contadores */}
        <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          {node._count.peopleBornHere + node._count.peopleDiedHere > 0 && (
            <span className="flex items-center gap-1 text-xs text-gray-500" title="Personas relacionadas">
              <Users className="w-3 h-3" />
              {node._count.peopleBornHere + node._count.peopleDiedHere}
            </span>
          )}
        </div>

        {/* Acciones */}
        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
          <Link
            href={`/admin/locations/new?parentId=${node.id}`}
            className="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded"
            title="Agregar lugar hijo"
            onClick={(e) => e.stopPropagation()}
          >
            <Plus className="w-4 h-4" />
          </Link>
          
          <Link
            href={`/admin/locations/${node.id}/edit`}
            className="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded"
            title="Editar"
            onClick={(e) => e.stopPropagation()}
          >
            <Edit className="w-4 h-4" />
          </Link>
          
          <button
            onClick={handleDelete}
            disabled={hasRelations}
            className={`p-1.5 rounded ${
              hasRelations
                ? 'text-gray-300 cursor-not-allowed'
                : 'text-gray-400 hover:text-red-600 hover:bg-red-50'
            }`}
            title={hasRelations ? `No se puede eliminar: ${getRelationsTooltip()}` : 'Eliminar'}
          >
            <Trash2 className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* Hijos */}
      {isExpanded && hasChildren && (
        <div>
          {node.children.map((child) => (
            <LocationTreeNode
              key={child.id}
              node={child}
              level={level + 1}
              onDelete={onDelete}
            />
          ))}
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/MovieFormEnhanced.tsx
// ==================================================
// src/components/admin/MovieFormEnhanced.tsx
'use client'

import { useState, useEffect } from 'react'
import {
  Plus,
  X,
  Search,
  UserPlus,
  Building,
  Globe,
  Hash,
  Trash2,
  Tag
} from 'lucide-react'
import ScreeningVenueSelector from './ScreeningVenueSelector'
import CastList from './movies/CastList'


interface MovieFormEnhancedProps {
  onGenresChange: (genres: number[]) => void
  onCastChange: (cast: any[]) => void
  onCrewChange: (crew: any[]) => void
  onCountriesChange: (countries: number[]) => void
  onProductionCompaniesChange: (companies: number[]) => void
  onDistributionCompaniesChange: (companies: number[]) => void
  onScreeningVenuesChange: (venues: any[]) => void
  onThemesChange?: (themes: number[]) => void
  initialData?: {
    genres?: any[]
    cast?: any[]
    crew?: any[]
    countries?: any[]
    productionCompanies?: any[]
    distributionCompanies?: any[]
    themes?: any[]
    screeningVenues?: any[]
  }
  showOnlyBasicInfo?: boolean
  showOnlyCast?: boolean
  showOnlyCrew?: boolean
  showOnlyCompanies?: boolean
}

export default function MovieFormEnhanced({
  onGenresChange,
  onCastChange,
  onCrewChange,
  onCountriesChange,
  onProductionCompaniesChange,
  onDistributionCompaniesChange,
  onScreeningVenuesChange,
  onThemesChange = () => { },
  initialData,
  showOnlyBasicInfo = false,
  showOnlyCast = false,
  showOnlyCrew = false,
  showOnlyCompanies = false
}: MovieFormEnhancedProps) {
  // Estados para las listas disponibles
  const [availableGenres, setAvailableGenres] = useState<any[]>([])
  const [availablePeople, setAvailablePeople] = useState<any[]>([])
  const [availableCountries, setAvailableCountries] = useState<any[]>([])
  const [availableProductionCompanies, setAvailableProductionCompanies] = useState<any[]>([])
  const [availableDistributionCompanies, setAvailableDistributionCompanies] = useState<any[]>([])
  const [availableThemes, setAvailableThemes] = useState<any[]>([])

  // Estados para las selecciones
  const [selectedGenres, setSelectedGenres] = useState<number[]>([])
  const [cast, setCast] = useState<any[]>([])
  const [crew, setCrew] = useState<any[]>([])
  const [selectedCountries, setSelectedCountries] = useState<number[]>([])
  const [selectedProductionCompanies, setSelectedProductionCompanies] = useState<number[]>([])
  const [selectedDistributionCompanies, setSelectedDistributionCompanies] = useState<number[]>([])
  const [selectedThemes, setSelectedThemes] = useState<number[]>([])
  const [screeningVenues, setScreeningVenues] = useState<any[]>([])

  // Estados para b√∫squeda
  const [personSearch, setPersonSearch] = useState('')
  const [themeSearch, setThemeSearch] = useState('')
  const [countrySearch, setCountrySearch] = useState('')
  const [showPersonSearch, setShowPersonSearch] = useState(false)
  const [addingType, setAddingType] = useState<'cast' | 'crew' | null>(null)

  const [availableRoles, setAvailableRoles] = useState<any[]>([])

  const [dataReady, setDataReady] = useState(false)

  // Estado para nuevo actor/crew
  const [newPerson, setNewPerson] = useState({
    personId: 0,
    characterName: '',
    roleId: 0,
    billingOrder: 0
  })

  const [isInitialized, setIsInitialized] = useState(false)

  // Cargar datos iniciales
  useEffect(() => {
    fetchInitialData()
  }, [])

  useEffect(() => {
    setIsInitialized(false)  // Resetear cuando cambia initialData
  }, [initialData])

  // Inicializar con datos existentes - CORREGIDO
  useEffect(() => {
    if (initialData && !isInitialized) {
      console.log('üé¨ MovieFormEnhanced - initialData completo:', initialData)
      console.log('üé≠ MovieFormEnhanced - initialData.genres:', initialData.genres)
      if (initialData.genres) {
        console.log('üé≠ Primer g√©nero:', initialData.genres[0])
        const genreIds = initialData.genres.map(g => {
          console.log('üé≠ Procesando g√©nero:', g)
          return g.genre?.id || g.genreId || g.id
        })
        console.log('üé≠ IDs extra√≠dos:', genreIds)

        setSelectedGenres(genreIds)
      }

      if (initialData.cast) {
        // ‚úÖ SOLUCI√ìN: normalizar antes de guardar
        const normalizedCast = initialData.cast.map((member: any) => ({
          personId: member.personId || member.person?.id,
          person: member.person,
          characterName: member.characterName,
          billingOrder: member.billingOrder,
          isPrincipal: member.isPrincipal,
          notes: member.notes
        }))

        setCast(normalizedCast)
      }

      if (initialData.crew) {
        console.log('üé¨ Crew data received:', initialData.crew)
        setCrew(initialData.crew)
      }

      if (initialData.screeningVenues) {
        setScreeningVenues(initialData.screeningVenues)
      }

      // CORRECCI√ìN IMPORTANTE: Manejar correctamente los pa√≠ses
      if (initialData.countries) {
        const countryIds = initialData.countries.map(c => {
          // Manejar diferentes estructuras posibles
          if (typeof c === 'number') return c
          if (c.countryId) return c.countryId  // Si viene de movieCountries
          if (c.id) return c.id
          if (c.country && c.country.id) return c.country.id
          return null
        }).filter(id => id !== null)

        setSelectedCountries(countryIds)
      }

      if (initialData.productionCompanies) {
        const companyIds = initialData.productionCompanies.map(c => c.companyId || c.id || c.company?.id)
        setSelectedProductionCompanies(companyIds)
      }

      if (initialData.distributionCompanies) {
        const companyIds = initialData.distributionCompanies.map(c => c.companyId || c.id || c.company?.id)
        setSelectedDistributionCompanies(companyIds)
      }

      if (initialData.themes) {
        const themeIds = initialData.themes.map(t => t.themeId || t.id)
        setSelectedThemes(themeIds)
      }

      setIsInitialized(true)
    }
  }, [initialData, isInitialized])

  // Notificar cambios al componente padre
  useEffect(() => {
    if (isInitialized || !initialData) {
      onGenresChange(selectedGenres)
    }
  }, [selectedGenres, onGenresChange, isInitialized, initialData])

  useEffect(() => {
    if (isInitialized) {
      onScreeningVenuesChange(screeningVenues)
    }
  }, [screeningVenues, onScreeningVenuesChange, isInitialized])

  useEffect(() => {
    if (isInitialized && initialData) {
      onCastChange(cast)
    }
  }, [cast, onCastChange, isInitialized, initialData])

  useEffect(() => {
    if (isInitialized) {
      onCrewChange(crew)
    }
  }, [crew, onCrewChange, isInitialized])

  useEffect(() => {
    if (isInitialized || !initialData) {
      onCountriesChange(selectedCountries)
    }
  }, [selectedCountries, onCountriesChange, isInitialized, initialData])

  useEffect(() => {
    if (isInitialized) {
      onProductionCompaniesChange(selectedProductionCompanies)
    }
  }, [selectedProductionCompanies, onProductionCompaniesChange, isInitialized])

  useEffect(() => {
    if (isInitialized) {
      onDistributionCompaniesChange(selectedDistributionCompanies)
    }
  }, [selectedDistributionCompanies, onDistributionCompaniesChange, isInitialized])

  useEffect(() => {
    if (isInitialized) {
      onThemesChange(selectedThemes)
    }
  }, [selectedThemes, onThemesChange, isInitialized])

  // Cargar datos de la API
  const fetchInitialData = async () => {
    try {
      const [genresRes, countriesRes, prodCompaniesRes, distCompaniesRes, themesRes, rolesRes] = await Promise.all([
        fetch('/api/genres'),
        fetch('/api/locations/countries'),
        fetch('/api/companies/production'),
        fetch('/api/companies/distribution'),
        fetch('/api/themes').catch(() => ({ ok: false, json: () => [] })),
        fetch('/api/roles?limit=100')
      ])

      // Verificar que todas las respuestas sean OK
      if (!genresRes.ok || !countriesRes.ok || !prodCompaniesRes.ok || !distCompaniesRes.ok) {
        throw new Error('Error fetching data')
      }

      const [genres, countries, prodCompanies, distCompanies, themes, roles] = await Promise.all([
        genresRes.json(),
        countriesRes.json(),
        prodCompaniesRes.json(),
        distCompaniesRes.json(),
        themesRes.ok ? themesRes.json() : [],
        rolesRes.ok ? rolesRes.json() : { data: [] }
      ])

      // Asegurar que siempre sean arrays
      setAvailableGenres(Array.isArray(genres) ? genres : [])
      setAvailableCountries(Array.isArray(countries) ? countries : [])
      setAvailableProductionCompanies(Array.isArray(prodCompanies) ? prodCompanies : [])
      setAvailableDistributionCompanies(Array.isArray(distCompanies) ? distCompanies : [])
      setAvailableThemes(Array.isArray(themes) ? themes : [])
      setAvailableRoles(roles.data || [])

    } catch (error) {
      console.error('Error loading initial data:', error)
      // Asegurar que los estados sean arrays vac√≠os en caso de error
      setAvailableGenres([])
      setAvailableCountries([])
      setAvailableProductionCompanies([])
      setAvailableDistributionCompanies([])
      setAvailableThemes([])
      setAvailableRoles([])
    }
  }

  // Buscar personas
  const searchPeople = async (search: string) => {
    if (search.length < 2) return

    try {
      const response = await fetch(`/api/people?search=${encodeURIComponent(search)}&limit=10`)
      const result = await response.json()

      // CAMBIO IMPORTANTE: Manejar tanto array directo como objeto con data
      const peopleData = Array.isArray(result) ? result : (result.data || [])

      // Ya no necesitas formatear el nombre porque ya viene formateado del backend
      setAvailablePeople(peopleData)

    } catch (error) {
      console.error('Error searching people:', error)
      setAvailablePeople([])
    }
  }

  // Agregar persona al cast o crew
  const addPerson = () => {
    console.log('üîµ addPerson - INICIO')
    console.log('üîµ personId:', newPerson.personId)
    console.log('üîµ cast actual:', cast)

    if (!newPerson.personId) return

    const selectedPerson = availablePeople.find((p: any) => p.id === newPerson.personId)
    console.log('üîµ selectedPerson encontrado:', selectedPerson)

    if (!selectedPerson) return

    if (addingType === 'cast') {
      const newMember = {
        personId: newPerson.personId,
        person: selectedPerson,
        characterName: newPerson.characterName,
        billingOrder: cast.length + 1,
        isPrincipal: cast.length < 5
      }
      console.log('üîµ newMember a agregar:', newMember)

      const newCast = [...cast, newMember]
      console.log('üîµ newCast completo:', newCast)

      setCast(newCast)
      console.log('üîµ setCast ejecutado')
    } else if (addingType === 'crew') {
      const selectedRole = availableRoles.find(r => r.id === newPerson.roleId)

      setCrew([...crew, {
        personId: newPerson.personId,
        person: selectedPerson,
        roleId: newPerson.roleId,
        role: selectedRole,
        billingOrder: crew.filter(c => c.roleId === newPerson.roleId).length + 1
      }])
    }

    // Limpiar formulario
    setNewPerson({
      personId: 0,
      characterName: '',
      roleId: 0,
      billingOrder: 0
    })
    setShowPersonSearch(false)
    setAddingType(null)
    setPersonSearch('')
  }

  // Crear nueva persona
  const createNewPerson = async () => {
    if (!personSearch) return

    try {
      const response = await fetch('/api/people', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: personSearch })
      })

      if (response.ok) {
        const newPersonData = await response.json()
        setAvailablePeople([newPersonData])
        setNewPerson({ ...newPerson, personId: newPersonData.id })
      }
    } catch (error) {
      console.error('Error creating person:', error)
    }
  }

  // Renderizar solo las secciones necesarias seg√∫n las props
  if (showOnlyBasicInfo) {
    return (
      <div className="space-y-6">
        {/* G√©neros */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <Hash className="w-5 h-5" />
            G√©neros
          </h3>
          <div className="flex flex-wrap gap-2">
            {availableGenres.map((genre: any) => (
              <label
                key={genre.id}
                className="inline-flex items-center"
              >
                <input
                  type="checkbox"
                  className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  checked={selectedGenres.includes(genre.id)}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setSelectedGenres([...selectedGenres, genre.id])
                    } else {
                      setSelectedGenres(selectedGenres.filter(id => id !== genre.id))
                    }
                  }}
                />
                <span className="ml-2 text-sm text-gray-700">{genre.name}</span>
              </label>
            ))}
          </div>
        </div>

        {/* Pa√≠ses */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <Globe className="w-5 h-5" />
            Pa√≠ses Coproductores
          </h3>

          {/* Tags de pa√≠ses seleccionados */}
          {selectedCountries.length > 0 && (
            <div className="flex flex-wrap gap-2 mb-3">
              {selectedCountries.map(countryId => {
                const country = availableCountries.find(c => c.id === countryId)
                if (!country) return null
                return (
                  <span
                    key={country.id}
                    className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800"
                  >
                    {country.name}
                    <button
                      type="button"
                      onClick={() => setSelectedCountries(selectedCountries.filter(id => id !== country.id))}
                      className="ml-1 hover:text-blue-600"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </span>
                )
              })}
            </div>
          )}

          {/* Buscador de pa√≠ses */}
          <div className="relative">
            <input
              type="text"
              placeholder="Buscar pa√≠ses..."
              value={countrySearch}
              onChange={(e) => setCountrySearch(e.target.value)}
              className="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
          </div>

          {/* Lista filtrada de pa√≠ses */}
          {countrySearch && (
            <div className="mt-2 max-h-48 overflow-y-auto border border-gray-200 rounded-lg">
              {availableCountries
                .filter((country: any) =>
                  country.name.toLowerCase().includes(countrySearch.toLowerCase()) &&
                  !selectedCountries.includes(country.id)
                )
                .map((country: any) => (
                  <button
                    key={country.id}
                    type="button"
                    onClick={() => {
                      setSelectedCountries([...selectedCountries, country.id])
                      setCountrySearch('')
                    }}
                    className="w-full text-left px-3 py-2 hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                  >
                    <span className="text-sm text-gray-700">{country.name}</span>
                  </button>
                ))}
              {availableCountries.filter((country: any) =>
                country.name.toLowerCase().includes(countrySearch.toLowerCase()) &&
                !selectedCountries.includes(country.id)
              ).length === 0 && (
                  <div className="px-3 py-2 text-sm text-gray-500">
                    No se encontraron pa√≠ses
                  </div>
                )}
            </div>
          )}

          <p className="mt-1 text-xs text-gray-500">
            Escribe para buscar y agregar pa√≠ses
          </p>
        </div>
        <div className="col-span-2 mt-4">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Pantallas de Estreno
          </label>
          <ScreeningVenueSelector
            selectedVenueIds={screeningVenues}
            onChange={(venues) => {
              setScreeningVenues(venues)
            }}
          />
          <p className="mt-1 text-sm text-gray-500">
            Selecciona las pantallas donde se estren√≥ o estrenar√° la pel√≠cula
          </p>
        </div>
        {/* Temas */}
        {availableThemes.length > 0 && (
          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
              <Tag className="w-5 h-5" />
              Temas / Palabras Clave
            </h3>

            {/* Tags de temas seleccionados */}
            {selectedThemes.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-3">
                {selectedThemes.map(themeId => {
                  const theme = availableThemes.find(t => t.id === themeId)
                  if (!theme) return null
                  return (
                    <span
                      key={theme.id}
                      className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm bg-purple-100 text-purple-800"
                    >
                      {theme.name}
                      <button
                        type="button"
                        onClick={() => setSelectedThemes(selectedThemes.filter(id => id !== theme.id))}
                        className="ml-1 hover:text-purple-600"
                      >
                        <X className="w-3 h-3" />
                      </button>
                    </span>
                  )
                })}
              </div>
            )}

            {/* Buscador de temas */}
            <div className="relative">
              <input
                type="text"
                placeholder="Buscar temas..."
                value={themeSearch}
                onChange={(e) => setThemeSearch(e.target.value)}
                className="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
              <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
            </div>

            {/* Lista filtrada de temas */}
            {themeSearch && (
              <div className="mt-2 max-h-48 overflow-y-auto border border-gray-200 rounded-lg">
                {availableThemes
                  .filter((theme: any) =>
                    theme.name.toLowerCase().includes(themeSearch.toLowerCase()) &&
                    !selectedThemes.includes(theme.id)
                  )
                  .map((theme: any) => (
                    <button
                      key={theme.id}
                      type="button"
                      onClick={() => {
                        setSelectedThemes([...selectedThemes, theme.id])
                        setThemeSearch('')
                      }}
                      className="w-full text-left px-3 py-2 hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                    >
                      <span className="text-sm text-gray-700">{theme.name}</span>
                    </button>
                  ))}
                {availableThemes.filter((theme: any) =>
                  theme.name.toLowerCase().includes(themeSearch.toLowerCase()) &&
                  !selectedThemes.includes(theme.id)
                ).length === 0 && (
                    <div className="px-3 py-2 text-sm text-gray-500">
                      No se encontraron temas
                    </div>
                  )}
              </div>
            )}

            <p className="mt-1 text-xs text-gray-500">
              Escribe para buscar y agregar temas
            </p>
          </div>
        )}
      </div>
    )
  }

  if (showOnlyCast) {
    return (
      <div className="space-y-6">
        {/* Cast */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <UserPlus className="w-5 h-5" />
            Reparto
          </h3>

          {/* ‚úÖ NUEVO COMPONENTE CON DRAG & DROP */}
          <div className="mb-4">
            <CastList cast={cast} onCastChange={setCast} />
          </div>

          <button
            type="button"
            onClick={() => {
              setAddingType('cast')
              setShowPersonSearch(true)
            }}
            className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
          >
            <Plus className="w-4 h-4" />
            Agregar Actor/Actriz
          </button>
        </div>

        {/* Modal de b√∫squeda de personas - MANTENER IGUAL */}
        {showPersonSearch && (
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
            {/* Modal de b√∫squeda de personas */}
            {showPersonSearch && (
              <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
                <div className="bg-white rounded-lg max-w-md w-full p-6">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    {addingType === 'cast' ? 'Agregar Actor/Actriz' : 'Agregar Miembro del Equipo'}
                  </h3>

                  <div className="space-y-4">
                    {/* B√∫squeda de persona */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Buscar Persona
                      </label>
                      <div className="relative">
                        <input
                          type="text"
                          value={personSearch}
                          onChange={(e) => {
                            setPersonSearch(e.target.value)
                            searchPeople(e.target.value)
                          }}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                          placeholder="Escriba el nombre..."
                        />
                        <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
                      </div>

                      {availablePeople.length > 0 && (
                        <div className="mt-2 border border-gray-200 rounded-lg max-h-40 overflow-y-auto">
                          {availablePeople.map((person: any) => (
                            <button
                              key={person.id}
                              type="button"
                              onClick={() => setNewPerson({ ...newPerson, personId: person.id })}
                              className={`w-full text-left px-3 py-2 hover:bg-gray-50 ${newPerson.personId === person.id ? 'bg-blue-50' : ''
                                }`}
                            >
                              {person.name}
                            </button>
                          ))}
                        </div>
                      )}

                      {personSearch && availablePeople.length === 0 && (
                        <button
                          type="button"
                          onClick={createNewPerson}
                          className="mt-2 text-sm text-blue-600 hover:text-blue-800"
                        >
                          Crear nueva persona: "{personSearch}"
                        </button>
                      )}
                    </div>

                    {/* Campos espec√≠ficos seg√∫n el tipo */}
                    {addingType === 'cast' && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Personaje
                        </label>
                        <input
                          type="text"
                          value={newPerson.characterName}
                          onChange={(e) => setNewPerson({ ...newPerson, characterName: e.target.value })}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                          placeholder="Nombre del personaje"
                        />
                      </div>
                    )}

                    {addingType === 'crew' && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Rol
                        </label>
                        <select
                          value={newPerson.roleId}
                          onChange={(e) => setNewPerson({ ...newPerson, roleId: parseInt(e.target.value) })}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        >
                          <option value="">Seleccionar...</option>
                          {availableRoles
                            .sort((a, b) => a.department.localeCompare(b.department))
                            .map((role: any) => (
                              <option key={role.id} value={role.id}>
                                {role.name} ({role.department})
                              </option>
                            ))}
                        </select>
                      </div>
                    )}
                  </div>

                  {/* Botones de acci√≥n */}
                  <div className="mt-6 flex justify-end gap-3">
                    <button
                      type="button"
                      onClick={() => {
                        setShowPersonSearch(false)
                        setAddingType(null)
                        setPersonSearch('')
                        setNewPerson({
                          personId: 0,
                          characterName: '',
                          roleId: 0,
                          billingOrder: 0
                        })
                      }}
                      className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
                    >
                      Cancelar
                    </button>
                    <button
                      type="button"
                      onClick={addPerson}
                      disabled={!newPerson.personId || (addingType === 'crew' && !newPerson.roleId)}
                      className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Agregar
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    )
  }

  if (showOnlyCrew) {
    return (
      <div className="space-y-6">
        {/* Crew */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <UserPlus className="w-5 h-5" />
            Equipo T√©cnico
          </h3>

          {crew.length > 0 && (
            <div className="mb-4 space-y-2">
              {crew.map((member, index) => {
                console.log('üé≠ Member:', member) // ‚Üê AGREGADO
                console.log('Person:', member.person)  // ‚Üê AGREGAR
                console.log('Role:', member.role)      // ‚Üê AGREGAR
                return (
                  <div key={index} className="flex items-center gap-4 p-3 bg-gray-50 rounded-lg">
                    <div className="flex-1">
                      <span className="font-medium">
                        {member.person ? `${member.person.firstName || ''} ${member.person.lastName || ''}`.trim() : 'Sin nombre'}
                      </span>
                      <span className="text-gray-500"> - {member.role?.name || 'Sin rol'}</span>
                      {member.role?.department && (
                        <span className="text-gray-400"> ({member.role.department})</span>
                      )}
                    </div>
                    <button
                      type="button"
                      onClick={() => setCrew(crew.filter((_, i) => i !== index))}
                      className="text-red-600 hover:text-red-800"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>
                )
              })}
            </div>
          )}

          <button
            type="button"
            onClick={() => {
              setAddingType('crew')
              setShowPersonSearch(true)
            }}
            className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
          >
            <Plus className="w-4 h-4" />
            Agregar Miembro del Equipo
          </button>
        </div>

        {/* Modal de b√∫squeda de personas */}
        {showPersonSearch && (
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg max-w-md w-full p-6">
              <h3 className="text-lg font-medium text-gray-900 mb-4">
                {addingType === 'cast' ? 'Agregar Actor/Actriz' : 'Agregar Miembro del Equipo'}
              </h3>

              <div className="space-y-4">
                {/* B√∫squeda de persona */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Buscar Persona
                  </label>
                  <div className="relative">
                    <input
                      type="text"
                      value={personSearch}
                      onChange={(e) => {
                        setPersonSearch(e.target.value)
                        searchPeople(e.target.value)
                      }}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      placeholder="Escriba el nombre..."
                    />
                    <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
                  </div>

                  {availablePeople.length > 0 && (
                    <div className="mt-2 border border-gray-200 rounded-lg max-h-40 overflow-y-auto">
                      {availablePeople.map((person: any) => (
                        <button
                          key={person.id}
                          type="button"
                          onClick={() => setNewPerson({ ...newPerson, personId: person.id })}
                          className={`w-full text-left px-3 py-2 hover:bg-gray-50 ${newPerson.personId === person.id ? 'bg-blue-50' : ''
                            }`}
                        >
                          {person.name}
                        </button>
                      ))}
                    </div>
                  )}

                  {personSearch && availablePeople.length === 0 && (
                    <button
                      type="button"
                      onClick={createNewPerson}
                      className="mt-2 text-sm text-blue-600 hover:text-blue-800"
                    >
                      Crear nueva persona: "{personSearch}"
                    </button>
                  )}
                </div>

                {/* Campos espec√≠ficos seg√∫n el tipo */}
                {addingType === 'cast' && (
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Personaje
                    </label>
                    <input
                      type="text"
                      value={newPerson.characterName}
                      onChange={(e) => setNewPerson({ ...newPerson, characterName: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      placeholder="Nombre del personaje"
                    />
                  </div>
                )}

                {addingType === 'crew' && (
                  <>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Rol
                      </label>
                      <select
                        value={newPerson.roleId}  // ‚úÖ Cambiar a roleId
                        onChange={(e) => setNewPerson({ ...newPerson, roleId: parseInt(e.target.value) })}  // ‚úÖ Cambiar a roleId
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      >
                        <option value="">Seleccionar...</option>
                        {availableRoles
                          .sort((a, b) => a.department.localeCompare(b.department))
                          .map((role: any) => (
                            <option key={role.id} value={role.id}>
                              {role.name} ({role.department})
                            </option>
                          ))}
                      </select>
                    </div>
                  </>
                )}
              </div>

              {/* Botones de acci√≥n */}
              <div className="mt-6 flex justify-end gap-3">
                <button
                  type="button"
                  onClick={() => {
                    setShowPersonSearch(false)
                    setAddingType(null)
                    setPersonSearch('')
                    setNewPerson({
                      personId: 0,
                      characterName: '',
                      roleId: 0,
                      billingOrder: 0
                    })
                  }}
                  className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
                >
                  Cancelar
                </button>
                <button
                  type="button"
                  onClick={addPerson}
                  disabled={!newPerson.personId || (addingType === 'crew' && !newPerson.roleId)}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Agregar
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    )
  }

  if (showOnlyCompanies) {
    return (
      <div className="space-y-6">
        {/* Productoras */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <Building className="w-5 h-5" />
            Productoras
          </h3>
          <select
            multiple
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            value={selectedProductionCompanies.map(String)}
            onChange={(e) => {
              const selected = Array.from(e.target.selectedOptions, option => parseInt(option.value))
              setSelectedProductionCompanies(selected)
            }}
          >
            {availableProductionCompanies.map((company: any) => (
              <option key={company.id} value={company.id}>
                {company.name}
              </option>
            ))}
          </select>
          <p className="mt-1 text-sm text-gray-500">
            Mant√©n presionado Ctrl/Cmd para seleccionar m√∫ltiples opciones
          </p>
        </div>

        {/* Distribuidoras */}
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <Building className="w-5 h-5" />
            Distribuidoras
          </h3>
          <select
            multiple
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            value={selectedDistributionCompanies.map(String)}
            onChange={(e) => {
              const selected = Array.from(e.target.selectedOptions, option => parseInt(option.value))
              setSelectedDistributionCompanies(selected)
            }}
          >
            {availableDistributionCompanies.map((company: any) => (
              <option key={company.id} value={company.id}>
                {company.name}
              </option>
            ))}
          </select>
          <p className="mt-1 text-sm text-gray-500">
            Mant√©n presionado Ctrl/Cmd para seleccionar m√∫ltiples opciones
          </p>
        </div>
      </div>
    )
  }

  // Renderizar todo por defecto
  return (
    <div className="space-y-6">
      {/* G√©neros */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <Hash className="w-5 h-5" />
          G√©neros
        </h3>
        <div className="flex flex-wrap gap-2">
          {availableGenres.map((genre: any) => (
            <label
              key={genre.id}
              className="inline-flex items-center"
            >
              <input
                type="checkbox"
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                checked={selectedGenres.includes(genre.id)}
                onChange={(e) => {
                  if (e.target.checked) {
                    setSelectedGenres([...selectedGenres, genre.id])
                  } else {
                    setSelectedGenres(selectedGenres.filter(id => id !== genre.id))
                  }
                }}
              />
              <span className="ml-2 text-sm text-gray-700">{genre.name}</span>
            </label>
          ))}
        </div>
      </div>

      {/* Cast */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <UserPlus className="w-5 h-5" />
          Reparto
        </h3>

        {cast.length > 0 && (
          <div className="mb-4 space-y-2">
            {cast.map((member, index) => (
              <div key={index} className="flex items-center gap-4 p-3 bg-gray-50 rounded-lg">
                <div className="flex-1">
                  <span className="font-medium">
                    {member.person ? `${member.person.firstName || ''} ${member.person.lastName || ''}`.trim() : 'Sin nombre'}
                  </span>
                  {member.characterName && (
                    <span className="text-gray-500"> como {member.characterName}</span>
                  )}
                </div>
                <button
                  type="button"
                  onClick={() => setCast(cast.filter((_, i) => i !== index))}
                  className="text-red-600 hover:text-red-800"
                >
                  <Trash2 className="w-4 h-4" />
                </button>
              </div>
            ))}
          </div>
        )}

        <button
          type="button"
          onClick={() => {
            setAddingType('cast')
            setShowPersonSearch(true)
          }}
          className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
        >
          <Plus className="w-4 h-4" />
          Agregar Actor/Actriz
        </button>
      </div>

      {/* Crew */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <UserPlus className="w-5 h-5" />
          Equipo T√©cnico
        </h3>

        {crew.length > 0 && (
          <div className="mb-4 space-y-2">
            {crew.map((member, index) => (
              <div key={index} className="flex items-center gap-4 p-3 bg-gray-50 rounded-lg">
                <div className="flex-1">
                  <span className="font-medium">{member.person?.name || 'Sin nombre'}</span>
                  <span className="text-gray-500"> - {member.role?.name || 'Sin rol'}</span>  // ‚úÖ
                  {member.role?.department && (  // ‚úÖ
                    <span className="text-gray-400"> ({member.role.department})</span>
                  )}
                </div>
                <button
                  type="button"
                  onClick={() => setCrew(crew.filter((_, i) => i !== index))}
                  className="text-red-600 hover:text-red-800"
                >
                  <Trash2 className="w-4 h-4" />
                </button>
              </div>
            ))}
          </div>
        )}

        <button
          type="button"
          onClick={() => {
            setAddingType('crew')
            setShowPersonSearch(true)
          }}
          className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
        >
          <Plus className="w-4 h-4" />
          Agregar Miembro del Equipo
        </button>
      </div>

      {/* Pa√≠ses */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <Globe className="w-5 h-5" />
          Pa√≠ses Coproductores
        </h3>
        <div className="flex flex-wrap gap-2">
          {availableCountries.map((country: any) => (
            <button
              key={country.id}
              type="button"
              onClick={() => {
                if (selectedCountries.includes(country.id)) {
                  setSelectedCountries(selectedCountries.filter(id => id !== country.id))
                } else {
                  setSelectedCountries([...selectedCountries, country.id])
                }
              }}
              className={`px-3 py-1 rounded-full text-sm font-medium transition-colors ${selectedCountries.includes(country.id)
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                }`}
            >
              {country.name}
            </button>
          ))}
        </div>
      </div>

      {/* Temas */}
      {availableThemes.length > 0 && (
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
            <Tag className="w-5 h-5" />
            Temas / Palabras Clave
          </h3>

          {/* Tags de temas seleccionados */}
          {selectedThemes.length > 0 && (
            <div className="flex flex-wrap gap-2 mb-3">
              {selectedThemes.map(themeId => {
                const theme = availableThemes.find(t => t.id === themeId)
                if (!theme) return null
                return (
                  <span
                    key={theme.id}
                    className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm bg-purple-100 text-purple-800"
                  >
                    {theme.name}
                    <button
                      type="button"
                      onClick={() => setSelectedThemes(selectedThemes.filter(id => id !== theme.id))}
                      className="ml-1 hover:text-purple-600"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </span>
                )
              })}
            </div>
          )}

          {/* Buscador de temas */}
          <div className="relative">
            <input
              type="text"
              placeholder="Buscar temas..."
              value={themeSearch}
              onChange={(e) => setThemeSearch(e.target.value)}
              className="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
          </div>

          {/* Lista filtrada de temas */}
          {themeSearch && (
            <div className="mt-2 max-h-48 overflow-y-auto border border-gray-200 rounded-lg">
              {availableThemes
                .filter((theme: any) =>
                  theme.name.toLowerCase().includes(themeSearch.toLowerCase()) &&
                  !selectedThemes.includes(theme.id)
                )
                .map((theme: any) => (
                  <button
                    key={theme.id}
                    type="button"
                    onClick={() => {
                      setSelectedThemes([...selectedThemes, theme.id])
                      setThemeSearch('')
                    }}
                    className="w-full text-left px-3 py-2 hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                  >
                    <span className="text-sm text-gray-700">{theme.name}</span>
                  </button>
                ))}
              {availableThemes.filter((theme: any) =>
                theme.name.toLowerCase().includes(themeSearch.toLowerCase()) &&
                !selectedThemes.includes(theme.id)
              ).length === 0 && (
                  <div className="px-3 py-2 text-sm text-gray-500">
                    No se encontraron temas
                  </div>
                )}
            </div>
          )}

          <p className="mt-1 text-xs text-gray-500">
            Escribe para buscar y agregar temas
          </p>
        </div>
      )}

      {/* Productoras */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <Building className="w-5 h-5" />
          Productoras
        </h3>
        <select
          multiple
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          value={selectedProductionCompanies.map(String)}
          onChange={(e) => {
            const selected = Array.from(e.target.selectedOptions, option => parseInt(option.value))
            setSelectedProductionCompanies(selected)
          }}
        >
          {availableProductionCompanies.map((company: any) => (
            <option key={company.id} value={company.id}>
              {company.name}
            </option>
          ))}
        </select>
        <p className="mt-1 text-sm text-gray-500">
          Mant√©n presionado Ctrl/Cmd para seleccionar m√∫ltiples opciones
        </p>
      </div>

      {/* Distribuidoras */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
          <Building className="w-5 h-5" />
          Distribuidoras
        </h3>
        <select
          multiple
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          value={selectedDistributionCompanies.map(String)}
          onChange={(e) => {
            const selected = Array.from(e.target.selectedOptions, option => parseInt(option.value))
            setSelectedDistributionCompanies(selected)
          }}
        >
          {availableDistributionCompanies.map((company: any) => (
            <option key={company.id} value={company.id}>
              {company.name}
            </option>
          ))}
        </select>
        <p className="mt-1 text-sm text-gray-500">
          Mant√©n presionado Ctrl/Cmd para seleccionar m√∫ltiples opciones
        </p>
      </div>

      {/* Modal de b√∫squeda de personas */}
      {showPersonSearch && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full p-6">
            <h3 className="text-lg font-medium text-gray-900 mb-4">
              {addingType === 'cast' ? 'Agregar Actor/Actriz' : 'Agregar Miembro del Equipo'}
            </h3>

            <div className="space-y-4">
              {/* B√∫squeda de persona */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Buscar Persona
                </label>
                <div className="relative">
                  <input
                    type="text"
                    value={personSearch}
                    onChange={(e) => {
                      setPersonSearch(e.target.value)
                      searchPeople(e.target.value)
                    }}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="Escriba el nombre..."
                  />
                  <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400" />
                </div>

                {availablePeople.length > 0 && (
                  <div className="mt-2 border border-gray-200 rounded-lg max-h-40 overflow-y-auto">
                    {availablePeople.map((person: any) => (
                      <button
                        key={person.id}
                        type="button"
                        onClick={() => setNewPerson({ ...newPerson, personId: person.id })}
                        className={`w-full text-left px-3 py-2 hover:bg-gray-50 ${newPerson.personId === person.id ? 'bg-blue-50' : ''
                          }`}
                      >
                        {person.name}
                      </button>
                    ))}
                  </div>
                )}

                {personSearch && availablePeople.length === 0 && (
                  <button
                    type="button"
                    onClick={createNewPerson}
                    className="mt-2 text-sm text-blue-600 hover:text-blue-800"
                  >
                    Crear nueva persona: "{personSearch}"
                  </button>
                )}
              </div>

              {/* Campos espec√≠ficos seg√∫n el tipo */}
              {addingType === 'cast' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Personaje
                  </label>
                  <input
                    type="text"
                    value={newPerson.characterName}
                    onChange={(e) => setNewPerson({ ...newPerson, characterName: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="Nombre del personaje"
                  />
                </div>
              )}

              {addingType === 'crew' && (
                <>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Rol
                    </label>
                    <select
                      value={newPerson.roleId}
                      onChange={(e) => setNewPerson({ ...newPerson, roleId: parseInt(e.target.value) })}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    >
                      <option value="">Seleccionar...</option>
                      {availableRoles
                        .sort((a, b) => a.department.localeCompare(b.department))
                        .map((role: any) => (
                          <option key={role.id} value={role.id}>
                            {role.name} ({role.department})
                          </option>
                        ))}
                    </select>
                  </div>
                </>
              )}
            </div>

            {/* Botones de acci√≥n */}
            <div className="mt-6 flex justify-end gap-3">
              <button
                type="button"
                onClick={() => {
                  setShowPersonSearch(false)
                  setAddingType(null)
                  setPersonSearch('')
                  setNewPerson({
                    personId: 0,
                    characterName: '',
                    roleId: 0,
                    billingOrder: 0
                  })
                }}
                className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
              >
                Cancelar
              </button>
              <button
                type="button"
                onClick={addPerson}
                disabled={!newPerson.personId || (addingType === 'crew' && !newPerson.roleId)}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Agregar
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/MovieLinksManager.tsx
// ==================================================
import { useState } from 'react';
import { Plus, Trash2, Link, ExternalLink } from 'lucide-react';

interface MovieLink {
  id?: number;
  type: string;
  url: string;
  title?: string;
  isActive?: boolean;
}

interface MovieLinksManagerProps {
  initialLinks?: MovieLink[];
  onLinksChange: (links: MovieLink[]) => void;
}

const LINK_TYPES = [
  { value: 'INSTAGRAM', label: 'Instagram', icon: 'üì∑' },
  { value: 'TWITTER', label: 'X (Twitter)', icon: 'ùïè' },
  { value: 'FACEBOOK', label: 'Facebook', icon: 'üë§' },
  { value: 'TIKTOK', label: 'TikTok', icon: 'üéµ' },
  { value: 'YOUTUBE', label: 'YouTube', icon: '‚ñ∂Ô∏è' },
  { value: 'WEBSITE', label: 'Sitio Web Oficial', icon: 'üåê' }
];

export default function MovieLinksManager({ 
  initialLinks = [], 
  onLinksChange 
}: MovieLinksManagerProps) {
  const [links, setLinks] = useState<MovieLink[]>(initialLinks);
  const [showAddForm, setShowAddForm] = useState(false);
  const [newLink, setNewLink] = useState<MovieLink>({
    type: 'WEBSITE',
    url: '',
    title: ''
  });

  const handleAddLink = () => {
    if (!newLink.url || !newLink.type) return;

    const updatedLinks = [...links, { ...newLink, isActive: true }];
    setLinks(updatedLinks);
    onLinksChange(updatedLinks);

    // Reset form
    setNewLink({ type: 'WEBSITE', url: '', title: '' });
    setShowAddForm(false);
  };

  const handleRemoveLink = (index: number) => {
    const updatedLinks = links.filter((_, i) => i !== index);
    setLinks(updatedLinks);
    onLinksChange(updatedLinks);
  };

  const getLinkTypeInfo = (type: string) => {
    return LINK_TYPES.find(t => t.value === type) || LINK_TYPES[5];
  };

  const getPlaceholderUrl = (type: string) => {
    switch (type) {
      case 'INSTAGRAM':
        return 'https://www.instagram.com/peliculaejemplo';
      case 'TWITTER':
        return 'https://twitter.com/peliculaejemplo';
      case 'FACEBOOK':
        return 'https://www.facebook.com/peliculaejemplo';
      case 'TIKTOK':
        return 'https://www.tiktok.com/@peliculaejemplo';
      case 'YOUTUBE':
        return 'https://www.youtube.com/channel/UCxxxxxx';
      case 'WEBSITE':
      default:
        return 'https://www.peliculaejemplo.com';
    }
  };

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center gap-2">
        <Link className="w-5 h-5" />
        Links Oficiales
      </h3>

      {/* Lista de links existentes */}
      {links.length > 0 && (
        <div className="space-y-2 mb-4">
          {links.map((link, index) => {
            const typeInfo = getLinkTypeInfo(link.type);
            return (
              <div 
                key={index} 
                className="flex items-center gap-4 p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors"
              >
                <span className="text-2xl">{typeInfo.icon}</span>
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <span className="font-medium text-gray-900">{typeInfo.label}</span>
                    {link.title && (
                      <span className="text-sm text-gray-500">- {link.title}</span>
                    )}
                  </div>
                  <a 
                    href={link.url} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1"
                  >
                    {link.url}
                    <ExternalLink className="w-3 h-3" />
                  </a>
                </div>
                <button
                  type="button"
                  onClick={() => handleRemoveLink(index)}
                  className="text-red-600 hover:text-red-800 transition-colors"
                >
                  <Trash2 className="w-4 h-4" />
                </button>
              </div>
            );
          })}
        </div>
      )}

      {/* Formulario para agregar nuevo link */}
      {showAddForm ? (
        <div className="border border-gray-300 rounded-lg p-4 space-y-4 bg-gray-50">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Tipo de Link
              </label>
              <select
                value={newLink.type}
                onChange={(e) => setNewLink({ ...newLink, type: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              >
                {LINK_TYPES.map(type => (
                  <option key={type.value} value={type.value}>
                    {type.icon} {type.label}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                T√≠tulo/Descripci√≥n (opcional)
              </label>
              <input
                type="text"
                value={newLink.title || ''}
                onChange={(e) => setNewLink({ ...newLink, title: e.target.value })}
                placeholder="Ej: Cuenta oficial"
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              URL
            </label>
            <input
              type="url"
              value={newLink.url}
              onChange={(e) => setNewLink({ ...newLink, url: e.target.value })}
              placeholder={getPlaceholderUrl(newLink.type)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              required
            />
          </div>

          <div className="flex justify-end gap-3">
            <button
              type="button"
              onClick={() => {
                setShowAddForm(false);
                setNewLink({ type: 'WEBSITE', url: '', title: '' });
              }}
              className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
            >
              Cancelar
            </button>
            <button
              type="button"
              onClick={handleAddLink}
              disabled={!newLink.url}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              Agregar Link
            </button>
          </div>
        </div>
      ) : (
        <button
          type="button"
          onClick={() => setShowAddForm(true)}
          className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors"
        >
          <Plus className="w-4 h-4" />
          Agregar Link Oficial
        </button>
      )}

      {links.length === 0 && !showAddForm && (
        <p className="text-sm text-gray-500 italic">
          No hay links oficiales agregados para esta pel√≠cula.
        </p>
      )}
    </div>
  );
}

// ==================================================
// src/components/admin/movies/CastList.tsx
// ==================================================
// src/components/admin/movies/CastList.tsx
'use client'

import { useState } from 'react'
import {
    DndContext,
    closestCenter,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
    DragEndEvent,
} from '@dnd-kit/core'
import {
    arrayMove,
    SortableContext,
    sortableKeyboardCoordinates,
    useSortable,
    verticalListSortingStrategy,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { GripVertical, Trash2 } from 'lucide-react'

interface CastMember {
    personId: number
    person: {
        id: number
        firstName?: string
        lastName?: string
        name?: string
    }
    characterName?: string
    billingOrder?: number
    isPrincipal?: boolean
    notes?: string
}

interface CastListProps {
    cast: CastMember[]
    onCastChange: (cast: CastMember[]) => void
}

interface SortableCastItemProps {
    member: CastMember
    index: number
    onRemove: () => void
    onCharacterNameChange: (characterName: string) => void
    onPrincipalChange: (isPrincipal: boolean) => void  // ‚úÖ NUEVO
}

function SortableCastItem({ 
    member, 
    index, 
    onRemove, 
    onCharacterNameChange,
    onPrincipalChange  // ‚úÖ NUEVO
}: SortableCastItemProps) {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging,
    } = useSortable({ id: member.personId.toString() })

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.5 : 1,
    }

    const personName = member.person.name ||
        `${member.person.firstName || ''} ${member.person.lastName || ''}`.trim() ||
        'Sin nombre'

    return (
        <div
            ref={setNodeRef}
            style={style}
            className="flex items-start gap-3 p-3 bg-gray-50 rounded-lg border border-gray-200"
        >
            {/* Drag Handle */}
            <button
                type="button"
                className="mt-2 cursor-grab active:cursor-grabbing text-gray-400 hover:text-gray-600"
                {...attributes}
                {...listeners}
            >
                <GripVertical className="w-5 h-5" />
            </button>

            {/* Content */}
            <div className="flex-1 space-y-2">
                {/* Nombre y personaje */}
                <div className="flex items-center gap-2">
                    <span className="font-medium text-gray-900">{personName}</span>
                    {member.characterName && (
                        <span className="text-gray-500"> como {member.characterName}</span>
                    )}
                    {/* ‚úÖ Badge visual (opcional) */}
                    {member.isPrincipal && (
                        <span className="px-2 py-0.5 text-xs font-medium bg-blue-100 text-blue-800 rounded">
                            Principal
                        </span>
                    )}
                </div>

                {/* Campo de personaje */}
                <div>
                    <label className="block text-xs text-gray-600 mb-1">Personaje:</label>
                    <input
                        type="text"
                        value={member.characterName || ''}
                        onChange={(e) => onCharacterNameChange(e.target.value)}
                        placeholder="Nombre del personaje..."
                        className="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    />
                </div>

                {/* ‚úÖ NUEVO: Checkbox de Actor Principal */}
                <div className="flex items-center gap-2">
                    <input
                        type="checkbox"
                        id={`principal-${member.personId}`}
                        checked={member.isPrincipal || false}
                        onChange={(e) => onPrincipalChange(e.target.checked)}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                    />
                    <label 
                        htmlFor={`principal-${member.personId}`}
                        className="text-sm text-gray-700 cursor-pointer select-none"
                    >
                        Actor/Actriz Principal
                    </label>
                </div>

                {/* Orden */}
                <div className="text-xs text-gray-500">
                    Orden: {index + 1}
                </div>
            </div>

            {/* Delete button */}
            <button
                type="button"
                onClick={onRemove}
                className="mt-2 text-red-600 hover:text-red-800"
            >
                <Trash2 className="w-4 h-4" />
            </button>
        </div>
    )
}

export default function CastList({ cast, onCastChange }: CastListProps) {
    console.log('üé¨ CastList RENDER - cast recibido:', cast)
    console.log('üé¨ Cantidad de items:', cast.length)
    cast.forEach((item, i) => {
        console.log(`üé¨ Item ${i}:`, {
            personId: item.personId,
            hasPersonId: !!item.personId,
            personFromObject: item.person?.id,
            isPrincipal: item.isPrincipal  // ‚úÖ Log para debugging
        })
    })
    
    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    )

    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event

        if (over && active.id !== over.id) {
            const oldIndex = cast.findIndex((item) => item.personId.toString() === active.id)
            const newIndex = cast.findIndex((item) => item.personId.toString() === over.id)

            // Reordenar array
            const newCast = arrayMove(cast, oldIndex, newIndex)

            // ‚úÖ MODIFICADO: Solo actualizar billingOrder, NO tocar isPrincipal
            const updatedCast = newCast.map((member, index) => ({
                ...member,
                billingOrder: index + 1,
                // isPrincipal se mantiene como est√°, no se modifica autom√°ticamente
            }))

            onCastChange(updatedCast)
        }
    }

    const handleRemove = (index: number) => {
        const newCast = cast.filter((_, i) => i !== index)
        // ‚úÖ MODIFICADO: Solo actualizar billingOrder
        const updatedCast = newCast.map((member, idx) => ({
            ...member,
            billingOrder: idx + 1,
            // isPrincipal se mantiene como est√°
        }))
        onCastChange(updatedCast)
    }

    const handleCharacterNameChange = (index: number, characterName: string) => {
        const newCast = [...cast]
        newCast[index] = {
            ...newCast[index],
            characterName,
        }
        onCastChange(newCast)
    }

    // ‚úÖ NUEVO: Handler para cambiar isPrincipal
    const handlePrincipalChange = (index: number, isPrincipal: boolean) => {
        const newCast = [...cast]
        newCast[index] = {
            ...newCast[index],
            isPrincipal,
        }
        onCastChange(newCast)
    }

    if (cast.length === 0) {
        return (
            <div className="text-center py-8 text-gray-500">
                No hay actores agregados. Usa el bot√≥n de abajo para agregar.
            </div>
        )
    }

    return (
        <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
        >
            <SortableContext
                items={cast.map((item) => item.personId.toString())}
                strategy={verticalListSortingStrategy}
            >
                <div className="space-y-2">
                    {cast.map((member, index) => (
                        <SortableCastItem
                            key={member.personId}
                            member={member}
                            index={index}
                            onRemove={() => handleRemove(index)}
                            onCharacterNameChange={(characterName) => handleCharacterNameChange(index, characterName)}
                            onPrincipalChange={(isPrincipal) => handlePrincipalChange(index, isPrincipal)}  // ‚úÖ NUEVO
                        />
                    ))}
                </div>
            </SortableContext>
        </DndContext>
    )
}

// ==================================================
// src/components/admin/movies/MovieModal/index.tsx
// ==================================================
// src/components/admin/movies/MovieModal/index.tsx
import * as Tabs from '@radix-ui/react-tabs'
import { useMovieModalContext } from '@/contexts/MovieModalContext'

// Componentes del modal
import MovieModalHeader from './MovieModalHeader'
import MovieModalTabs from './MovieModalTabs'
import MovieModalFooter from './MovieModalFooter'

// Tabs
import BasicInfoTab from './tabs/BasicInfoTab'
import MediaTab from './tabs/MediaTab'
import CastTab from './tabs/CastTab'
import CrewTab from './tabs/CrewTab'
import ImagesTab from './tabs/ImagesTab'
import AdvancedTab from './tabs/AdvancedTab'

interface MovieModalProps {
  isOpen: boolean
  onClose: () => void
}

export default function MovieModal({ isOpen, onClose }: MovieModalProps) {
  // Obtener todos los datos del context en lugar de props
  const {
    // Form methods
    handleSubmit,
    
    // UI state
    activeTab,
    setActiveTab,
    isSubmitting,
    
    // Submit handler
    onSubmit
  } = useMovieModalContext()

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-hidden">
        <MovieModalHeader onClose={onClose} />

        <form onSubmit={handleSubmit(onSubmit)} className="overflow-y-auto max-h-[calc(90vh-8rem)]">
          <Tabs.Root value={activeTab} onValueChange={setActiveTab} className="w-full">
            <MovieModalTabs
              activeTab={activeTab}
              onTabChange={setActiveTab}
            />

            <div className="p-6">
              <Tabs.Content value="basic">
                <BasicInfoTab />
              </Tabs.Content>

              <Tabs.Content value="media">
                <MediaTab />
              </Tabs.Content>

              <Tabs.Content value="cast">
                <CastTab />
              </Tabs.Content>

              <Tabs.Content value="crew">
                <CrewTab />
              </Tabs.Content>

              <Tabs.Content value="images">
                <ImagesTab />
              </Tabs.Content>

              <Tabs.Content value="advanced">
                <AdvancedTab />
              </Tabs.Content>
            </div>
          </Tabs.Root>

          <MovieModalFooter onCancel={onClose} />
        </form>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/MovieModalFooter.tsx
// ==================================================
// src/components/admin/movies/MovieModal/MovieModalFooter.tsx
import { Save, Loader2 } from 'lucide-react'
import { useMovieModalContext } from '@/contexts/MovieModalContext'

interface MovieModalFooterProps {
  onCancel: () => void
}

export default function MovieModalFooter({ onCancel }: MovieModalFooterProps) {
  // Obtener todos los datos necesarios del context
  const { 
    isSubmitting, 
    editingMovie, 
    formState 
  } = useMovieModalContext()
  
  const isEditing = !!editingMovie
  const errors = formState?.errors || {}

  return (
    <div className="px-6 py-4 bg-gray-50 border-t border-gray-200 flex items-center justify-end gap-4">
      <button
        type="button"
        onClick={onCancel}
        className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
      >
        Cancelar
      </button>

      {Object.keys(errors).length > 0 && (
        <div className="px-6 py-2 bg-red-50 text-red-800 text-sm">
          Errores: {Object.keys(errors).join(', ')}
          <div className="text-xs mt-1">
            {Object.entries(errors).map(([key, error]: [string, any]) => (
              <div key={key}>
                {key}: {error?.message || error?.type || 'Error desconocido'}
              </div>
            ))}
          </div>
        </div>
      )}

      <button
        type="submit"
        disabled={isSubmitting}
        className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
      >
        {isSubmitting ? (
          <>
            <Loader2 className="w-4 h-4 animate-spin" />
            Guardando...
          </>
        ) : (
          <>
            <Save className="w-4 h-4" />
            {isEditing ? 'Actualizar' : 'Crear'} Pel√≠cula
          </>
        )}
      </button>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/MovieModalHeader.tsx
// ==================================================
// src/components/admin/movies/MovieModal/MovieModalHeader.tsx
import { X } from 'lucide-react'
import { useMovieModalContext } from '@/contexts/MovieModalContext'

interface MovieModalHeaderProps {
  onClose: () => void
}

export default function MovieModalHeader({ onClose }: MovieModalHeaderProps) {
  // Obtener editingMovie del context para determinar si estamos editando
  const { editingMovie } = useMovieModalContext()
  
  const isEditing = !!editingMovie

  return (
    <div className="bg-gray-50 px-6 py-4 border-b border-gray-200">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold text-gray-900">
          {isEditing ? 'Editar Pel√≠cula' : 'Nueva Pel√≠cula'}
        </h2>
        <button
          onClick={onClose}
          className="text-gray-400 hover:text-gray-500"
        >
          <X className="w-6 h-6" />
        </button>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/MovieModalTabs.tsx
// ==================================================
// src/components/admin/movies/MovieModal/MovieModalTabs.tsx
import * as Tabs from '@radix-ui/react-tabs'
import { Info, Image, Users, Briefcase, Settings, Images } from 'lucide-react'

interface MovieModalTabsProps {
  activeTab: string
  onTabChange: (value: string) => void
}

const TABS = [
  { value: 'basic', label: 'Informaci√≥n B√°sica', icon: Info },
  { value: 'media', label: 'Multimedia', icon: Image },
  { value: 'cast', label: 'Reparto', icon: Users },
  { value: 'crew', label: 'Equipo T√©cnico', icon: Briefcase },
  { value: 'images', label: 'Im√°genes', icon: Images },
  { value: 'advanced', label: 'Avanzado', icon: Settings }
]

export default function MovieModalTabs({ activeTab, onTabChange }: MovieModalTabsProps) {
  return (
    <Tabs.List className="flex border-b border-gray-200 px-6 pt-4">
      {TABS.map((tab) => {
        const Icon = tab.icon
        return (
          <Tabs.Trigger
            key={tab.value}
            value={tab.value}
            className={`px-4 py-2 -mb-px text-sm font-medium transition-colors ${
              activeTab === tab.value
                ? 'text-blue-600 border-b-2 border-blue-600'
                : 'text-gray-500 hover:text-gray-700'
            }`}
          >
            <div className="flex items-center gap-2">
              <Icon className="w-4 h-4" />
              {tab.label}
            </div>
          </Tabs.Trigger>
        )
      })}
    </Tabs.List>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/AdvancedTab.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/AdvancedTab.tsx
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import { MONTHS } from '@/lib/shared/dateUtils'
import AlternativeTitlesManager from '@/components/admin/AlternativeTitlesManager'
import MovieLinksManager from '@/components/admin/MovieLinksManager'
import MovieFormEnhanced from '@/components/admin/MovieFormEnhanced'

export default function AdvancedTab() {
  // Obtener todos los datos necesarios del context
  const {
    register,
    watch,
    setValue,

    // Filming date states
    isPartialFilmingStartDate,
    setIsPartialFilmingStartDate,
    partialFilmingStartDate,
    setPartialFilmingStartDate,
    isPartialFilmingEndDate,
    setIsPartialFilmingEndDate,
    partialFilmingEndDate,
    setPartialFilmingEndDate,

    // Data
    alternativeTitles,
    setAlternativeTitles,
    movieFormInitialData,
    movieLinks,
    editingMovie,

    // Handlers
    handleProductionCompaniesChange,
    handleDistributionCompaniesChange,
    handleThemesChange,
    handleLinksChange
  } = useMovieModalContext()

  const editingMovieId = editingMovie?.id

  return (
    <div className="space-y-6">
      {/* Fechas de Rodaje */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Fechas de Rodaje
        </h3>

        {/* Fecha Inicio de Rodaje */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Fecha Inicio de Rodaje
          </label>

          <div className="mb-2">
            <label className="inline-flex items-center">
              <input
                type="checkbox"
                checked={isPartialFilmingStartDate}
                onChange={(e) => setIsPartialFilmingStartDate(e.target.checked)}
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <span className="ml-2 text-sm text-gray-600">
                Fecha incompleta
              </span>
            </label>
          </div>

          {!isPartialFilmingStartDate ? (
            <input
              type="text"
              placeholder="DD/MM/YYYY"
              maxLength={10}
              {...register('filmingStartDate')}
              onChange={(e) => {
                let value = e.target.value.replace(/\D/g, '');
                if (value.length >= 2) value = value.slice(0, 2) + '/' + value.slice(2);
                if (value.length >= 5) value = value.slice(0, 5) + '/' + value.slice(5, 9);
                e.target.value = value;
                
                if (value.length === 10) {
                  const [day, month, year] = value.split('/');
                  if (day && month && year && year.length === 4) {
                    setValue('filmingStartDate', `${year}-${month}-${day}`);
                  }
                }
              }}
              onBlur={(e) => {
                const value = e.target.value;
                if (value.length === 10) {
                  const [day, month, year] = value.split('/');
                  if (day && month && year) {
                    setValue('filmingStartDate', `${year}-${month}-${day}`);
                  }
                }
              }}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            />
          ) : (
            <div className="flex gap-2">
              <div className="flex-1">
                <input
                  type="number"
                  placeholder="A√±o"
                  min="1800"
                  max="2100"
                  value={partialFilmingStartDate.year || ''}
                  onChange={(e) => setPartialFilmingStartDate({
                    ...partialFilmingStartDate,
                    year: e.target.value ? parseInt(e.target.value) : null
                  })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                />
              </div>
              <div className="flex-1">
                <select
                  value={partialFilmingStartDate.month || ''}
                  onChange={(e) => setPartialFilmingStartDate({
                    ...partialFilmingStartDate,
                    month: e.target.value ? parseInt(e.target.value) : null
                  })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                >
                  <option value="">Mes</option>
                  {MONTHS.map(month => (
                    <option key={month.value} value={month.value}>
                      {month.label}
                    </option>
                  ))}
                </select>
              </div>
            </div>
          )}
        </div>

        {/* Fecha Fin de Rodaje */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Fecha Fin de Rodaje
          </label>

          <div className="mb-2">
            <label className="inline-flex items-center">
              <input
                type="checkbox"
                checked={isPartialFilmingEndDate}
                onChange={(e) => setIsPartialFilmingEndDate(e.target.checked)}
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <span className="ml-2 text-sm text-gray-600">
                Fecha incompleta
              </span>
            </label>
          </div>

          {!isPartialFilmingEndDate ? (
            <input
              type="text"
              placeholder="DD/MM/YYYY"
              maxLength={10}
              {...register('filmingEndDate')}
              onChange={(e) => {
                let value = e.target.value.replace(/\D/g, '');
                if (value.length >= 2) value = value.slice(0, 2) + '/' + value.slice(2);
                if (value.length >= 5) value = value.slice(0, 5) + '/' + value.slice(5, 9);
                e.target.value = value;
                
                if (value.length === 10) {
                  const [day, month, year] = value.split('/');
                  if (day && month && year && year.length === 4) {
                    setValue('filmingEndDate', `${year}-${month}-${day}`);
                  }
                }
              }}
              onBlur={(e) => {
                const value = e.target.value;
                if (value.length === 10) {
                  const [day, month, year] = value.split('/');
                  if (day && month && year) {
                    setValue('filmingEndDate', `${year}-${month}-${day}`);
                  }
                }
              }}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            />
          ) : (
            <div className="flex gap-2">
              <div className="flex-1">
                <input
                  type="number"
                  placeholder="A√±o"
                  min="1800"
                  max="2100"
                  value={partialFilmingEndDate.year || ''}
                  onChange={(e) => setPartialFilmingEndDate({
                    ...partialFilmingEndDate,
                    year: e.target.value ? parseInt(e.target.value) : null
                  })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                />
              </div>
              <div className="flex-1">
                <select
                  value={partialFilmingEndDate.month || ''}
                  onChange={(e) => setPartialFilmingEndDate({
                    ...partialFilmingEndDate,
                    month: e.target.value ? parseInt(e.target.value) : null
                  })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                >
                  <option value="">Mes</option>
                  {MONTHS.map(month => (
                    <option key={month.value} value={month.value}>
                      {month.label}
                    </option>
                  ))}
                </select>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Estado de Producci√≥n */}
      <div className="mt-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Estado de Producci√≥n
        </h3>
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Estado de la pel√≠cula
          </label>
          <select
            {...register('stage')}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            defaultValue="COMPLETA"
          >
            <option value="COMPLETA">Completa</option>
            <option value="EN_DESARROLLO">En desarrollo</option>
            <option value="EN_POSTPRODUCCION">En postproducci√≥n</option>
            <option value="EN_PREPRODUCCION">En preproducci√≥n</option>
            <option value="EN_RODAJE">En rodaje</option>
            <option value="INCONCLUSA">Inconclusa</option>
            <option value="INEDITA">In√©dita</option>
          </select>
          <p className="mt-1 text-sm text-gray-500">
            Indica el estado actual de producci√≥n de la pel√≠cula
          </p>
        </div>
      </div>

      {/* Links Oficiales */}
      <div className="mt-6">
        <MovieLinksManager
          key={`links-${editingMovieId || 'new'}-${movieLinks.length}`}
          initialLinks={movieLinks}
          onLinksChange={handleLinksChange}
        />
      </div>

      {/* T√≠tulos Alternativos */}
      <div className="mt-6">
        <AlternativeTitlesManager
          onChange={setAlternativeTitles}
          initialTitles={editingMovieId ? alternativeTitles : []}
        />
      </div>

      {/* Productoras y Distribuidoras */}
      <div className="mt-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Producci√≥n y Distribuci√≥n
        </h3>
        <MovieFormEnhanced
          key={`companies-${editingMovieId || 'new'}`}
          onGenresChange={() => { }}
          onCastChange={() => { }}
          onCrewChange={() => { }}
          onCountriesChange={() => { }}
          onProductionCompaniesChange={handleProductionCompaniesChange}
          onDistributionCompaniesChange={handleDistributionCompaniesChange}
          onThemesChange={() => { }}
          onScreeningVenuesChange={() => { }}
          initialData={movieFormInitialData}
          showOnlyCompanies={true}
        />
      </div>

      {/* Notas Internas */}
      <div className="mt-6">
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Notas Internas
        </label>
        <textarea
          {...register('notes')}
          rows={4}
          placeholder="Anotaciones internas sobre esta pel√≠cula. No se mostrar√°n p√∫blicamente."
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
        />
        <p className="mt-1 text-sm text-gray-500">
          Este campo es solo para uso interno del equipo editorial.
        </p>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/BasicInfoTab.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/BasicInfoTab.tsx
import { useState, useEffect } from 'react'
import { TIPOS_DURACION, DATA_COMPLETENESS_LEVELS, SOUND_TYPES } from '@/lib/movies/movieConstants'
import { MONTHS } from '@/lib/shared/dateUtils'
import { getErrorMessage } from '@/lib/movies/movieUtils'
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import MovieFormEnhanced from '@/components/admin/MovieFormEnhanced'

export default function BasicInfoTab() {
  // Obtener todos los datos necesarios del context
  const {
    // Form methods
    register,
    watch,
    setValue,
    formState,

    // Date states
    isPartialDate,
    setIsPartialDate,
    partialReleaseDate,
    setPartialReleaseDate,

    // UI states
    tipoDuracionDisabled,

    // Metadata
    availableRatings,
    availableColorTypes,

    // Data and handlers
    movieFormInitialData,
    editingMovie,
    handleGenresChange,
    handleCountriesChange,
    handleThemesChange,
    handleScreeningVenuesChange
  } = useMovieModalContext()

  const errors = formState?.errors || {}
  const editingMovieId = editingMovie?.id

  // Estado local para el valor visual de la fecha (DD/MM/YYYY)
  const [releaseDateDisplay, setReleaseDateDisplay] = useState('')

  // Sincronizar estado local con el valor del formulario al cargar/editar
  useEffect(() => {
    const releaseDate = watch('releaseDate')
    if (!releaseDate) {
      setReleaseDateDisplay('')
      return
    }

    // Si es formato YYYY-MM-DD, convertir a DD/MM/YYYY
    if (releaseDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
      const [year, month, day] = releaseDate.split('-')
      setReleaseDateDisplay(`${day}/${month}/${year}`)
    } else if (releaseDate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
      // Ya est√° en formato DD/MM/YYYY
      setReleaseDateDisplay(releaseDate)
    }
  }, [watch('releaseDate')])

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Columna izquierda */}
        <div className="space-y-4">
          <h3 className="text-lg font-medium text-gray-900 mb-4">
            Informaci√≥n Principal
          </h3>

          {/* T√≠tulo */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              T√≠tulo *
            </label>
            <input
              type="text"
              {...register('title')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            />
            {errors.title && (
              <p className="mt-1 text-sm text-red-600">{getErrorMessage(errors.title)}</p>
            )}
          </div>

          <div className="grid grid-cols-2 gap-4">
            {/* A√±o */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                A√±o
              </label>
              <input
                type="number"
                {...register('year', { valueAsNumber: true })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              />
              {errors.year && (
                <p className="mt-1 text-sm text-red-600">{getErrorMessage(errors.year)}</p>
              )}
            </div>

            {/* Fecha de Estreno */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Fecha de Estreno
              </label>

              <div className="mb-2">
                <label className="inline-flex items-center">
                  <input
                    type="checkbox"
                    checked={isPartialDate}
                    onChange={(e) => setIsPartialDate(e.target.checked)}
                    className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                  <span className="ml-2 text-sm text-gray-600">
                    Fecha incompleta
                  </span>
                </label>
              </div>

              {!isPartialDate ? (
                <input
                  type="text"
                  placeholder="DD/MM/YYYY"
                  maxLength={10}
                  value={releaseDateDisplay}
                  onChange={(e) => {
                    const input = e.target.value

                    // Permitir solo n√∫meros y barras
                    let cleaned = input.replace(/[^\d/]/g, '')

                    // Auto-formatear: agregar barras autom√°ticamente
                    const numbers = cleaned.replace(/\//g, '')
                    let formatted = ''

                    if (numbers.length > 0) {
                      formatted = numbers.slice(0, 2)
                      if (numbers.length >= 2) {
                        formatted += '/' + numbers.slice(2, 4)
                      }
                      if (numbers.length >= 4) {
                        formatted += '/' + numbers.slice(4, 8)
                      }
                    }

                    // Actualizar estado local
                    setReleaseDateDisplay(formatted)

                    // Si la fecha est√° completa (DD/MM/YYYY), convertir a YYYY-MM-DD y guardar en el form
                    if (formatted.length === 10) {
                      const [day, month, year] = formatted.split('/')

                      // Validaci√≥n b√°sica
                      const dayNum = parseInt(day)
                      const monthNum = parseInt(month)
                      const yearNum = parseInt(year)

                      if (dayNum >= 1 && dayNum <= 31 &&
                        monthNum >= 1 && monthNum <= 12 &&
                        yearNum >= 1800 && yearNum <= 2100) {
                        setValue('releaseDate', `${year}-${month}-${day}`, { shouldValidate: true })
                      }
                    } else {
                      // Si no est√° completa, limpiar el valor en el form
                      setValue('releaseDate', '', { shouldValidate: false })
                    }
                  }}
                  onBlur={() => {
                    // Al perder el foco, validar formato completo
                    if (releaseDateDisplay && releaseDateDisplay.length !== 10) {
                      // Si no est√° completo, limpiar
                      setReleaseDateDisplay('')
                      setValue('releaseDate', '', { shouldValidate: false })
                    }
                  }}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                />
              ) : (
                <div className="flex gap-2">
                  <div className="flex-1">
                    <input
                      type="number"
                      placeholder="A√±o"
                      min="1800"
                      max="2100"
                      value={partialReleaseDate.year || ''}
                      onChange={(e) => setPartialReleaseDate({
                        ...partialReleaseDate,
                        year: e.target.value ? parseInt(e.target.value) : null
                      })}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    />
                  </div>
                  <div className="flex-1">
                    <select
                      value={partialReleaseDate.month || ''}
                      onChange={(e) => setPartialReleaseDate({
                        ...partialReleaseDate,
                        month: e.target.value ? parseInt(e.target.value) : null
                      })}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    >
                      <option value="">Mes</option>
                      {MONTHS.map(month => (
                        <option key={month.value} value={month.value}>
                          {month.label}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Duraci√≥n */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Duraci√≥n (minutos)
              </label>
              <input
                type="number"
                {...register('duration', { valueAsNumber: true })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Segundos
              </label>
              <input
                type="number"
                min="0"
                max="59"
                {...register('durationSeconds', { valueAsNumber: true })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                placeholder="0-59"
              />
            </div>
          </div>

          {/* Tipo de duraci√≥n */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Tipo de duraci√≥n
              {tipoDuracionDisabled && (
                <span className="ml-2 text-xs text-green-600 font-normal">
                  (Calculado autom√°ticamente)
                </span>
              )}
            </label>
            <select
              {...register('tipoDuracion')}
              disabled={tipoDuracionDisabled}
              className={`w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 ${tipoDuracionDisabled ? 'bg-gray-100' : ''
                }`}
            >
              <option value="">Seleccionar tipo...</option>
              {TIPOS_DURACION.map((tipo) => (
                <option key={tipo.value} value={tipo.value}>
                  {tipo.label}
                </option>
              ))}
            </select>
          </div>

          {/* Informaci√≥n T√©cnica */}
          <div className="space-y-4 pt-4 border-t border-gray-200">
            <h4 className="text-md font-medium text-gray-900">
              Informaci√≥n T√©cnica
            </h4>

            <div className="grid grid-cols-2 gap-4">
              {/* Color */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Color
                </label>
                <select
                  {...register('colorTypeId', { valueAsNumber: true })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                >
                  <option value="">Seleccionar...</option>
                  {availableColorTypes.map((colorType) => (
                    <option key={colorType.id} value={colorType.id}>
                      {colorType.name}
                    </option>
                  ))}
                </select>
              </div>

              {/* Sonido */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Sonido
                </label>
                <select
                  {...register('soundType')}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                >
                  <option value="">Seleccionar...</option>
                  {SOUND_TYPES.map(sound => (
                    <option key={sound.value} value={sound.value}>
                      {sound.label}
                    </option>
                  ))}
                </select>
              </div>
            </div>

            {/* Calificaci√≥n */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Calificaci√≥n
              </label>
              <select
                {...register('ratingId', {
                  setValueAs: (v: string | number) => {
                    if (v === '' || v === '0' || v === 0) return null;
                    return Number(v);
                  }
                })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
              >
                <option value="">Sin calificaci√≥n</option>
                {availableRatings.map((rating) => (
                  <option key={rating.id} value={rating.id}>
                    {rating.name} {rating.abbreviation && `(${rating.abbreviation})`}
                  </option>
                ))}
              </select>
              {(() => {
                const selectedRating = availableRatings.find(r => r.id === watch('ratingId'))
                return selectedRating?.description && (
                  <p className="mt-1 text-sm text-gray-500">
                    {selectedRating.description}
                  </p>
                )
              })()}
            </div>
          </div>
        </div>

        {/* Columna derecha */}
        <div className="space-y-4">
          <h3 className="text-lg font-medium text-gray-900 mb-4">
            Informaci√≥n Adicional
          </h3>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Sinopsis
              {watch('synopsisLocked') && (
                <span className="ml-2 text-xs text-green-600 font-semibold">
                  üîí BLOQUEADA
                </span>
              )}
            </label>
            <textarea
    {...register('synopsis')}
    rows={4}
    readOnly={watch('synopsisLocked')}  // ‚úÖ CAMBIO PRINCIPAL
    className={`w-full px-3 py-2 border rounded-lg transition-all duration-200 ${
      watch('synopsisLocked')
        ? 'bg-gray-200 text-gray-700 border-gray-400 cursor-not-allowed shadow-inner'
        : 'bg-white text-gray-900 border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent'
    }`}
  />
          </div>
          {/* Checkbox para bloquear sinopsis */}
          <div className="mt-2">
            <label className="inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                {...register('synopsisLocked')}
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <span className="ml-2 text-sm text-gray-600">
                üîí Bloquear sinopsis (sinopsis correcta y verificada)
              </span>
            </label>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Tagline
            </label>
            <input
              type="text"
              {...register('tagline')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              IMDb ID
            </label>
            <input
              type="text"
              {...register('imdbId')}
              placeholder="tt0123456"
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Nivel de informaci√≥n cargada *
            </label>
            <select
              {...register('dataCompleteness')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            >
              {DATA_COMPLETENESS_LEVELS.map(level => (
                <option key={level.value} value={level.value}>
                  {level.icon} {level.label}
                </option>
              ))}
            </select>
            <p className="mt-1 text-xs text-gray-500">
              Indica el nivel de detalle cargado
            </p>
          </div>
        </div>
      </div>

      {/* G√©neros, Pa√≠ses, Screening Venues y Temas */}
      <MovieFormEnhanced
        key={editingMovieId || 'new'}
        onGenresChange={handleGenresChange}
        onCastChange={() => { }}
        onCrewChange={() => { }}
        onCountriesChange={handleCountriesChange}
        onProductionCompaniesChange={() => { }}
        onDistributionCompaniesChange={() => { }}
        onThemesChange={handleThemesChange}
        onScreeningVenuesChange={handleScreeningVenuesChange}
        initialData={movieFormInitialData}
        showOnlyBasicInfo={true}
      />
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/CastTab.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/CastTab.tsx
import { useState, useEffect, useMemo } from 'react'
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import { Trash2, Plus, GripVertical } from 'lucide-react'
import PersonSearchInput from '@/components/admin/shared/PersonSearchInput'

// Imports para drag and drop
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

interface CastMember {
  personId: number
  personName?: string
  alternativeNameId?: number | null  // üÜï ID del nombre alternativo
  alternativeName?: string | null     // üÜï Nombre alternativo (para display)
  characterName?: string
  billingOrder?: number
  isPrincipal?: boolean
  isActor?: boolean  // true = actor interpretando personaje, false = aparece como s√≠ mismo
  person?: any
}

// Componente para cada fila draggable
function SortableCastMember({
  member,
  index,
  updateCastMember,
  removeCastMember
}: {
  member: CastMember
  index: number
  updateCastMember: (index: number, updates: Partial<CastMember>) => void
  removeCastMember: (index: number) => void
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: `cast-${index}` })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  // Determinar el nombre a mostrar (alternativo o principal)
  const displayName = member.alternativeName || member.personName || ''

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`bg-gray-50 p-3 rounded-lg ${isDragging ? 'shadow-lg ring-2 ring-blue-500' : ''}`}
    >
      <div className="flex items-center gap-2">
        {/* Handle para arrastrar */}
        <button
          type="button"
          className="cursor-grab active:cursor-grabbing p-1 hover:bg-gray-200 rounded touch-none flex-shrink-0"
          {...attributes}
          {...listeners}
          title="Arrastrar para reordenar"
        >
          <GripVertical className="h-5 w-5 text-gray-400" />
        </button>

        {/* Selector de Persona */}
        <div className="flex-1 min-w-0" style={{ maxWidth: '250px' }}>
          <PersonSearchInput
            value={member.personId}
            alternativeNameId={member.alternativeNameId}
            initialPersonName={displayName}
            onChange={(personId, personName, alternativeNameId, alternativeName) => updateCastMember(index, {
              personId,
              personName: personName,
              alternativeNameId: alternativeNameId || null,
              alternativeName: alternativeName || null
            })}
            placeholder="Buscar actor/actriz..."
          />
        </div>

        {/* Nombre del personaje */}
        <div className="flex-1 min-w-0" style={{ maxWidth: '180px' }}>
          <input
            type="text"
            value={member.characterName || ''}
            onChange={(e) => updateCastMember(index, { characterName: e.target.value })}
            placeholder="Personaje..."
            className="w-full px-2 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
          />
        </div>

        {/* Checkbox Es Actor */}
        <div className="flex items-center gap-1 flex-shrink-0">
          <input
            type="checkbox"
            id={`isActor-${index}`}
            checked={member.isActor !== false}  // default true si undefined
            onChange={(e) => updateCastMember(index, { isActor: e.target.checked })}
            className="rounded border-gray-300 text-green-600 focus:ring-green-500 cursor-pointer"
          />
          <label
            htmlFor={`isActor-${index}`}
            className="text-xs text-gray-700 cursor-pointer select-none whitespace-nowrap"
            title="Desmarcar si aparece como s√≠ mismo (entrevistado, documental)"
          >
            Actor
          </label>
        </div>

        {/* Checkbox Principal */}
        <div className="flex items-center gap-1 flex-shrink-0">
          <input
            type="checkbox"
            id={`principal-${index}`}
            checked={member.isPrincipal || false}
            onChange={(e) => updateCastMember(index, { isPrincipal: e.target.checked })}
            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
          />
          <label
            htmlFor={`principal-${index}`}
            className="text-xs text-gray-700 cursor-pointer select-none whitespace-nowrap"
          >
            Principal
          </label>
        </div>

        {/* Orden (read-only) */}
        <div className="flex-shrink-0" style={{ width: '50px' }}>
          <input
            type="number"
            value={member.billingOrder !== undefined ? member.billingOrder : index + 1}
            readOnly
            className="w-full px-2 py-2 text-sm border border-gray-300 rounded-md bg-gray-100 text-gray-600 cursor-not-allowed text-center"
            title="Orden (se actualiza al arrastrar)"
          />
        </div>

        {/* Bot√≥n eliminar */}
        <button
          type="button"
          onClick={() => removeCastMember(index)}
          className="p-2 text-red-600 hover:text-red-800 hover:bg-red-50 rounded flex-shrink-0"
          title="Eliminar"
        >
          <Trash2 className="h-4 w-4" />
        </button>
      </div>
    </div>
  )
}

export default function CastTab() {
  const {
    movieFormInitialData,
    handleCastChange
  } = useMovieModalContext()

  const [cast, setCast] = useState<CastMember[]>([])

  // Detectar si la pel√≠cula es documental bas√°ndose en los g√©neros
  // El slug del g√©nero documental es 'documental' (ajustar si es diferente)
  const isDocumental = useMemo(() => {
    const genres = movieFormInitialData?.genres || []
    
    // Buscar si alg√∫n g√©nero tiene slug o name que contenga 'documental'
    return genres.some((g: any) => {
      const slug = g.slug || g.genre?.slug || ''
      const name = g.name || g.genre?.name || ''
      return slug.toLowerCase().includes('documental') || 
             name.toLowerCase().includes('documental')
    })
  }, [movieFormInitialData?.genres])

  // Configurar sensores para drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  // Cargar datos del cast desde movieFormInitialData
  useEffect(() => {
    console.log('üé¨ CastTab - movieFormInitialData:', movieFormInitialData)
    console.log('üé¨ CastTab - isDocumental:', isDocumental)

    if (movieFormInitialData?.cast && movieFormInitialData.cast.length > 0) {
      console.log('üé¨ CastTab - Cargando cast:', movieFormInitialData.cast)

      const formattedCast = movieFormInitialData.cast.map((member: any) => {
        console.log('üé¨ Procesando miembro:', member)

        let personName = ''
        if (member.person) {
          personName = member.person.name || `${member.person.firstName || ''} ${member.person.lastName || ''}`.trim()
        }

        // üÜï Obtener nombre alternativo si existe
        let alternativeName: string | null = null
        if (member.alternativeNameId && member.alternativeName) {
          alternativeName = member.alternativeName.fullName || member.alternativeName
        } else if (member.alternativeNameId && member.person?.alternativeNames) {
          // Buscar en los nombres alternativos de la persona
          const altName = member.person.alternativeNames.find(
            (an: any) => an.id === member.alternativeNameId
          )
          if (altName) {
            alternativeName = altName.fullName
          }
        }

        const formatted = {
          personId: member.personId || member.person?.id || 0,
          personName: personName,
          alternativeNameId: member.alternativeNameId || null,
          alternativeName: alternativeName,
          characterName: member.characterName || '',
          billingOrder: member.billingOrder || 0,
          isPrincipal: member.isPrincipal || false,
          isActor: member.isActor !== undefined ? member.isActor : true,  // Leer de BD, default true
          person: member.person
        }

        console.log('üé¨ Miembro formateado:', formatted)
        return formatted
      })

      // Ordenar por billingOrder
      formattedCast.sort((a: CastMember, b: CastMember) => (a.billingOrder || 0) - (b.billingOrder || 0))
      setCast(formattedCast)
    } else {
      setCast([])
    }
  }, [movieFormInitialData?.cast])

  // Notificar cambios al contexto
  useEffect(() => {
    if (cast.length > 0 || movieFormInitialData?.cast?.length > 0) {
      handleCastChange(cast)
    }
  }, [cast])

  // Manejar el fin del drag
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event

    if (over && active.id !== over.id) {
      const oldIndex = cast.findIndex((_, i) => `cast-${i}` === active.id)
      const newIndex = cast.findIndex((_, i) => `cast-${i}` === over.id)

      const reorderedCast = arrayMove(cast, oldIndex, newIndex)

      // Actualizar billingOrder para todos los miembros
      const updatedCast = reorderedCast.map((member, index) => ({
        ...member,
        billingOrder: index + 1
      }))

      setCast(updatedCast)
      console.log('üîÑ Cast reordenado:', updatedCast)
    }
  }

  const updateCastMember = (index: number, updates: Partial<CastMember>) => {
    console.log('üîÑ Actualizando miembro:', index, updates)
    const updatedCast = [...cast]
    updatedCast[index] = {
      ...updatedCast[index],
      ...updates,
      personId: updates.personId || updatedCast[index].personId || 0
    }
    setCast(updatedCast)
  }

  const addCastMember = () => {
    const newMember: CastMember = {
      personId: 0,
      personName: '',
      alternativeNameId: null,
      alternativeName: null,
      characterName: '',
      billingOrder: cast.length + 1,
      isPrincipal: cast.length < 5,  // Primeros 5 son principales por defecto
      isActor: !isDocumental  // Si es documental, default false; sino true
    }
    setCast([...cast, newMember])
    console.log('‚ûï Nuevo miembro agregado, isActor:', !isDocumental)
  }

  const removeCastMember = (index: number) => {
    const updatedCast = cast.filter((_, i) => i !== index)
    // Reajustar billingOrder despu√©s de eliminar
    updatedCast.forEach((member, i) => {
      member.billingOrder = i + 1
    })
    setCast(updatedCast)
  }

  // Contadores para el resumen
  const actoresCount = cast.filter(c => c.isActor !== false).length
  const siMismosCount = cast.filter(c => c.isActor === false).length

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <div>
          <h3 className="text-lg font-medium text-gray-900">Reparto</h3>
          {isDocumental && (
            <p className="text-xs text-amber-600 mt-1">
              üéûÔ∏è Pel√≠cula documental - Las personas se agregan como "s√≠ mismos" por defecto
            </p>
          )}
        </div>
        <span className="text-sm text-gray-500">
          Arrastra para reordenar
        </span>
      </div>

      {cast.length === 0 ? (
        <div className="text-center py-8 bg-gray-50 rounded-lg">
          <p className="text-gray-500">No hay personas en el reparto</p>
          <button
            type="button"
            onClick={addCastMember}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm font-medium"
          >
            Agregar la primera persona
          </button>
        </div>
      ) : (
        <>
          {/* Encabezados de columnas */}
          <div className="flex items-center gap-2 px-3 pb-2 text-xs font-medium text-gray-500 border-b border-gray-200">
            <div className="w-7 flex-shrink-0"></div>
            <div className="flex-1 min-w-0" style={{ maxWidth: '250px' }}>Persona</div>
            <div className="flex-1 min-w-0" style={{ maxWidth: '180px' }}>Personaje</div>
            <div className="flex-shrink-0 w-14 text-center" title="Marcar si interpreta un personaje">Actor</div>
            <div className="flex-shrink-0 w-16 text-center">Principal</div>
            <div className="flex-shrink-0 text-center" style={{ width: '50px' }}>Orden</div>
            <div className="w-10 flex-shrink-0"></div>
          </div>

          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={cast.map((_, i) => `cast-${i}`)}
              strategy={verticalListSortingStrategy}
            >
              <div className="space-y-3">
                {cast.map((member, index) => (
                  <SortableCastMember
                    key={`cast-${index}`}
                    member={member}
                    index={index}
                    updateCastMember={updateCastMember}
                    removeCastMember={removeCastMember}
                  />
                ))}
              </div>
            </SortableContext>
          </DndContext>

          {/* Bot√≥n agregar despu√©s de la lista */}
          <button
            type="button"
            onClick={addCastMember}
            className="inline-flex items-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            <Plus className="h-4 w-4 mr-1" />
            Agregar Persona
          </button>
        </>
      )}

      {/* Resumen */}
      {cast.length > 0 && (
        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-800">
            <strong>{cast.length}</strong> persona{cast.length !== 1 ? 's' : ''} en el reparto
            {actoresCount > 0 && (
              <span className="ml-2">
                ‚Ä¢ {actoresCount} actor{actoresCount !== 1 ? 'es' : ''}
              </span>
            )}
            {siMismosCount > 0 && (
              <span className="ml-2">
                ‚Ä¢ {siMismosCount} como s√≠ mismo{siMismosCount !== 1 ? 's' : ''}
              </span>
            )}
            {cast.filter(c => c.isPrincipal).length > 0 && (
              <span className="ml-2">
                ‚Ä¢ {cast.filter(c => c.isPrincipal).length} principal{cast.filter(c => c.isPrincipal).length !== 1 ? 'es' : ''}
              </span>
            )}
          </p>
        </div>
      )}

      {/* Leyenda explicativa */}
      <div className="text-xs text-gray-500 border-t pt-3 mt-3">
        <p><strong>Actor:</strong> Marca si la persona interpreta un personaje ficticio.</p>
        <p>Desmarca si aparece como s√≠ misma (entrevistado, documental, cameo real).</p>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/CrewTab.tsx
// ==================================================
// components/admin/movies/MovieModal/tabs/CrewTab.tsx
import { useState, useEffect } from 'react'
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import { Trash2, Plus, GripVertical } from 'lucide-react'
import PersonSearchInput from '@/components/admin/shared/PersonSearchInput'
import RoleSelector from '../../RoleSelector'

// Imports para drag and drop
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

interface CrewMember {
  personId: number
  personName?: string
  alternativeNameId?: number | null  // üÜï ID del nombre alternativo
  alternativeName?: string | null     // üÜï Nombre alternativo (para display)
  roleId?: number | null
  role?: any
  department?: string
  billingOrder?: number
  notes?: string  // ‚úÖ CORREGIDO: era 'note', ahora es 'notes'
  person?: any
}

// Componente para cada fila draggable
function SortableCrewMember({ 
  member, 
  index, 
  updateCrewMember, 
  removeCrewMember 
}: {
  member: CrewMember
  index: number
  updateCrewMember: (index: number, updates: Partial<CrewMember>) => void
  removeCrewMember: (index: number) => void
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: `crew-${index}` })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  // Determinar el nombre a mostrar (alternativo o principal)
  const displayName = member.alternativeName || member.personName || ''

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`bg-gray-50 p-4 rounded-lg ${isDragging ? 'shadow-lg ring-2 ring-blue-500' : ''}`}
    >
      <div className="grid grid-cols-12 gap-2">
        {/* Handle para arrastrar */}
        <div className="col-span-1 flex items-center justify-center">
          <button
            type="button"
            className="cursor-grab active:cursor-grabbing p-2 hover:bg-gray-200 rounded touch-none"
            {...attributes}
            {...listeners}
            title="Arrastrar para reordenar"
          >
            <GripVertical className="h-5 w-5 text-gray-400" />
          </button>
        </div>

        {/* Selector de Persona */}
        <div className="col-span-4">
          <label className="block text-xs font-medium text-gray-700 mb-1">
            Persona
          </label>
          <PersonSearchInput
            value={member.personId}
            alternativeNameId={member.alternativeNameId}
            initialPersonName={displayName}
            onChange={(personId, personName, alternativeNameId, alternativeName) => updateCrewMember(index, {
              personId,
              personName: personName,
              alternativeNameId: alternativeNameId || null,
              alternativeName: alternativeName || null
            })}
            placeholder="Buscar persona..."
          />
          {member.personName && !member.alternativeName && (
            <p className="text-xs text-gray-500 mt-1">{member.personName}</p>
          )}
        </div>

        {/* Selector de Rol con b√∫squeda */}
        <div className="col-span-4">
          <label className="block text-xs font-medium text-gray-700 mb-1">
            Rol
          </label>
          <RoleSelector
            value={member.roleId || undefined}
            onChange={(roleId, roleName, department) => updateCrewMember(index, {
              roleId,
              role: roleName,
              department: department || member.department
            })}
            placeholder="Buscar rol..."
          />
          {member.role && typeof member.role === 'string' && (
            <p className="text-xs text-gray-500 mt-1">{member.role}</p>
          )}
        </div>

        {/* Departamento (auto-completado) */}
        <div className="col-span-2">
          <label className="block text-xs font-medium text-gray-700 mb-1">
            Departamento
          </label>
          <input
            type="text"
            value={member.department || ''}
            placeholder="Depto"
            className="w-full px-3 py-2 border border-gray-300 rounded-md bg-gray-100 text-gray-600 cursor-not-allowed text-sm"
            disabled
            readOnly
          />
        </div>

        {/* Bot√≥n eliminar */}
        <div className="col-span-1 flex items-end">
          <button
            type="button"
            onClick={() => removeCrewMember(index)}
            className="p-2 text-red-600 hover:text-red-800 hover:bg-red-50 rounded"
            title="Eliminar miembro"
          >
            <Trash2 className="h-4 w-4" />
          </button>
        </div>
      </div>

      {/* Campos adicionales (segunda fila) */}
      <div className="grid grid-cols-12 gap-2 mt-2">
        <div className="col-span-1"></div> {/* Espacio para alinear con el handle */}
        
        {/* Nota */}
        <div className="col-span-8">
          <input
            type="text"
            value={member.notes || ''}
            onChange={(e) => updateCrewMember(index, { notes: e.target.value })}
            placeholder="Nota adicional (opcional)"
            className="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md"
          />
        </div>

        {/* Orden de facturaci√≥n (ahora read-only) */}
        <div className="col-span-2">
          <input
            type="number"
            value={member.billingOrder !== undefined ? member.billingOrder : index}
            readOnly
            className="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md bg-gray-100 text-gray-600 cursor-not-allowed"
            title="El orden se actualiza autom√°ticamente al arrastrar"
          />
        </div>
      </div>
    </div>
  )
}

export default function CrewTab() {
  const {
    movieFormInitialData,
    handleCrewChange
  } = useMovieModalContext()

  const [crew, setCrew] = useState<CrewMember[]>([])

  // Configurar sensores para drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px de movimiento antes de activar el drag
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  // Cargar datos del crew desde movieFormInitialData
  useEffect(() => {
    console.log('üé¨ CrewTab - movieFormInitialData:', movieFormInitialData)

    if (movieFormInitialData?.crew && movieFormInitialData.crew.length > 0) {
      console.log('üé¨ CrewTab - Cargando crew:', movieFormInitialData.crew)

      const formattedCrew = movieFormInitialData.crew.map((member: any) => {
        console.log('üé¨ Procesando miembro:', member)

        let personName = ''
        if (member.person) {
          personName = `${member.person.firstName || ''} ${member.person.lastName || ''}`.trim()
        }

        let roleId = member.roleId
        if (!roleId && member.role && typeof member.role === 'object') {
          roleId = member.role.id
        }

        let roleName = ''
        if (typeof member.role === 'string') {
          roleName = member.role
        } else if (member.role && typeof member.role === 'object') {
          roleName = member.role.name || ''
        }

        // üÜï Obtener nombre alternativo si existe
        let alternativeName: string | null = null
        if (member.alternativeNameId && member.alternativeName) {
          alternativeName = member.alternativeName.fullName || member.alternativeName
        } else if (member.alternativeNameId && member.person?.alternativeNames) {
          // Buscar en los nombres alternativos de la persona
          const altName = member.person.alternativeNames.find(
            (an: any) => an.id === member.alternativeNameId
          )
          if (altName) {
            alternativeName = altName.fullName
          }
        }

        const formatted = {
          personId: member.personId || member.person?.id || 0,
          personName: personName,
          alternativeNameId: member.alternativeNameId || null,
          alternativeName: alternativeName,
          roleId: roleId || null,
          role: roleName,
          department: member.department || member.role?.department || '',
          billingOrder: member.billingOrder || 0,
          notes: member.notes || '',  // ‚úÖ CORREGIDO: era 'note'
          person: member.person
        }

        console.log('üé¨ Miembro formateado:', formatted)
        return formatted
      })

      // Ordenar por billingOrder
      formattedCrew.sort((a: any, b: any) => (a.billingOrder || 0) - (b.billingOrder || 0))
      setCrew(formattedCrew)
    } else {
      setCrew([])
    }
  }, [movieFormInitialData?.crew])

  // Notificar cambios al contexto
  useEffect(() => {
    if (crew.length > 0 || movieFormInitialData?.crew?.length > 0) {
      handleCrewChange(crew)
    }
  }, [crew])

  // Manejar el fin del drag
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event

    if (over && active.id !== over.id) {
      const oldIndex = crew.findIndex((_, i) => `crew-${i}` === active.id)
      const newIndex = crew.findIndex((_, i) => `crew-${i}` === over.id)

      const reorderedCrew = arrayMove(crew, oldIndex, newIndex)
      
      // Actualizar billingOrder para todos los miembros
      const updatedCrew = reorderedCrew.map((member, index) => ({
        ...member,
        billingOrder: index
      }))

      setCrew(updatedCrew)
      console.log('üîÑ Crew reordenado:', updatedCrew)
    }
  }

  const updateCrewMember = (index: number, updates: Partial<CrewMember>) => {
    console.log('üîÑ Actualizando miembro:', index, updates)
    const updatedCrew = [...crew]
    updatedCrew[index] = {
      ...updatedCrew[index],
      ...updates,
      personId: updates.personId || updatedCrew[index].personId || 0
    }
    setCrew(updatedCrew)
  }

  const addCrewMember = () => {
    const newMember: CrewMember = {
      personId: 0,
      personName: '',
      alternativeNameId: null,
      alternativeName: null,
      roleId: null,
      role: '',
      department: '',
      billingOrder: crew.length,
      notes: ''  // ‚úÖ CORREGIDO: era 'note'
    }
    setCrew([...crew, newMember])
  }

  const removeCrewMember = (index: number) => {
    const updatedCrew = crew.filter((_, i) => i !== index)
    // Reajustar billingOrder despu√©s de eliminar
    updatedCrew.forEach((member, i) => {
      member.billingOrder = i
    })
    setCrew(updatedCrew)
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-medium text-gray-900">Equipo T√©cnico</h3>
        <span className="text-sm text-gray-500">
          Arrastra para reordenar
        </span>
      </div>

      {crew.length === 0 ? (
        <div className="text-center py-8 bg-gray-50 rounded-lg">
          <p className="text-gray-500">No hay miembros del equipo t√©cnico</p>
          <button
            type="button"
            onClick={addCrewMember}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm font-medium"
          >
            Agregar el primer miembro
          </button>
        </div>
      ) : (
        <>
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={crew.map((_, i) => `crew-${i}`)}
              strategy={verticalListSortingStrategy}
            >
              <div className="space-y-3">
                {crew.map((member, index) => (
                  <SortableCrewMember
                    key={`crew-${index}`}
                    member={member}
                    index={index}
                    updateCrewMember={updateCrewMember}
                    removeCrewMember={removeCrewMember}
                  />
                ))}
              </div>
            </SortableContext>
          </DndContext>

          {/* BOT√ìN AGREGAR - DESPU√âS DE LA LISTA */}
          <button
            type="button"
            onClick={addCrewMember}
            className="inline-flex items-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            <Plus className="h-4 w-4 mr-1" />
            Agregar Miembro
          </button>
        </>
      )}

      {/* Resumen */}
      {crew.length > 0 && (
        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-800">
            <strong>{crew.length}</strong> miembro{crew.length !== 1 ? 's' : ''} en el equipo t√©cnico
          </p>
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/ImageEditModal.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/ImageEditModal.tsx
'use client'

import { useState, useEffect } from 'react'
import { X, Save, Trash2, GripVertical } from 'lucide-react'
import { 
  ImageWithRelations, 
  ImageType,
  MOVIE_IMAGE_TYPES,
  IMAGE_TYPE_LABELS 
} from '@/lib/images/imageTypes'
import { imagePresets, generateImageCaption } from '@/lib/images/imageUtils'
import { imagesService } from '@/services/images.service'
import { toast } from 'react-hot-toast'

interface MoviePerson {
  personId: number
  person: {
    id: number
    firstName?: string | null
    lastName?: string | null
  }
}

interface ImageEditModalProps {
  image: ImageWithRelations
  moviePeople: MoviePerson[]  // Cast + Crew de la pel√≠cula
  onClose: () => void
  onSave: (image: ImageWithRelations) => void
  onDelete: (imageId: number) => void
}

interface SelectedPerson {
  personId: number
  position: number
  name: string
}

export function ImageEditModal({ 
  image, 
  moviePeople,
  onClose, 
  onSave,
  onDelete 
}: ImageEditModalProps) {
  const [type, setType] = useState<ImageType>(image.type)
  const [photoDate, setPhotoDate] = useState(image.photoDate?.split('T')[0] || '')
  const [photographerCredit, setPhotographerCredit] = useState(image.photographerCredit || '')
  const [eventName, setEventName] = useState(image.eventName || '')
  const [selectedPeople, setSelectedPeople] = useState<SelectedPerson[]>([])
  const [saving, setSaving] = useState(false)
  const [deleting, setDeleting] = useState(false)

  // Inicializar personas seleccionadas
  useEffect(() => {
    if (image.people) {
      const people = image.people.map(ip => ({
        personId: ip.personId,
        position: ip.position,
        name: ip.person 
          ? `${ip.person.firstName || ''} ${ip.person.lastName || ''}`.trim()
          : `Persona ${ip.personId}`
      }))
      setSelectedPeople(people.sort((a, b) => a.position - b.position))
    }
  }, [image])

  // Generar preview del caption
  const previewCaption = generateImageCaption({
    ...image,
    type,
    eventName: eventName || null,
    people: selectedPeople.map((sp, idx) => ({
      personId: sp.personId,
      position: idx,
      person: moviePeople.find(mp => mp.personId === sp.personId)?.person || {
        id: sp.personId,
        firstName: sp.name.split(' ')[0],
        lastName: sp.name.split(' ').slice(1).join(' ')
      }
    }))
  })

  const handleAddPerson = (personId: number) => {
    const moviePerson = moviePeople.find(mp => mp.personId === personId)
    if (!moviePerson || selectedPeople.some(sp => sp.personId === personId)) return

    const name = `${moviePerson.person.firstName || ''} ${moviePerson.person.lastName || ''}`.trim()
    setSelectedPeople(prev => [
      ...prev,
      { personId, position: prev.length, name }
    ])
  }

  const handleRemovePerson = (personId: number) => {
    setSelectedPeople(prev => 
      prev.filter(p => p.personId !== personId)
        .map((p, idx) => ({ ...p, position: idx }))
    )
  }

  const handleMovePerson = (index: number, direction: 'up' | 'down') => {
    if (
      (direction === 'up' && index === 0) ||
      (direction === 'down' && index === selectedPeople.length - 1)
    ) return

    const newPeople = [...selectedPeople]
    const swapIndex = direction === 'up' ? index - 1 : index + 1
    ;[newPeople[index], newPeople[swapIndex]] = [newPeople[swapIndex], newPeople[index]]
    
    setSelectedPeople(newPeople.map((p, idx) => ({ ...p, position: idx })))
  }

  const handleSave = async () => {
    setSaving(true)
    try {
      const updated = await imagesService.update(image.id, {
        cloudinaryPublicId: image.cloudinaryPublicId,
        type,
        photoDate: photoDate || null,
        photographerCredit: photographerCredit || null,
        eventName: eventName || null,
        movieId: image.movieId,
        people: selectedPeople.map((p, idx) => ({
          personId: p.personId,
          position: idx
        }))
      })
      toast.success('Imagen actualizada')
      onSave(updated)
    } catch (error) {
      console.error('Error guardando imagen:', error)
      toast.error('Error al guardar')
    } finally {
      setSaving(false)
    }
  }

  const handleDelete = async () => {
    if (!confirm('¬øEliminar esta imagen?')) return
    
    setDeleting(true)
    try {
      await imagesService.delete(image.id)
      toast.success('Imagen eliminada')
      onDelete(image.id)
    } catch (error) {
      console.error('Error eliminando imagen:', error)
      toast.error('Error al eliminar')
    } finally {
      setDeleting(false)
    }
  }

  // Personas disponibles (que no est√°n seleccionadas)
  const availablePeople = moviePeople.filter(
    mp => !selectedPeople.some(sp => sp.personId === mp.personId)
  )

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[60]">
      <div className="bg-white rounded-lg max-w-3xl w-full max-h-[90vh] overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="text-lg font-semibold">Editar imagen</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="overflow-y-auto p-4 max-h-[calc(90vh-8rem)]">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Preview de imagen */}
            <div>
              <img
                src={imagePresets.gallery(image.cloudinaryPublicId)}
                alt="Preview"
                className="w-full rounded-lg shadow-md"
              />
              {/* Preview del caption */}
              <div className="mt-3 p-3 bg-gray-50 rounded-lg">
                <p className="text-xs text-gray-500 mb-1">Caption generado:</p>
                <p className="text-sm text-gray-700 italic">{previewCaption}</p>
              </div>
            </div>

            {/* Formulario */}
            <div className="space-y-4">
              {/* Tipo */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Tipo de imagen
                </label>
                <select
                  value={type}
                  onChange={(e) => setType(e.target.value as ImageType)}
                  className="w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500"
                >
                  {MOVIE_IMAGE_TYPES.map(t => (
                    <option key={t} value={t}>{IMAGE_TYPE_LABELS[t]}</option>
                  ))}
                </select>
              </div>

              {/* Evento (solo para PREMIERE) */}
              {type === 'PREMIERE' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Nombre del evento
                  </label>
                  <input
                    type="text"
                    value={eventName}
                    onChange={(e) => setEventName(e.target.value)}
                    placeholder="Ej: Festival de Cannes"
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              )}

              {/* Fecha */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Fecha de la foto
                </label>
                <input
                  type="date"
                  value={photoDate}
                  onChange={(e) => setPhotoDate(e.target.value)}
                  className="w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500"
                />
              </div>

              {/* Fot√≥grafo */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Cr√©dito del fot√≥grafo
                </label>
                <input
                  type="text"
                  value={photographerCredit}
                  onChange={(e) => setPhotographerCredit(e.target.value)}
                  placeholder="Nombre del fot√≥grafo"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500"
                />
              </div>

              {/* Personas */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Personas en la imagen
                </label>
                <p className="text-xs text-gray-500 mb-2">
                  El orden determina c√≥mo aparecen en el caption
                </p>

                {/* Lista de personas seleccionadas */}
                {selectedPeople.length > 0 && (
                  <div className="space-y-1 mb-3">
                    {selectedPeople.map((person, idx) => (
                      <div 
                        key={person.personId}
                        className="flex items-center gap-2 bg-blue-50 rounded px-2 py-1"
                      >
                        <span className="text-xs text-gray-400 w-4">{idx + 1}</span>
                        <span className="flex-1 text-sm">{person.name}</span>
                        <button
                          type="button"
                          onClick={() => handleMovePerson(idx, 'up')}
                          disabled={idx === 0}
                          className="p-1 text-gray-400 hover:text-gray-600 disabled:opacity-30"
                        >
                          ‚Üë
                        </button>
                        <button
                          type="button"
                          onClick={() => handleMovePerson(idx, 'down')}
                          disabled={idx === selectedPeople.length - 1}
                          className="p-1 text-gray-400 hover:text-gray-600 disabled:opacity-30"
                        >
                          ‚Üì
                        </button>
                        <button
                          type="button"
                          onClick={() => handleRemovePerson(person.personId)}
                          className="p-1 text-red-400 hover:text-red-600"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      </div>
                    ))}
                  </div>
                )}

                {/* Selector de personas disponibles */}
                {availablePeople.length > 0 && (
                  <select
                    onChange={(e) => {
                      if (e.target.value) {
                        handleAddPerson(parseInt(e.target.value))
                        e.target.value = ''
                      }
                    }}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500"
                    defaultValue=""
                  >
                    <option value="">+ Agregar persona del cast/crew...</option>
                    {availablePeople.map(mp => (
                      <option key={mp.personId} value={mp.personId}>
                        {`${mp.person.firstName || ''} ${mp.person.lastName || ''}`.trim()}
                      </option>
                    ))}
                  </select>
                )}

                {moviePeople.length === 0 && (
                  <p className="text-sm text-gray-500 italic">
                    Agrega personas al cast o crew para poder seleccionarlas aqu√≠
                  </p>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between p-4 border-t bg-gray-50">
          <button
            type="button"
            onClick={handleDelete}
            disabled={deleting || saving}
            className="flex items-center gap-2 px-4 py-2 text-red-600 hover:bg-red-50 rounded-md transition-colors disabled:opacity-50"
          >
            <Trash2 className="w-4 h-4" />
            {deleting ? 'Eliminando...' : 'Eliminar'}
          </button>
          
          <div className="flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
            >
              Cancelar
            </button>
            <button
              type="button"
              onClick={handleSave}
              disabled={saving || deleting}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50"
            >
              <Save className="w-4 h-4" />
              {saving ? 'Guardando...' : 'Guardar'}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/index.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/index.tsx
'use client'

import { useState, useEffect } from 'react'
import { ImageIcon, Loader2 } from 'lucide-react'
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import { ImageWithRelations } from '@/lib/images/imageTypes'
import { imagePresets, generateImageCaption } from '@/lib/images/imageUtils'
import { imagesService } from '@/services/images.service'
import { MultiImageUpload } from './MultiImageUpload'
import { ImageEditModal } from './ImageEditModal'
import { toast } from 'react-hot-toast'

interface MoviePerson {
    personId: number
    person: {
        id: number
        firstName?: string | null
        lastName?: string | null
    }
}

export default function ImagesTab() {
    const { editingMovie, watch } = useMovieModalContext()

    const [images, setImages] = useState<ImageWithRelations[]>([])
    const [loading, setLoading] = useState(false)
    const [editingImage, setEditingImage] = useState<ImageWithRelations | null>(null)
    const [moviePeople, setMoviePeople] = useState<MoviePerson[]>([])

    const movieId = editingMovie?.id

    // Cargar im√°genes de la pel√≠cula
    useEffect(() => {
        if (movieId) {
            loadImages()
            loadMoviePeople()
        }
    }, [movieId])

    const loadImages = async () => {
        if (!movieId) return
        setLoading(true)
        try {
            const data = await imagesService.getByMovieId(movieId)
            setImages(data)
        } catch (error) {
            console.error('Error cargando im√°genes:', error)
            toast.error('Error al cargar im√°genes')
        } finally {
            setLoading(false)
        }
    }

    // Obtener personas del cast y crew de la pel√≠cula
    // Obtener personas del cast y crew de la pel√≠cula
    const loadMoviePeople = async () => {
        if (!movieId) return

        try {
            const response = await fetch(`/api/movies/${movieId}`)
            const movie = await response.json()

            console.log('üé¨ Cargando personas de la pel√≠cula:', movie.title)

            const people: MoviePerson[] = []
            const seenIds = new Set<number>()

            // Agregar cast - la estructura es { person: { id, firstName, lastName } }
            if (movie.cast && Array.isArray(movie.cast)) {
                movie.cast.forEach((c: any) => {
                    if (c.person && c.person.id && !seenIds.has(c.person.id)) {
                        seenIds.add(c.person.id)
                        people.push({
                            personId: c.person.id,
                            person: {
                                id: c.person.id,
                                firstName: c.person.firstName,
                                lastName: c.person.lastName
                            }
                        })
                    }
                })
            }

            // Agregar crew - misma estructura
            if (movie.crew && Array.isArray(movie.crew)) {
                movie.crew.forEach((c: any) => {
                    if (c.person && c.person.id && !seenIds.has(c.person.id)) {
                        seenIds.add(c.person.id)
                        people.push({
                            personId: c.person.id,
                            person: {
                                id: c.person.id,
                                firstName: c.person.firstName,
                                lastName: c.person.lastName
                            }
                        })
                    }
                })
            }

            // Ordenar alfab√©ticamente
            people.sort((a, b) => {
                const nameA = `${a.person.firstName || ''} ${a.person.lastName || ''}`.trim()
                const nameB = `${b.person.firstName || ''} ${b.person.lastName || ''}`.trim()
                return nameA.localeCompare(nameB)
            })

            console.log('üë• Personas encontradas:', people.length, people)
            setMoviePeople(people)
        } catch (error) {
            console.error('Error cargando personas:', error)
        }
    }

    // Manejar subida masiva
    const handleUploadComplete = async (publicIds: string[]) => {
        if (!movieId || publicIds.length === 0) return

        try {
            const newImages = await imagesService.createBulk(movieId, publicIds, 'STILL')
            setImages(prev => [...newImages, ...prev])
        } catch (error) {
            console.error('Error guardando im√°genes:', error)
            toast.error('Error al guardar algunas im√°genes')
        }
    }

    // Manejar actualizaci√≥n de imagen
    const handleImageSave = (updatedImage: ImageWithRelations) => {
        setImages(prev => prev.map(img =>
            img.id === updatedImage.id ? updatedImage : img
        ))
        setEditingImage(null)
    }

    // Manejar eliminaci√≥n de imagen
    const handleImageDelete = (imageId: number) => {
        setImages(prev => prev.filter(img => img.id !== imageId))
        setEditingImage(null)
    }

    // Si no hay pel√≠cula, mostrar mensaje
    if (!movieId) {
        return (
            <div className="text-center py-12">
                <ImageIcon className="mx-auto h-12 w-12 text-gray-300" />
                <p className="mt-4 text-gray-500">
                    Guard√° la pel√≠cula primero para poder agregar im√°genes
                </p>
            </div>
        )
    }

    return (
        <div className="space-y-6">
            {/* Subida m√∫ltiple */}
            <MultiImageUpload
                movieId={movieId}
                onUploadComplete={handleUploadComplete}
            />

            {/* Galer√≠a de im√°genes */}
            {loading ? (
                <div className="flex items-center justify-center py-12">
                    <Loader2 className="w-8 h-8 animate-spin text-gray-400" />
                </div>
            ) : images.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                    No hay im√°genes cargadas
                </div>
            ) : (
                <>
                    <div className="flex items-center justify-between">
                        <h4 className="text-sm font-medium text-gray-700">
                            {images.length} imagen{images.length !== 1 ? 'es' : ''}
                        </h4>
                        <p className="text-xs text-gray-500">
                            Click en una imagen para editarla
                        </p>
                    </div>

                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                        {images.map(image => (
                            <div
                                key={image.id}
                                onClick={() => setEditingImage(image)}
                                className="group relative aspect-[3/2] rounded-lg overflow-hidden bg-gray-100 cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all"
                            >
                                <img
                                    src={imagePresets.card(image.cloudinaryPublicId)}
                                    alt={generateImageCaption(image)}
                                    className="w-full h-full object-cover"
                                />

                                {/* Overlay con info */}
                                <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity">
                                    <div className="absolute bottom-0 left-0 right-0 p-2">
                                        <p className="text-white text-xs line-clamp-2">
                                            {generateImageCaption(image)}
                                        </p>
                                    </div>
                                </div>

                                {/* Badge de personas */}
                                {image.people && image.people.length > 0 && (
                                    <div className="absolute top-2 right-2 bg-blue-600 text-white text-xs px-1.5 py-0.5 rounded">
                                        {image.people.length}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </>
            )}

            {/* Modal de edici√≥n */}
            {editingImage && (
                <ImageEditModal
                    image={editingImage}
                    moviePeople={moviePeople}
                    onClose={() => setEditingImage(null)}
                    onSave={handleImageSave}
                    onDelete={handleImageDelete}
                />
            )}
        </div>
    )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/MultiImageUpload.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/ImagesTab/MultiImageUpload.tsx
'use client'

import { CldUploadWidget } from 'next-cloudinary'
import { useState, useRef, useCallback } from 'react'
import { ImagePlus } from 'lucide-react'
import { toast } from 'react-hot-toast'

interface MultiImageUploadProps {
  movieId: number
  onUploadComplete: (publicIds: string[]) => void
  disabled?: boolean
}

export function MultiImageUpload({ 
  movieId, 
  onUploadComplete,
  disabled = false 
}: MultiImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false)
  const [uploadCount, setUploadCount] = useState(0)
  const widgetRef = useRef<(() => void) | null>(null)
  
  // Usar ref para los IDs (evita problemas de closure)
  const uploadedIdsRef = useRef<string[]>([])

  const handleUploadSuccess = useCallback((result: any) => {
    if (result.info) {
      const { public_id } = result.info
      console.log('‚úÖ Imagen subida:', public_id)
      uploadedIdsRef.current.push(public_id)
      setUploadCount(prev => prev + 1)
    }
  }, [])

  const handleClose = useCallback(() => {
    const uploadedIds = uploadedIdsRef.current
    console.log('üö™ Widget cerrado, im√°genes subidas:', uploadedIds.length, uploadedIds)
    
    setIsUploading(false)
    
    if (uploadedIds.length > 0) {
      onUploadComplete([...uploadedIds]) // Pasar copia del array
      toast.success(`${uploadedIds.length} imagen(es) subida(s)`)
    }
    
    // Resetear para pr√≥xima subida
    uploadedIdsRef.current = []
    setUploadCount(0)
    
    // Restaurar scroll
    document.body.style.overflow = ''
  }, [onUploadComplete])

  const openWidget = useCallback(() => {
    if (widgetRef.current && !isUploading) {
      // Resetear antes de abrir
      uploadedIdsRef.current = []
      setUploadCount(0)
      setIsUploading(true)
      widgetRef.current()
    }
  }, [isUploading])

  return (
    <CldUploadWidget
      uploadPreset="cinenacional-unsigned"
      options={{
        folder: `cinenacional/gallery/${movieId}`,
        sources: ['local', 'url', 'google_drive', 'dropbox'],
        multiple: true,
        maxFiles: 20,
        clientAllowedFormats: ['jpg', 'jpeg', 'png', 'webp'],
        maxFileSize: 10000000,
        resourceType: 'image',
        showCompletedButton: true,
        showUploadMoreButton: true,
        singleUploadAutoClose: false,
        showPoweredBy: false,
        language: 'es',
        text: {
          es: {
            or: 'O',
            menu: {
              files: 'Mis archivos',
              web: 'Direcci√≥n web',
            },
            actions: {
              upload: 'Subir',
              done: 'Listo'
            },
            local: {
              browse: 'Buscar',
              dd_title_multi: 'Arrastra y suelta tus im√°genes aqu√≠',
              drop_title_multi: 'Suelta los archivos para subirlos',
            }
          }
        }
      }}
      onSuccess={handleUploadSuccess}
      onClose={handleClose}
    >
      {({ open }) => {
        widgetRef.current = open

        return (
          <button
            type="button"
            onClick={openWidget}
            disabled={disabled || isUploading}
            className="w-full border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 cursor-pointer transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUploading ? (
              <>
                <div className="inline-block animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-3"></div>
                <p className="text-sm font-medium text-gray-700">
                  Subiendo im√°genes... ({uploadCount} completadas)
                </p>
              </>
            ) : (
              <>
                <ImagePlus className="mx-auto h-10 w-10 text-gray-400 mb-3" />
                <p className="text-sm font-medium text-gray-900">
                  Click para subir im√°genes
                </p>
                <p className="mt-1 text-xs text-gray-500">
                  Puedes seleccionar m√∫ltiples archivos (hasta 20)
                </p>
                <p className="mt-1 text-xs text-gray-400">
                  JPG, PNG o WEBP ‚Ä¢ M√°x 10MB cada una
                </p>
              </>
            )}
          </button>
        )
      }}
    </CldUploadWidget>
  )
}

// ==================================================
// src/components/admin/movies/MovieModal/tabs/MediaTab.tsx
// ==================================================
// src/components/admin/movies/MovieModal/tabs/MediaTab.tsx
import { useMovieModalContext } from '@/contexts/MovieModalContext'
import { CloudinaryUploadWidget } from '@/components/admin/CloudinaryUploadWidget'

export default function MediaTab() {
  // Obtener datos necesarios del context
  const {
    register,
    watch,
    setValue,
    editingMovie
  } = useMovieModalContext()

  const editingMovieId = editingMovie?.id

  return (
    <div className="space-y-6">
      <h3 className="text-lg font-medium text-gray-900 mb-4">
        Im√°genes y Videos
      </h3>

      <CloudinaryUploadWidget
        value={watch('posterUrl')}
        onChange={(url, publicId) => {
          setValue('posterUrl', url)
          setValue('posterPublicId', publicId)
        }}
        label="Afiche de la Pel√≠cula"
        type="poster"
        movieId={editingMovieId}
      />

      <CloudinaryUploadWidget
        value={watch('backdropUrl')}
        onChange={(url, publicId) => {
          setValue('backdropUrl', url)
          setValue('backdropPublicId', publicId)
        }}
        label="Imagen de Fondo"
        type="backdrop"
        movieId={editingMovieId}
      />

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          URL del Trailer
        </label>
        <input
          type="url"
          {...register('trailerUrl')}
          placeholder="https://youtube.com/watch?v=..."
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
        />
        <p className="mt-1 text-sm text-gray-500">
          Ingresa la URL completa del video en YouTube, Vimeo u otra plataforma
        </p>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MoviesFilters.tsx
// ==================================================
// src/components/admin/movies/MoviesFilters.tsx
import { Search, Plus } from 'lucide-react'

export interface MovieFilters {
  searchTerm: string
  selectedStage: string
  selectedYear: string
  currentPage: number
}

interface MoviesFiltersProps {
  filters: MovieFilters
  onFiltersChange: (filters: Partial<MovieFilters>) => void
  onNewMovie: () => void
}

export default function MoviesFilters({ 
  filters, 
  onFiltersChange, 
  onNewMovie 
}: MoviesFiltersProps) {
  // Generar a√±os desde el actual hasta 50 a√±os atr√°s
  const currentYear = new Date().getFullYear()
  const years = Array.from({ length: 50 }, (_, i) => currentYear - i)

  const handleFilterChange = (key: keyof MovieFilters, value: string | number) => {
    onFiltersChange({ 
      [key]: value,
      // Resetear a p√°gina 1 cuando cambian los filtros
      currentPage: key !== 'currentPage' ? 1 : filters.currentPage 
    })
  }

  return (
    <div className="bg-white rounded-lg shadow p-6 mb-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        {/* B√∫squeda */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
          <input
            type="text"
            placeholder="Buscar pel√≠culas..."
            className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            value={filters.searchTerm}
            onChange={(e) => handleFilterChange('searchTerm', e.target.value)}
          />
        </div>

        {/* Filtro por a√±o */}
        <select
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
          value={filters.selectedYear}
          onChange={(e) => handleFilterChange('selectedYear', e.target.value)}
        >
          <option value="">Todos los a√±os</option>
          {years.map(year => (
            <option key={year} value={year}>{year}</option>
          ))}
        </select>

        {/* Bot√≥n nueva pel√≠cula */}
        <button
          onClick={onNewMovie}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
        >
          <Plus className="w-5 h-5" />
          Nueva Pel√≠cula
        </button>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MoviesPagination.tsx
// ==================================================
// src/components/admin/movies/MoviesPagination.tsx
interface MoviesPaginationProps {
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
}

export default function MoviesPagination({
  currentPage,
  totalPages,
  onPageChange
}: MoviesPaginationProps) {
  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1)
    }
  }

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1)
    }
  }

  return (
    <div className="bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6 mt-4 rounded-lg shadow">
      {/* Vista m√≥vil */}
      <div className="flex-1 flex justify-between sm:hidden">
        <button
          onClick={handlePrevious}
          disabled={currentPage === 1}
          className="relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Anterior
        </button>
        <button
          onClick={handleNext}
          disabled={currentPage === totalPages}
          className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Siguiente
        </button>
      </div>

      {/* Vista desktop */}
      <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
        <div>
          <p className="text-sm text-gray-700">
            P√°gina <span className="font-medium">{currentPage}</span> de{' '}
            <span className="font-medium">{totalPages}</span>
          </p>
        </div>
        <div>
          <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
            <button
              onClick={handlePrevious}
              disabled={currentPage === 1}
              className="relative inline-flex items-center px-4 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              Anterior
            </button>
            
            {/* N√∫meros de p√°gina (opcional, para una versi√≥n m√°s completa) */}
            <span className="relative inline-flex items-center px-4 py-2 border border-gray-300 bg-white text-sm font-medium text-gray-700">
              {currentPage}
            </span>
            
            <button
              onClick={handleNext}
              disabled={currentPage === totalPages}
              className="relative inline-flex items-center px-4 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              Siguiente
            </button>
          </nav>
        </div>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/movies/MoviesTable.tsx
// ==================================================
// src/components/admin/movies/MoviesTable.tsx
import { useState } from 'react'
import { Film, Edit, Trash2, Eye, Star, Loader2 } from 'lucide-react'
import { toast } from 'react-hot-toast'
import { type Movie } from '@/lib/movies/movieTypes'

interface MoviesTableProps {
  movies: Movie[]
  loading: boolean
  onEdit: (movie: Movie) => void
  onDelete: (id: number) => Promise<void>
}

export default function MoviesTable({ 
  movies, 
  loading, 
  onEdit, 
  onDelete 
}: MoviesTableProps) {
  const [deletingMovieId, setDeletingMovieId] = useState<number | null>(null)

  const handleDelete = async (id: number) => {
    if (!confirm('¬øEst√°s seguro de eliminar esta pel√≠cula?')) return
    
    try {
      setDeletingMovieId(id)
      await onDelete(id)
      toast.success('Pel√≠cula eliminada')
    } catch (error) {
      toast.error('Error al eliminar la pel√≠cula')
    } finally {
      setDeletingMovieId(null)
    }
  }

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="flex items-center justify-center h-64">
          <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
        </div>
      </div>
    )
  }

  if (!movies || movies.length === 0) {
    return (
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="text-center py-12">
          <Film className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <p className="text-gray-500">No se encontraron pel√≠culas</p>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Pel√≠cula
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                A√±o
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Director
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Estado
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Rating
              </th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                Acciones
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {movies.map((movie) => (
              <MovieRow
                key={movie.id}
                movie={movie}
                onEdit={onEdit}
                onDelete={handleDelete}
                isDeleting={deletingMovieId === movie.id}
              />
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

// Componente interno para cada fila
interface MovieRowProps {
  movie: Movie
  onEdit: (movie: Movie) => void
  onDelete: (id: number) => void
  isDeleting: boolean
}

function MovieRow({ movie, onEdit, onDelete, isDeleting }: MovieRowProps) {
  return (
    <tr className="hover:bg-gray-50">
      <td className="px-6 py-4 whitespace-nowrap">
        <div className="flex items-center">
          <div className="flex-shrink-0 h-10 w-10">
            {movie.posterUrl ? (
              <img
                className="h-10 w-10 rounded-lg object-cover"
                src={movie.posterUrl}
                alt={movie.title}
              />
            ) : (
              <div className="h-10 w-10 rounded-lg bg-gray-200 flex items-center justify-center">
                <Film className="w-5 h-5 text-gray-400" />
              </div>
            )}
          </div>
          <div className="ml-4">
            <div className="text-sm font-medium text-gray-900">
              {movie.title}
            </div>
            {movie.originalTitle && (
              <div className="text-sm text-gray-500">
                {movie.originalTitle}
              </div>
            )}
          </div>
        </div>
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
        {movie.year}
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        {movie.directors?.map(d => d.name).join(', ') || '-'}
      </td>
      <td className="px-6 py-4 whitespace-nowrap">
        {movie.rating ? (
          <div className="flex items-center">
            <Star className="w-4 h-4 text-yellow-400 fill-current" />
            <span className="ml-1 text-sm text-gray-900">
              {movie.rating}
            </span>
          </div>
        ) : (
          <span className="text-sm text-gray-400">-</span>
        )}
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
        <div className="flex items-center justify-end gap-2">
          <a
            href={`/pelicula/${movie.slug}`}
            target="_blank"
            rel="noopener noreferrer"
            className="text-gray-600 hover:text-gray-900 transition-colors"
            title="Ver pel√≠cula"
          >
            <Eye className="w-4 h-4" />
          </a>
          <button
            onClick={() => onEdit(movie)}
            className="text-blue-600 hover:text-blue-900 transition-colors"
            title="Editar"
          >
            <Edit className="w-4 h-4" />
          </button>
          <button
            onClick={() => onDelete(movie.id)}
            disabled={isDeleting}
            className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50"
            title="Eliminar"
          >
            {isDeleting ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Trash2 className="w-4 h-4" />
            )}
          </button>
        </div>
      </td>
    </tr>
  )
}

// ==================================================
// src/components/admin/movies/RoleSelector.tsx
// ==================================================
// components/admin/RoleSelector.tsx
import { useState, useEffect, useRef } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { Search, X } from 'lucide-react'
import { rolesService } from '@/services/roles.service'
import { 
  Department, 
  DEPARTMENT_LABELS, 
  getDepartmentLabel,
  getDepartmentColor,
  type Role,
  type RoleFilters 
} from '@/lib/roles/rolesTypes'

interface RoleSelectorProps {
  value?: number
  onChange: (roleId: number, roleName: string, department?: string) => void
  placeholder?: string
  disabled?: boolean
}

export default function RoleSelector({ 
  value, 
  onChange, 
  placeholder = "Buscar rol...",
  disabled = false 
}: RoleSelectorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [selectedDepartment, setSelectedDepartment] = useState<Department | ''>('')
  const [roles, setRoles] = useState<Role[]>([])
  const [loading, setLoading] = useState(false)
  const [selectedRole, setSelectedRole] = useState<Role | null>(null)
  
  const containerRef = useRef<HTMLDivElement>(null)
  const debouncedSearch = useDebounce(searchTerm, 300)

  // Cargar rol seleccionado si existe
  useEffect(() => {
    if (value && value > 0) {
      rolesService.getById(value)
        .then(role => {
          setSelectedRole(role)
          setSearchTerm(role.name)
        })
        .catch(err => console.error('Error cargando rol:', err))
    }
  }, [value])

  // Cerrar dropdown al hacer click fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Buscar roles - MEJORADO para usar el servicio correctamente
  useEffect(() => {
    const searchRoles = async () => {
      if (!isOpen) return
      
      setLoading(true)
      try {
        // Si hay b√∫squeda, usar el m√©todo search del servicio
        if (debouncedSearch && debouncedSearch.length >= 2) {
          const results = await rolesService.search(
            debouncedSearch, 
            selectedDepartment || undefined,
            50
          )
          setRoles(results)
        } else {
          // Si no hay b√∫squeda, obtener todos con filtros
          const filters: RoleFilters = {
            department: selectedDepartment || undefined,
            isActive: true,
            limit: 100
          }
          
          const response = await rolesService.getAll(filters)
          setRoles(response.data)
        }
      } catch (error) {
        console.error('Error buscando roles:', error)
        setRoles([])
      } finally {
        setLoading(false)
      }
    }

    searchRoles()
  }, [debouncedSearch, selectedDepartment, isOpen])

  const handleSelectRole = (role: Role) => {
    setSelectedRole(role)
    setSearchTerm(role.name)
    onChange(role.id, role.name, getDepartmentLabel(role.department))
    setIsOpen(false)
  }

  const handleClear = () => {
    setSearchTerm('')
    setSelectedRole(null)
    setSelectedDepartment('')
    onChange(0, '', undefined)
    setIsOpen(false)
  }

  // Agrupar roles por departamento
  const groupedRoles = roles.reduce((acc, role) => {
    const deptLabel = getDepartmentLabel(role.department)
    if (!acc[deptLabel]) acc[deptLabel] = []
    acc[deptLabel].push(role)
    return acc
  }, {} as Record<string, Role[]>)

  // Ordenar departamentos para mostrar
  const sortedDepartments = Object.keys(groupedRoles).sort((a, b) => {
    // Poner "Otros" al final
    if (a === 'Otros') return 1
    if (b === 'Otros') return -1
    return a.localeCompare(b)
  })

  return (
    <div className="relative" ref={containerRef}>
      {/* Filtro por Departamento (opcional) */}
      {!disabled && (
        <div className="mb-2 flex gap-2">
          <select
            value={selectedDepartment}
            onChange={(e) => setSelectedDepartment(e.target.value as Department | '')}
            className="text-sm border border-gray-300 rounded-md px-2 py-1 bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="">Todos los departamentos</option>
            {Object.values(Department).map(dept => (
              <option key={dept} value={dept}>
                {getDepartmentLabel(dept)}
              </option>
            ))}
          </select>
          
          {selectedDepartment && (
            <button
              type="button"
              onClick={() => setSelectedDepartment('')}
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              Limpiar filtro
            </button>
          )}
        </div>
      )}

      {/* Campo de b√∫squeda */}
      <div className="relative">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => {
              setSearchTerm(e.target.value)
              if (!isOpen) setIsOpen(true)
            }}
            onFocus={() => setIsOpen(true)}
            placeholder={placeholder}
            disabled={disabled}
            className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
          />
          {searchTerm && !disabled && (
            <button
              type="button"
              onClick={handleClear}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <X className="h-4 w-4" />
            </button>
          )}
        </div>

        {/* Dropdown de resultados */}
        {isOpen && !disabled && (
          <div className="absolute z-50 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg max-h-96 overflow-auto">
            {loading ? (
              <div className="p-3 text-center text-gray-500">
                <div className="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div>
                <span className="ml-2">Buscando roles...</span>
              </div>
            ) : roles.length === 0 ? (
              <div className="p-3 text-center text-gray-500">
                {debouncedSearch && debouncedSearch.length >= 2 ? 
                  `No se encontraron roles con "${debouncedSearch}"` : 
                  selectedDepartment ? 
                    'No hay roles en este departamento' :
                    'Escribe al menos 2 caracteres para buscar'}
              </div>
            ) : (
              <div className="py-1">
                {sortedDepartments.map(deptLabel => {
                  const deptRoles = groupedRoles[deptLabel]
                  const firstRole = deptRoles[0]
                  const deptColor = getDepartmentColor(firstRole.department)
                  
                  return (
                    <div key={deptLabel}>
                      {/* Header del departamento con color */}
                      <div 
                        className="px-3 py-1.5 text-xs font-semibold text-white sticky top-0 flex justify-between items-center"
                        style={{ backgroundColor: deptColor }}
                      >
                        <span>{deptLabel}</span>
                        <span className="bg-white/20 px-1.5 py-0.5 rounded text-xs">
                          {deptRoles.length}
                        </span>
                      </div>
                      
                      {/* Roles del departamento */}
                      {deptRoles.map(role => (
                        <button
                          key={role.id}
                          type="button"
                          onClick={() => handleSelectRole(role)}
                          className="w-full text-left px-3 py-2 hover:bg-blue-50 transition-colors flex items-center justify-between group"
                        >
                          <div className="flex-1 min-w-0">
                            <div className="flex items-center gap-2">
                              <span className="font-medium text-gray-900">
                                {role.name}
                              </span>
                              {role.isMainRole && (
                                <span className="text-xs bg-yellow-100 text-yellow-800 px-1.5 py-0.5 rounded font-medium">
                                  Principal
                                </span>
                              )}
                            </div>
                            {role.description && (
                              <div className="text-xs text-gray-500 truncate mt-0.5">
                                {role.description}
                              </div>
                            )}
                          </div>
                          {role._count?.crewRoles && role._count.crewRoles > 0 && (
                            <span className="ml-2 text-xs text-gray-400 group-hover:text-gray-600">
                              {role._count.crewRoles} {role._count.crewRoles === 1 ? 'uso' : 'usos'}
                            </span>
                          )}
                        </button>
                      ))}
                    </div>
                  )
                })}
              </div>
            )}

            {/* Sugerencias √∫tiles */}
            {!loading && !debouncedSearch && isOpen && roles.length > 0 && (
              <div className="p-3 border-t border-gray-200 bg-gray-50">
                <p className="text-xs text-gray-500">
                  üí° Mostrando {roles.length} roles{selectedDepartment ? ` de ${getDepartmentLabel(selectedDepartment)}` : ''}
                </p>
              </div>
            )}

            {/* Opci√≥n para crear nuevo rol si no se encuentra */}
            {!loading && debouncedSearch && debouncedSearch.length >= 2 && roles.length === 0 && (
              <div className="border-t border-gray-200">
                <button
                  type="button"
                  className="w-full text-left px-3 py-2 hover:bg-green-50 flex items-center space-x-2 text-green-700"
                  onClick={() => {
                    console.log('Crear nuevo rol:', debouncedSearch)
                    // Aqu√≠ podr√≠as abrir un modal para crear el rol
                    setIsOpen(false)
                  }}
                >
                  <span className="text-sm">
                    ¬øNo encuentras el rol? Solicita agregarlo: "{debouncedSearch}"
                  </span>
                </button>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Mostrar rol seleccionado con badge de color */}
      {selectedRole && !isOpen && (
        <div className="mt-2 flex items-center gap-2">
          <span 
            className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium text-white"
            style={{ backgroundColor: getDepartmentColor(selectedRole.department) }}
          >
            {getDepartmentLabel(selectedRole.department)}
          </span>
          <span className="text-sm text-gray-700 font-medium">
            {selectedRole.name}
          </span>
          {selectedRole.isMainRole && (
            <span className="text-xs bg-yellow-100 text-yellow-800 px-1.5 py-0.5 rounded">
              Principal
            </span>
          )}
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/MoviesFilters.tsx
// ==================================================
// src/components/admin/movies/MoviesFilters.tsx
import { Search, Plus } from 'lucide-react'

interface MoviesFiltersProps {
  searchTerm: string
  onSearchChange: (value: string) => void
  selectedStatus: string
  onStatusChange: (value: string) => void
  selectedStage: string
  onStageChange: (value: string) => void
  selectedYear: string
  onYearChange: (value: string) => void
  onNewMovie: () => void
}

export default function MoviesFilters({
  searchTerm,
  onSearchChange,
  selectedStatus,
  onStatusChange,
  selectedStage,
  onStageChange,
  selectedYear,
  onYearChange,
  onNewMovie
}: MoviesFiltersProps) {
  // Generar array de a√±os (√∫ltimos 50 a√±os)
  const currentYear = new Date().getFullYear()
  const years = Array.from({ length: 50 }, (_, i) => currentYear - i)

  return (
    <div className="bg-white rounded-lg shadow p-6 mb-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        {/* B√∫squeda */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
          <input
            type="text"
            placeholder="Buscar pel√≠culas..."
            className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            value={searchTerm}
            onChange={(e) => onSearchChange(e.target.value)}
          />
        </div>

        {/* Filtro por estado */}
        <select
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
          value={selectedStatus}
          onChange={(e) => onStatusChange(e.target.value)}
        >
          <option value="">Todos los estados</option>
          <option value="DRAFT">Borrador</option>
          <option value="PUBLISHED">Publicado</option>
          <option value="ARCHIVED">Archivado</option>
        </select>

        {/* Filtro por a√±o */}
        <select
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
          value={selectedYear}
          onChange={(e) => onYearChange(e.target.value)}
        >
          <option value="">Todos los a√±os</option>
          {years.map(year => (
            <option key={year} value={year}>{year}</option>
          ))}
        </select>

        {/* Bot√≥n nueva pel√≠cula */}
        <button
          onClick={onNewMovie}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
        >
          <Plus className="w-5 h-5" />
          Nueva Pel√≠cula
        </button>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/MoviesPagination.tsx
// ==================================================
// src/components/admin/MoviesPagination.tsx
interface MoviesPaginationProps {
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
}

export default function MoviesPagination({
  currentPage,
  totalPages,
  onPageChange
}: MoviesPaginationProps) {
  // Si no hay m√∫ltiples p√°ginas, no mostrar nada
  if (totalPages <= 1) return null

  const handlePrevious = () => {
    onPageChange(Math.max(1, currentPage - 1))
  }

  const handleNext = () => {
    onPageChange(Math.min(totalPages, currentPage + 1))
  }

  return (
    <div className="bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6 mt-4 rounded-lg shadow">
      {/* Vista m√≥vil */}
      <div className="flex-1 flex justify-between sm:hidden">
        <button
          onClick={handlePrevious}
          disabled={currentPage === 1}
          className="relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Anterior
        </button>
        <button
          onClick={handleNext}
          disabled={currentPage === totalPages}
          className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Siguiente
        </button>
      </div>

      {/* Vista desktop */}
      <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
        <div>
          <p className="text-sm text-gray-700">
            P√°gina <span className="font-medium">{currentPage}</span> de{' '}
            <span className="font-medium">{totalPages}</span>
          </p>
        </div>
        <div>
          <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
            <button
              onClick={handlePrevious}
              disabled={currentPage === 1}
              className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Anterior
            </button>
            <button
              onClick={handleNext}
              disabled={currentPage === totalPages}
              className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Siguiente
            </button>
          </nav>
        </div>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/MoviesTable.tsx
// ==================================================
// src/components/admin/MoviesTable.tsx
import { Film, Eye, Edit, Trash2, Loader2, Star } from 'lucide-react'

interface Director {
  id: number
  name: string
}

interface Movie {
  id: number
  slug: string
  title: string
  originalTitle?: string
  year: number
  releaseDate?: string
  duration?: number
  rating?: number
  posterUrl?: string
  status: string
  stage?: string
  dataCompleteness?: string
  directors?: Director[]
}

interface MoviesTableProps {
  movies: Movie[]
  loading: boolean
  deletingMovieId: number | null
  onEdit: (movie: Movie) => void
  onDelete: (id: number) => void
}

export default function MoviesTable({
  movies,
  loading,
  deletingMovieId,
  onEdit,
  onDelete
}: MoviesTableProps) {
  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="flex items-center justify-center h-64">
          <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
        </div>
      </div>
    )
  }

  if (!movies || movies.length === 0) {
    return (
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="text-center py-12">
          <Film className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <p className="text-gray-500">No se encontraron pel√≠culas</p>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Pel√≠cula
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                A√±o
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Director
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Estado
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Completitud
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Rating
              </th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                Acciones
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {movies.map((movie) => (
              <tr key={movie.id} className="hover:bg-gray-50">
                <td className="px-6 py-4 whitespace-nowrap">
                  <div className="flex items-center">
                    <div className="flex-shrink-0 h-10 w-10">
                      {movie.posterUrl ? (
                        <img
                          className="h-10 w-10 rounded-lg object-cover"
                          src={movie.posterUrl}
                          alt={movie.title}
                        />
                      ) : (
                        <div className="h-10 w-10 rounded-lg bg-gray-200 flex items-center justify-center">
                          <Film className="w-5 h-5 text-gray-400" />
                        </div>
                      )}
                    </div>
                    <div className="ml-4">
                      <div className="text-sm font-medium text-gray-900">
                        {movie.title}
                      </div>
                      {movie.originalTitle && (
                        <div className="text-sm text-gray-500">
                          {movie.originalTitle}
                        </div>
                      )}
                    </div>
                  </div>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {movie.year}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {movie.directors?.map(d => d.name).join(', ') || '-'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                    movie.status === 'PUBLISHED'
                      ? 'bg-green-100 text-green-800'
                      : movie.status === 'DRAFT'
                        ? 'bg-yellow-100 text-yellow-800'
                        : 'bg-gray-100 text-gray-800'
                  }`}>
                    {movie.status === 'PUBLISHED' ? 'Publicado' :
                      movie.status === 'DRAFT' ? 'Borrador' : 'Archivado'}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className="text-sm text-gray-400">-</span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {movie.rating ? (
                    <div className="flex items-center">
                      <Star className="w-4 h-4 text-yellow-400 fill-current" />
                      <span className="ml-1 text-sm text-gray-900">
                        {movie.rating}
                      </span>
                    </div>
                  ) : (
                    <span className="text-sm text-gray-400">-</span>
                  )}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <div className="flex items-center justify-end gap-2">
                    <a
                      href={`/pelicula/${movie.slug}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-gray-600 hover:text-gray-900 transition-colors"
                      title="Ver pel√≠cula"
                    >
                      <Eye className="w-4 h-4" />
                    </a>
                    <button
                      onClick={() => onEdit(movie)}
                      className="text-blue-600 hover:text-blue-900 transition-colors"
                      title="Editar"
                    >
                      <Edit className="w-4 h-4" />
                    </button>
                    <button
                      onClick={() => onDelete(movie.id)}
                      disabled={deletingMovieId === movie.id}
                      className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50"
                      title="Eliminar"
                    >
                      {deletingMovieId === movie.id ? (
                        <Loader2 className="w-4 h-4 animate-spin" />
                      ) : (
                        <Trash2 className="w-4 h-4" />
                      )}
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/people/PeopleTable.tsx
// ==================================================
// src/components/admin/people/PeopleTable.tsx

'use client';

import { useState } from 'react';
import Link from 'next/link';
import { 
  Edit, 
  Trash2, 
  Search, 
  Eye, 
  Download,
  ChevronLeft,
  ChevronRight,
  Loader2,
  Users
} from 'lucide-react';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { usePeople } from '@/hooks/usePeople';
import { formatPersonName, formatGender, getPersonSummary } from '@/lib/people/peopleUtils';
import { GENDER_OPTIONS, PEOPLE_PAGINATION } from '@/lib/people/peopleConstants';

export function PeopleTable() {
  const [deleteId, setDeleteId] = useState<number | null>(null);
  const [deleteName, setDeleteName] = useState<string>('');
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  
  const {
    people,
    totalCount,
    currentPage,
    totalPages,
    loading,
    filters,
    updateFilter,
    deletePerson,
    exportToCSV,
    goToNextPage,
    goToPreviousPage,
    canGoNext,
    canGoPrevious,
  } = usePeople();

  const handleDelete = async () => {
    if (deleteId) {
      try {
        await deletePerson(deleteId);
        setShowDeleteDialog(false);
        setDeleteId(null);
      } catch (error) {
        // El error ya se maneja en el hook
      }
    }
  };

  const handleDeleteClick = (person: any) => {
    setDeleteId(person.id);
    setDeleteName(formatPersonName(person));
    setShowDeleteDialog(true);
  };

  return (
    <>
      {/* Filtros */}
      <div className="mb-4 flex flex-wrap gap-4">
        <div className="relative flex-1 max-w-sm">
  <Search className="absolute left-3 top-2.5 h-4 w-4 text-gray-400" />
  <input
    type="text"
    placeholder="Buscar por nombre..."
    value={filters.search || ''}
    onChange={(e) => updateFilter('search', e.target.value)}
    className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
  />
  {/* Indicador de b√∫squeda en progreso */}
  {loading && filters.search && (
    <div className="absolute right-3 top-2.5">
      <Loader2 className="h-4 w-4 text-gray-400 animate-spin" />
    </div>
  )}
</div>
        
        <select
          value={filters.gender || ''}
          onChange={(e) => updateFilter('gender', e.target.value as any)}
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
        >
          <option value="">Todos los g√©neros</option>
          {GENDER_OPTIONS.map(option => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>

        <select
          value={String(filters.isActive ?? '')}
          onChange={(e) => updateFilter('isActive', e.target.value === '' ? '' : e.target.value === 'true')}
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
        >
          <option value="">Todos</option>
          <option value="true">Activos</option>
          <option value="false">Inactivos</option>
        </select>

        <button
          onClick={exportToCSV}
          disabled={loading}
          className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors flex items-center gap-2"
        >
          <Download className="w-4 h-4" />
          Exportar CSV
        </button>
      </div>

      {/* Tabla */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Nombre
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Nombre Real
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Informaci√≥n
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  G√©nero
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Links
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Pel√≠culas
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Estado
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Acciones
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {loading ? (
                <tr>
                  <td colSpan={8} className="text-center py-12">
                    <Loader2 className="w-8 h-8 text-blue-600 animate-spin mx-auto" />
                    <p className="mt-2 text-gray-500">Cargando personas...</p>
                  </td>
                </tr>
              ) : people?.length === 0 ? (
                <tr>
                  <td colSpan={8} className="text-center py-12">
                    <Users className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <p className="text-gray-500">
                      {filters.search 
                        ? 'No se encontraron personas con ese criterio de b√∫squeda' 
                        : 'No hay personas registradas'}
                    </p>
                  </td>
                </tr>
              ) : (
                people?.map((person) => (
                  <tr key={person.id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm font-medium text-gray-900">
                        {formatPersonName(person)}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {person.realName || '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {person.birthDate ? (
                        person.hideAge ? (
                          <span className="italic">Fecha oculta</span>
                        ) : (
                          getPersonSummary(person)
                        )
                      ) : (
                        '-'
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {formatGender(person.gender)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      {person._count?.links ? (
                        <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">
                          {person._count.links} {person._count.links === 1 ? 'link' : 'links'}
                        </span>
                      ) : (
                        <span className="text-sm text-gray-400">-</span>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {(person._count?.castRoles || 0) + (person._count?.crewRoles || 0) > 0 ? (
                        <div>
                          {person._count?.castRoles || 0} como actor
                          {((person._count?.crewRoles || 0) > 0) && (
                            <>, {person._count?.crewRoles || 0} como crew</>
                          )}
                        </div>
                      ) : (
                        <span className="text-gray-400">-</span>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        person.isActive 
                          ? 'bg-green-100 text-green-800' 
                          : 'bg-gray-100 text-gray-800'
                      }`}>
                        {person.isActive ? 'Activo' : 'Inactivo'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <div className="flex items-center justify-end gap-2">
                        <Link 
                          href={`/admin/people/${person.id}`}
                          className="text-gray-600 hover:text-gray-900 transition-colors"
                          title="Ver detalles"
                        >
                          <Eye className="w-4 h-4" />
                        </Link>
                        <Link 
                          href={`/admin/people/${person.id}/edit`}
                          className="text-blue-600 hover:text-blue-900 transition-colors"
                          title="Editar"
                        >
                          <Edit className="w-4 h-4" />
                        </Link>
                        <button
                          onClick={() => handleDeleteClick(person)}
                          disabled={
                            (person._count?.castRoles || 0) + (person._count?.crewRoles || 0) > 0
                          }
                          className="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                          title={
                            (person._count?.castRoles || 0) + (person._count?.crewRoles || 0) > 0
                              ? "No se puede eliminar porque tiene pel√≠culas asociadas"
                              : "Eliminar"
                          }
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>
      </div>

      {/* Informaci√≥n y paginaci√≥n */}
      {people && people.length > 0 && totalPages > 1 && (
        <div className="bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6 mt-4 rounded-lg shadow">
          {/* Vista m√≥vil */}
          <div className="flex-1 flex justify-between sm:hidden">
            <button
              onClick={goToPreviousPage}
              disabled={!canGoPrevious || loading}
              className="relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Anterior
            </button>
            <button
              onClick={goToNextPage}
              disabled={!canGoNext || loading}
              className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Siguiente
            </button>
          </div>

          {/* Vista desktop */}
          <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
            <div>
              <p className="text-sm text-gray-700">
                Mostrando <span className="font-medium">
                  {((currentPage - 1) * PEOPLE_PAGINATION.DEFAULT_LIMIT) + 1}
                </span> - <span className="font-medium">
                  {Math.min(currentPage * PEOPLE_PAGINATION.DEFAULT_LIMIT, totalCount)}
                </span> de <span className="font-medium">{totalCount}</span> personas
              </p>
            </div>
            <div>
              <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px">
                <button
                  onClick={goToPreviousPage}
                  disabled={!canGoPrevious || loading}
                  className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <ChevronLeft className="h-5 w-5" />
                  Anterior
                </button>
                
                <span className="relative inline-flex items-center px-4 py-2 border border-gray-300 bg-white text-sm font-medium text-gray-700">
                  P√°gina {currentPage} de {totalPages}
                </span>
                
                <button
                  onClick={goToNextPage}
                  disabled={!canGoNext || loading}
                  className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Siguiente
                  <ChevronRight className="h-5 w-5" />
                </button>
              </nav>
            </div>
          </div>
        </div>
      )}

      {/* Modal de confirmaci√≥n de eliminaci√≥n */}
      {showDeleteDialog && (
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full p-6">
            <h3 className="text-lg font-medium text-gray-900 mb-4">
              ¬øEst√°s seguro?
            </h3>
            <p className="text-sm text-gray-500 mb-6">
              Esta acci√≥n no se puede deshacer. Se eliminar√° permanentemente a{' '}
              <span className="font-semibold">{deleteName}</span> del sistema.
            </p>
            <div className="flex justify-end gap-3">
              <button
                type="button"
                onClick={() => {
                  setShowDeleteDialog(false);
                  setDeleteId(null);
                }}
                className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
              >
                Cancelar
              </button>
              <button
                type="button"
                onClick={handleDelete}
                className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
              >
                Eliminar
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

// ==================================================
// src/components/admin/people/PersonForm.tsx
// ==================================================
// src/components/admin/people/PersonForm.tsx

'use client';

import { useEffect, useState, useRef } from 'react';
import { Save, Loader2, AlertCircle } from 'lucide-react';
import { usePeopleForm } from '@/hooks/usePeopleForm';
import { PersonWithRelations } from '@/lib/people/peopleTypes';
import NationalitiesField from './PersonFormFields/NationalitiesField'
import { CloudinaryUploadWidget } from '@/components/admin/CloudinaryUploadWidget';

// Importar sub-componentes del formulario
import { BasicInfoFields } from './PersonFormFields/BasicInfoFields';
import { BiographyFields } from './PersonFormFields/BiographyFields';
import { LocationFields } from './PersonFormFields/LocationFields';
import { LinksSection } from './PersonFormFields/LinksSection';

interface PersonFormProps {
    personId?: number;
    initialData?: PersonWithRelations;
    onSuccess?: (person: PersonWithRelations) => void;
    onCancel?: () => void;
}

export function PersonForm({
    personId,
    initialData,
    onSuccess,
    onCancel
}: PersonFormProps) {
    const {
        formData,
        loading,
        saving,
        errors,
        isDirty,
        isEdit,
        updateField,
        updateFields,
        addLink,
        updateLink,
        removeLink,
        save,
        cancel,
    } = usePeopleForm({ personId, onSuccess });

    // Estado para nacionalidades
    const [nationalities, setNationalities] = useState<number[]>([]);

    // Usar ref para evitar loops infinitos
    const nationalitiesInitialized = useRef(false);

    // Si hay datos iniciales y no es edici√≥n, cargarlos
    useEffect(() => {
        if (initialData && !personId) {
            updateFields({
                firstName: initialData.firstName || '',
                lastName: initialData.lastName || '',
                realName: initialData.realName || '',
                gender: initialData.gender || '',
            });

            // Cargar nacionalidades si existen
            if (initialData.nationalities) {
                const nationalityIds = initialData.nationalities.map((n: any) => {
                    if (typeof n === 'number') return n;
                    if (typeof n === 'object' && n !== null) {
                        return n.locationId;
                    }
                    return null;
                }).filter((id): id is number => id !== null);
                setNationalities(nationalityIds);
            }
        }
    }, [initialData, personId, updateFields]);

    // Cargar nacionalidades cuando se edita una persona existente
    useEffect(() => {
        if (isEdit && formData.nationalities && formData.nationalities.length > 0 && !nationalitiesInitialized.current) {
            const nationalityIds = Array.isArray(formData.nationalities)
                ? formData.nationalities.map((n: any) => {
                    const id = typeof n === 'object' ? n.locationId : n;
                    return id;
                })
                : [];

            setNationalities(nationalityIds);
            nationalitiesInitialized.current = true;
        }
    }, [isEdit, formData.nationalities]);

    // Funci√≥n para manejar el cambio de nacionalidades
    const handleNationalitiesChange = (newNationalities: number[]) => {
        setNationalities(newNationalities);
        updateField('nationalities', newNationalities);
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        await save();
    };

    const handleCancel = () => {
        if (onCancel) {
            onCancel();
        } else {
            cancel();
        }
    };

    if (loading) {
        return (
            <div className="flex items-center justify-center py-8">
                <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
            </div>
        );
    }

    return (
        <form onSubmit={handleSubmit} className="space-y-6">
            {/* Mostrar errores si hay */}
            {errors.length > 0 && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                    <div className="flex">
                        <AlertCircle className="h-5 w-5 text-red-400 mt-0.5" />
                        <div className="ml-3">
                            <h3 className="text-sm font-medium text-red-800">
                                Se encontraron los siguientes errores:
                            </h3>
                            <ul className="mt-2 text-sm text-red-700 list-disc list-inside">
                                {errors.map((error, index) => (
                                    <li key={index}>{error}</li>
                                ))}
                            </ul>
                        </div>
                    </div>
                </div>
            )}

            {/* Informaci√≥n b√°sica - SIN la foto */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Informaci√≥n Personal
                </h3>
                <BasicInfoFields
                    formData={formData}
                    updateField={updateField}
                    isEdit={isEdit}
                />
            </div>

            {/* Nacionalidades */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Nacionalidades
                </h3>
                <NationalitiesField
                    value={nationalities}
                    onChange={handleNationalitiesChange}
                    disabled={saving}
                />
            </div>

            {/* Ubicaciones */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Ubicaciones
                </h3>
                <LocationFields
                    formData={formData}
                    updateField={updateField}
                />
            </div>

            {/* Biograf√≠a e informaci√≥n adicional */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Informaci√≥n Adicional
                </h3>
                <BiographyFields
                    formData={formData}
                    updateField={updateField}
                />
            </div>

            {/* Links */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Enlaces
                </h3>
                <LinksSection
                    links={formData.links}
                    onAddLink={addLink}
                    onUpdateLink={updateLink}
                    onRemoveLink={removeLink}
                />
            </div>

            {/* FOTO DE PERFIL - MOVIDA AL FINAL */}
            <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-medium text-gray-900 mb-6">
                    Foto de Perfil
                </h3>
                <div className="max-w-md mx-auto">
                    <CloudinaryUploadWidget
                        value={formData.photoUrl}
                        onChange={(url, publicId) => {
                            updateField('photoUrl', url);
                            updateField('photoPublicId', publicId);
                        }}
                        label=""
                        type="person_photo"
                        personId={personId}
                        aspectRatio="3:4"
                        maxWidth={800}
                        maxDisplayHeight={400}  // NUEVO: limitar altura de display
                    />
                </div>
            </div>

            {/* Botones de acci√≥n */}
            <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center justify-between">
                    <div className="text-sm text-gray-500">
                        {isDirty && (
                            <span className="text-orange-600">
                                * Hay cambios sin guardar
                            </span>
                        )}
                    </div>

                    <div className="flex gap-3">
                        <button
                            type="button"
                            onClick={handleCancel}
                            className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                        >
                            Cancelar
                        </button>

                        <button
                            type="submit"
                            disabled={saving || loading}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        >
                            {saving ? (
                                <>
                                    <Loader2 className="w-4 h-4 animate-spin" />
                                    Guardando...
                                </>
                            ) : (
                                <>
                                    <Save className="w-4 h-4" />
                                    {isEdit ? 'Actualizar' : 'Crear'} Persona
                                </>
                            )}
                        </button>
                    </div>
                </div>
            </div>
        </form>
    );
}

// ==================================================
// src/components/admin/people/PersonFormFields/AlternativeNamesSection.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/AlternativeNamesSection.tsx

'use client';

import { PersonAlternativeName } from '@/lib/people/peopleTypes';
import { Plus, Trash2, User } from 'lucide-react';

interface AlternativeNamesSectionProps {
    alternativeNames: PersonAlternativeName[];
    onAdd: () => void;
    onUpdate: (index: number, fullName: string) => void;
    onRemove: (index: number) => void;
}

export function AlternativeNamesSection({
    alternativeNames,
    onAdd,
    onUpdate,
    onRemove
}: AlternativeNamesSectionProps) {
    return (
        <div className="space-y-4">
            <div className="flex items-center justify-between">
                <label className="block text-sm font-medium text-gray-700">
                    <User className="inline w-4 h-4 mr-1" />
                    Nombres Alternativos
                </label>
                <button
                    type="button"
                    onClick={onAdd}
                    className="inline-flex items-center px-3 py-1 text-sm font-medium text-blue-600 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
                >
                    <Plus className="w-4 h-4 mr-1" />
                    Agregar
                </button>
            </div>

            <p className="text-xs text-gray-500">
                Nombres con los que aparece acreditada en algunas pel√≠culas (ej: Andy Kleinman en lugar de Andrea Kleinman)
            </p>

            {alternativeNames.length === 0 ? (
                <p className="text-sm text-gray-400 italic">
                    No hay nombres alternativos registrados
                </p>
            ) : (
                <div className="space-y-2">
                    {alternativeNames.map((altName, index) => (
                        <div key={index} className="flex items-center gap-2">
                            <input
                                type="text"
                                value={altName.fullName}
                                onChange={(e) => onUpdate(index, e.target.value)}
                                placeholder="Nombre alternativo completo"
                                className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            />
                            <button
                                type="button"
                                onClick={() => onRemove(index)}
                                className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-lg transition-colors"
                                title="Eliminar"
                            >
                                <Trash2 className="w-4 h-4" />
                            </button>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

// ==================================================
// src/components/admin/people/PersonFormFields/BasicInfoFields.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/BasicInfoFields.tsx

'use client';

import { PersonFormData, PersonAlternativeName } from '@/lib/people/peopleTypes';
import { Calendar, Plus, Trash2, User } from 'lucide-react';
import { useState, useEffect } from 'react';
import { PartialDate } from '@/lib/shared/dateUtils';

interface BasicInfoFieldsProps {
    formData: PersonFormData;
    updateField: <K extends keyof PersonFormData>(
        field: K,
        value: PersonFormData[K]
    ) => void;
    isEdit: boolean;
}

export function BasicInfoFields({
    formData,
    updateField,
    isEdit
}: BasicInfoFieldsProps) {
    // Estados para fechas parciales
    const [isPartialBirthDate, setIsPartialBirthDate] = useState(false);
    const [partialBirthDate, setPartialBirthDate] = useState<PartialDate>({
        year: null,
        month: null,
        day: null
    });
    
    const [isPartialDeathDate, setIsPartialDeathDate] = useState(false);
    const [partialDeathDate, setPartialDeathDate] = useState<PartialDate>({
        year: null,
        month: null,
        day: null
    });

    // Cargar estados de fechas parciales desde formData
    useEffect(() => {
        if (formData.isPartialBirthDate) {
            setIsPartialBirthDate(true);
            setPartialBirthDate(formData.partialBirthDate || { year: null, month: null, day: null });
        }
        if (formData.isPartialDeathDate) {
            setIsPartialDeathDate(true);
            setPartialDeathDate(formData.partialDeathDate || { year: null, month: null, day: null });
        }
    }, [formData.isPartialBirthDate, formData.isPartialDeathDate, formData.partialBirthDate, formData.partialDeathDate]);

    // Manejar cambios en fechas parciales
    const handlePartialBirthDateChange = (field: keyof PartialDate, value: any) => {
        const updated = { ...partialBirthDate, [field]: value ? parseInt(value) : null };
        setPartialBirthDate(updated);
        updateField('partialBirthDate', updated);
    };

    const handlePartialDeathDateChange = (field: keyof PartialDate, value: any) => {
        const updated = { ...partialDeathDate, [field]: value ? parseInt(value) : null };
        setPartialDeathDate(updated);
        updateField('partialDeathDate', updated);
    };

    const handleBirthDateTypeChange = (isPartial: boolean) => {
        setIsPartialBirthDate(isPartial);
        updateField('isPartialBirthDate', isPartial);
        if (!isPartial) {
            updateField('partialBirthDate', undefined);
        } else {
            updateField('birthDate', '');
        }
    };

    const handleDeathDateTypeChange = (isPartial: boolean) => {
        setIsPartialDeathDate(isPartial);
        updateField('isPartialDeathDate', isPartial);
        if (!isPartial) {
            updateField('partialDeathDate', undefined);
        } else {
            updateField('deathDate', '');
        }
    };

    // --- Funciones para nombres alternativos ---
    const alternativeNames = formData.alternativeNames || [];

    const handleAddAlternativeName = () => {
        const newAltName: PersonAlternativeName = { fullName: '' };
        updateField('alternativeNames', [...alternativeNames, newAltName]);
    };

    const handleUpdateAlternativeName = (index: number, fullName: string) => {
        const updated = alternativeNames.map((alt, i) => 
            i === index ? { ...alt, fullName } : alt
        );
        updateField('alternativeNames', updated);
    };

    const handleRemoveAlternativeName = (index: number) => {
        const updated = alternativeNames.filter((_, i) => i !== index);
        updateField('alternativeNames', updated);
    };

    // Generar opciones de a√±os
    const currentYear = new Date().getFullYear();
    const years = Array.from({ length: 150 }, (_, i) => currentYear - i);
    const months = [
        { value: 1, label: 'Enero' },
        { value: 2, label: 'Febrero' },
        { value: 3, label: 'Marzo' },
        { value: 4, label: 'Abril' },
        { value: 5, label: 'Mayo' },
        { value: 6, label: 'Junio' },
        { value: 7, label: 'Julio' },
        { value: 8, label: 'Agosto' },
        { value: 9, label: 'Septiembre' },
        { value: 10, label: 'Octubre' },
        { value: 11, label: 'Noviembre' },
        { value: 12, label: 'Diciembre' }
    ];

    return (
        <div className="space-y-6">
            {/* Nombre y datos b√°sicos */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                        Nombre
                    </label>
                    <input
                        type="text"
                        value={formData.firstName}
                        onChange={(e) => updateField('firstName', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Ej: Juan"
                    />
                </div>

                <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                        Apellido
                    </label>
                    <input
                        type="text"
                        value={formData.lastName}
                        onChange={(e) => updateField('lastName', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Ej: P√©rez"
                    />
                </div>

                <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                        Nombre Real/Completo
                    </label>
                    <input
                        type="text"
                        value={formData.realName || ''}
                        onChange={(e) => updateField('realName', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Ej: Juan Carlos P√©rez Garc√≠a"
                    />
                </div>

                <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                        G√©nero
                    </label>
                    <select
                        value={formData.gender || ''}
                        onChange={(e) => updateField('gender', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    >
                        <option value="">Seleccionar...</option>
                        <option value="MALE">Masculino</option>
                        <option value="FEMALE">Femenino</option>
                        <option value="OTHER">Otro</option>
                    </select>
                </div>
            </div>

            {/* Nombres Alternativos */}
            <div className="space-y-4">
                <div className="flex items-center justify-between">
                    <label className="block text-sm font-medium text-gray-700">
                        <User className="inline w-4 h-4 mr-1" />
                        Nombres Alternativos
                    </label>
                    <button
                        type="button"
                        onClick={handleAddAlternativeName}
                        className="inline-flex items-center px-3 py-1 text-sm font-medium text-blue-600 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
                    >
                        <Plus className="w-4 h-4 mr-1" />
                        Agregar
                    </button>
                </div>

                <p className="text-xs text-gray-500">
                    Nombres con los que aparece acreditada en algunas pel√≠culas (ej: Andy Kleinman en lugar de Andrea Kleinman)
                </p>

                {alternativeNames.length === 0 ? (
                    <p className="text-sm text-gray-400 italic">
                        No hay nombres alternativos registrados
                    </p>
                ) : (
                    <div className="space-y-2">
                        {alternativeNames.map((altName, index) => (
                            <div key={index} className="flex items-center gap-2">
                                <input
                                    type="text"
                                    value={altName.fullName}
                                    onChange={(e) => handleUpdateAlternativeName(index, e.target.value)}
                                    placeholder="Nombre alternativo completo"
                                    className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                />
                                <button
                                    type="button"
                                    onClick={() => handleRemoveAlternativeName(index)}
                                    className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-lg transition-colors"
                                    title="Eliminar"
                                >
                                    <Trash2 className="w-4 h-4" />
                                </button>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Fecha de nacimiento */}
            <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                    <Calendar className="inline w-4 h-4 mr-1" />
                    Fecha de Nacimiento
                </label>
                
                <div className="mb-2">
                    <label className="inline-flex items-center">
                        <input
                            type="checkbox"
                            checked={isPartialBirthDate}
                            onChange={(e) => handleBirthDateTypeChange(e.target.checked)}
                            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <span className="ml-2 text-sm text-gray-600">
                            Fecha incompleta (solo a√±o o a√±o/mes)
                        </span>
                    </label>
                </div>

                {isPartialBirthDate ? (
                    <div className="grid grid-cols-3 gap-2">
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">A√±o</label>
                            <select
                                value={partialBirthDate.year || ''}
                                onChange={(e) => handlePartialBirthDateChange('year', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                            >
                                <option value="">----</option>
                                {years.map(year => (
                                    <option key={year} value={year}>{year}</option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">Mes</label>
                            <select
                                value={partialBirthDate.month || ''}
                                onChange={(e) => handlePartialBirthDateChange('month', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                disabled={!partialBirthDate.year}
                            >
                                <option value="">--</option>
                                {months.map(month => (
                                    <option key={month.value} value={month.value}>
                                        {month.label}
                                    </option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">D√≠a</label>
                            <input
                                type="number"
                                min="1"
                                max="31"
                                value={partialBirthDate.day || ''}
                                onChange={(e) => handlePartialBirthDateChange('day', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                disabled={!partialBirthDate.month}
                                placeholder="--"
                            />
                        </div>
                    </div>
                ) : (
                    <input
                        type="date"
                        value={formData.birthDate}
                        onChange={(e) => updateField('birthDate', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    />
                )}
            </div>

            {/* Fecha de muerte */}
            <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                    <Calendar className="inline w-4 h-4 mr-1" />
                    Fecha de Fallecimiento
                </label>
                
                <div className="mb-2">
                    <label className="inline-flex items-center">
                        <input
                            type="checkbox"
                            checked={isPartialDeathDate}
                            onChange={(e) => handleDeathDateTypeChange(e.target.checked)}
                            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <span className="ml-2 text-sm text-gray-600">
                            Fecha incompleta (solo a√±o o a√±o/mes)
                        </span>
                    </label>
                </div>

                {isPartialDeathDate ? (
                    <div className="grid grid-cols-3 gap-2">
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">A√±o</label>
                            <select
                                value={partialDeathDate.year || ''}
                                onChange={(e) => handlePartialDeathDateChange('year', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                            >
                                <option value="">----</option>
                                {years.map(year => (
                                    <option key={year} value={year}>{year}</option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">Mes</label>
                            <select
                                value={partialDeathDate.month || ''}
                                onChange={(e) => handlePartialDeathDateChange('month', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                disabled={!partialDeathDate.year}
                            >
                                <option value="">--</option>
                                {months.map(month => (
                                    <option key={month.value} value={month.value}>
                                        {month.label}
                                    </option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label className="block text-xs text-gray-500 mb-1">D√≠a</label>
                            <input
                                type="number"
                                min="1"
                                max="31"
                                value={partialDeathDate.day || ''}
                                onChange={(e) => handlePartialDeathDateChange('day', e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                disabled={!partialDeathDate.month}
                                placeholder="--"
                            />
                        </div>
                    </div>
                ) : (
                    <input
                        type="date"
                        value={formData.deathDate}
                        onChange={(e) => updateField('deathDate', e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    />
                )}
            </div>

            {/* Opciones adicionales */}
            <div className="space-y-3">
                <label className="inline-flex items-center">
                    <input
                        type="checkbox"
                        checked={formData.hideAge || false}
                        onChange={(e) => updateField('hideAge', e.target.checked)}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-700">
                        Ocultar edad en el perfil p√∫blico
                    </span>
                </label>

                <label className="inline-flex items-center">
                    <input
                        type="checkbox"
                        checked={formData.isActive !== false}
                        onChange={(e) => updateField('isActive', e.target.checked)}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-700">
                        Persona activa (visible en el sitio)
                    </span>
                </label>
            </div>
        </div>
    );
}

// ==================================================
// src/components/admin/people/PersonFormFields/BiographyFields.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/BiographyFields.tsx

import { PersonFormData } from '@/lib/people/peopleTypes';
import { Image, FileText } from 'lucide-react';

interface BiographyFieldsProps {
  formData: PersonFormData;
  updateField: <K extends keyof PersonFormData>(field: K, value: PersonFormData[K]) => void;
}

export function BiographyFields({ formData, updateField }: BiographyFieldsProps) {
  return (
    <div className="space-y-6">
      {/* Biograf√≠a */}
      <div>
        <label htmlFor="biography" className="block text-sm font-medium text-gray-700 mb-1">
          <span className="flex items-center gap-2">
            <FileText className="w-4 h-4" />
            Biograf√≠a
          </span>
        </label>
        <textarea
          id="biography"
          value={formData.biography}
          onChange={(e) => updateField('biography', e.target.value)}
          placeholder="Escriba aqu√≠ la biograf√≠a de la persona..."
          rows={6}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 resize-none"
        />
        <div className="mt-1 flex justify-between text-sm text-gray-500">
          <span>Puede usar formato Markdown para dar estilo al texto</span>
          <span>{(formData.biography  || '').length } caracteres</span>
        </div>
      </div>

      {/* URL de Foto */}
      <div>
        <label htmlFor="photoUrl" className="block text-sm font-medium text-gray-700 mb-1">
          <span className="flex items-center gap-2">
            <Image className="w-4 h-4" />
            URL de Foto
          </span>
        </label>
        <input
          type="url"
          id="photoUrl"
          value={formData.photoUrl}
          onChange={(e) => updateField('photoUrl', e.target.value)}
          placeholder="https://ejemplo.com/foto.jpg"
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
        />
        <p className="mt-1 text-sm text-gray-500">
          Ingrese la URL completa de la imagen. Se recomienda usar im√°genes de al menos 400x600px
        </p>
      </div>

      {/* Vista previa de la imagen si hay URL */}
      {formData.photoUrl && (
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Vista previa
          </label>
          <div className="relative w-32 h-48 rounded-lg overflow-hidden border border-gray-300">
            <img
              src={formData.photoUrl}
              alt="Vista previa"
              className="w-full h-full object-cover"
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.style.display = 'none';
                const errorDiv = target.nextElementSibling as HTMLElement;
                if (errorDiv) errorDiv.style.display = 'flex';
              }}
            />
            <div 
              className="absolute inset-0 bg-gray-100 items-center justify-center hidden"
              style={{ display: 'none' }}
            >
              <span className="text-sm text-gray-500">
                Error al cargar imagen
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// ==================================================
// src/components/admin/people/PersonFormFields/LinksSection.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/LinksSection.tsx

import { Plus, Trash2, ExternalLink, GripVertical } from 'lucide-react';
import { PersonLink } from '@/lib/people/peopleTypes';
import { PERSON_LINK_TYPE_OPTIONS, LINK_CATEGORIES } from '@/lib/people/peopleConstants';

interface LinksSectionProps {
  links: PersonLink[];
  onAddLink: () => void;
  onUpdateLink: (index: number, updates: Partial<PersonLink>) => void;
  onRemoveLink: (index: number) => void;
}

export function LinksSection({ 
  links, 
  onAddLink, 
  onUpdateLink, 
  onRemoveLink 
}: LinksSectionProps) {
  return (
    <div className="space-y-4">
      {/* Descripci√≥n y bot√≥n agregar */}
      <div className="flex justify-between items-center">
        <p className="text-sm text-gray-500">
          Agregue enlaces a perfiles en redes sociales, sitios web, etc.
        </p>
        <button
          type="button"
          onClick={onAddLink}
          className="inline-flex items-center gap-2 px-3 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
        >
          <Plus className="w-4 h-4" />
          Agregar Enlace
        </button>
      </div>

      {/* Lista de links */}
      {links.length === 0 ? (
        <div className="text-center py-8 bg-gray-50 rounded-lg">
          <p className="text-gray-500 mb-4">
            No hay enlaces agregados
          </p>
          <button
            type="button"
            onClick={onAddLink}
            className="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
          >
            <Plus className="w-4 h-4" />
            Agregar primer enlace
          </button>
        </div>
      ) : (
        <div className="space-y-3">
          {links.map((link, index) => (
            <div key={index} className="border border-gray-200 rounded-lg p-4 bg-gray-50">
              <div className="space-y-4">
                {/* Header del link */}
                <div className="flex items-start justify-between">
                  <div className="flex items-center gap-2 text-sm text-gray-500">
                    <GripVertical className="w-4 h-4" />
                    Enlace #{index + 1}
                  </div>
                  <button
                    type="button"
                    onClick={() => onRemoveLink(index)}
                    className="text-red-600 hover:text-red-800 transition-colors"
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>

                {/* Tipo y T√≠tulo */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Tipo de enlace
                    </label>
                    <select
                      value={link.type}
                      onChange={(e) => onUpdateLink(index, { type: e.target.value as any })}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    >
                      {Object.entries(LINK_CATEGORIES).map(([key, category]) => (
                        <optgroup key={key} label={category.label}>
                          {category.types.map((type) => {
                            const option = PERSON_LINK_TYPE_OPTIONS.find(opt => opt.value === type);
                            return (
                              <option key={type} value={type}>
                                {option?.label || type}
                              </option>
                            );
                          })}
                        </optgroup>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      T√≠tulo <span className="text-gray-400">(opcional)</span>
                    </label>
                    <input
                      type="text"
                      value={link.title || ''}
                      onChange={(e) => onUpdateLink(index, { title: e.target.value })}
                      placeholder="Ej: Perfil oficial"
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    />
                  </div>
                </div>

                {/* URL */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    URL
                  </label>
                  <div className="flex gap-2">
                    <input
                      type="url"
                      value={link.url}
                      onChange={(e) => onUpdateLink(index, { url: e.target.value })}
                      placeholder="https://..."
                      required
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    />
                    {link.url && (
                      <button
                        type="button"
                        onClick={() => window.open(link.url, '_blank')}
                        title="Abrir enlace"
                        className="px-3 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
                      >
                        <ExternalLink className="w-4 h-4" />
                      </button>
                    )}
                  </div>
                </div>

                {/* Opciones */}
                <div className="flex items-center gap-6">
                  <label className="inline-flex items-center">
                    <input
                      type="checkbox"
                      checked={link.isVerified}
                      onChange={(e) => onUpdateLink(index, { isVerified: e.target.checked })}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <span className="ml-2 text-sm text-gray-700">Verificado</span>
                  </label>

                  <label className="inline-flex items-center">
                    <input
                      type="checkbox"
                      checked={link.isActive}
                      onChange={(e) => onUpdateLink(index, { isActive: e.target.checked })}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <span className="ml-2 text-sm text-gray-700">Activo</span>
                  </label>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Informaci√≥n adicional */}
      {links.length > 0 && (
        <p className="text-xs text-gray-500">
          Los enlaces verificados se mostrar√°n con un √≠cono especial. 
          Los enlaces inactivos no se mostrar√°n en el sitio p√∫blico.
        </p>
      )}
    </div>
  );
}

// ==================================================
// src/components/admin/people/PersonFormFields/LocationFields.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/LocationFields.tsx

import { useState, useEffect, useCallback, useRef } from 'react';
import { PersonFormData } from '@/lib/people/peopleTypes';
import { MapPin, Search, X, Loader2 } from 'lucide-react';
import debounce from 'lodash/debounce';

interface LocationFieldsProps {
  formData: PersonFormData;
  updateField: <K extends keyof PersonFormData>(field: K, value: PersonFormData[K]) => void;
}

interface Location {
  id: number;
  name: string;
  slug: string;
  parentId?: number;
  path?: string;
  parent?: {
    name: string;
    parent?: {
      name: string;
    };
  };
}

// Componente de Autocompletado reutilizable
function LocationAutocomplete({ 
  value, 
  onChange, 
  placeholder,
  disabled = false,
  label
}: {
  value: number | null;
  onChange: (locationId: number | null, locationName: string) => void;
  placeholder: string;
  disabled?: boolean;
  label: string;
}) {
  const [isOpen, setIsOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [displayValue, setDisplayValue] = useState('');
  const [locations, setLocations] = useState<Location[]>([]);
  const [loading, setLoading] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Cargar el valor inicial si existe
  useEffect(() => {
    if (value) {
      fetchLocationById(value);
    }
  }, [value]);

  // Obtener ubicaci√≥n por ID
  const fetchLocationById = async (locationId: number) => {
    try {
      const response = await fetch(`/api/locations/${locationId}`);
      if (response.ok) {
        const location = await response.json();
        // Usar el path completo que ya viene del API
        const formatted = location.path || formatLocationDisplay(location);
        setDisplayValue(formatted);
        setSearchTerm(formatted);
      }
    } catch (error) {
      console.error('Error fetching location:', error);
    }
  };

  // Cerrar dropdown al hacer clic fuera
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Buscar ubicaciones
  const searchLocations = useCallback(
    debounce(async (query: string) => {
      if (!query || query.length < 2) {
        setLocations([]);
        return;
      }

      setLoading(true);
      try {
        const response = await fetch(`/api/locations/search?q=${encodeURIComponent(query)}`);
        if (response.ok) {
          const data = await response.json();
          setLocations(data);
        }
      } catch (error) {
        console.error('Error searching locations:', error);
      } finally {
        setLoading(false);
      }
    }, 300),
    []
  );

  // Formatear la ubicaci√≥n para mostrar (con jerarqu√≠a)
  const formatLocationDisplay = (location: Location): string => {
    const parts = [location.name];
    
    // Si tiene path, usarlo directamente
    if ('path' in location && location.path) {
      return location.path;
    }
    
    // Si no, construir la jerarqu√≠a
    if (location.parent) {
      parts.push(location.parent.name);
      if (location.parent.parent) {
        parts.push(location.parent.parent.name);
      }
    }
    
    return parts.join(', ');
  };

  // Manejar cambio en el input
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setSearchTerm(value);
    setDisplayValue(value);
    
    if (value.length >= 2) {
      setIsOpen(true);
      searchLocations(value);
    } else {
      setIsOpen(false);
      setLocations([]);
    }
  };

  // Seleccionar una ubicaci√≥n
  const handleSelectLocation = (location: Location) => {
    const formatted = formatLocationDisplay(location);
    console.log('Selected location:', { location, formatted });
    setSearchTerm(formatted);
    setDisplayValue(formatted);
    onChange(location.id, formatted);
    setIsOpen(false);
    setLocations([]);
  };

  // Limpiar campo
  const handleClear = () => {
    setSearchTerm('');
    setDisplayValue('');
    onChange(null, '');
    setLocations([]);
    inputRef.current?.focus();
  };

  return (
    <div>
      <label htmlFor={label} className="block text-sm font-medium text-gray-700 mb-1">
        <span className="flex items-center gap-2">
          <MapPin className="w-4 h-4" />
          {label}
        </span>
      </label>
      <div className="relative" ref={dropdownRef}>
        <div className="relative">
          <input
            ref={inputRef}
            type="text"
            id={label}
            value={searchTerm}
            onChange={handleInputChange}
            onFocus={() => searchTerm.length >= 2 && setIsOpen(true)}
            placeholder={placeholder}
            disabled={disabled}
            className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 disabled:bg-gray-50 disabled:text-gray-500"
            autoComplete="off"
          />
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <Search className="h-4 w-4 text-gray-400" />
          </div>
          {searchTerm && !disabled && (
            <button
              type="button"
              onClick={handleClear}
              className="absolute inset-y-0 right-0 pr-3 flex items-center"
            >
              <X className="h-4 w-4 text-gray-400 hover:text-gray-600" />
            </button>
          )}
        </div>

        {/* Dropdown de resultados */}
        {isOpen && !disabled && (
          <div className="absolute z-50 mt-1 w-full bg-white rounded-lg shadow-lg border border-gray-200 max-h-60 overflow-auto">
            {loading ? (
              <div className="px-4 py-3 text-center">
                <Loader2 className="h-4 w-4 animate-spin inline-block text-gray-500" />
                <span className="ml-2 text-sm text-gray-500">Buscando...</span>
              </div>
            ) : locations.length > 0 ? (
              <ul className="py-1">
                {locations.map((location) => (
                  <li key={location.id}>
                    <button
                      type="button"
                      onClick={() => handleSelectLocation(location)}
                      className="w-full px-4 py-2 text-left hover:bg-gray-100 focus:bg-gray-100 focus:outline-none transition-colors"
                    >
                      <div className="flex items-center">
                        <MapPin className="h-4 w-4 text-gray-400 mr-2 flex-shrink-0" />
                        <div>
                          <div className="text-sm font-medium text-gray-900">
                            {location.name}
                          </div>
                          {(location.parent?.name || location.parent?.parent?.name) && (
                            <div className="text-xs text-gray-500">
                              {[location.parent?.name, location.parent?.parent?.name]
                                .filter(Boolean)
                                .join(', ')}
                            </div>
                          )}
                        </div>
                      </div>
                    </button>
                  </li>
                ))}
              </ul>
            ) : searchTerm.length >= 2 ? (
              <div className="px-4 py-3 text-sm text-gray-500 text-center">
                No se encontraron ubicaciones
              </div>
            ) : null}
          </div>
        )}
      </div>
    </div>
  );
}

export function LocationFields({ formData, updateField }: LocationFieldsProps) {
  const handleBirthLocationChange = (locationId: number | null, locationName: string) => {
    console.log('Birth location change:', { locationId, locationName });
    // Actualizar tanto el ID como el texto
    updateField('birthLocationId', locationId);
    updateField('birthLocation', locationName);
  };

  const handleDeathLocationChange = (locationId: number | null, locationName: string) => {
    console.log('Death location change:', { locationId, locationName });
    // Actualizar tanto el ID como el texto
    updateField('deathLocationId', locationId);
    updateField('deathLocation', locationName);
  };

  return (
    <div className="space-y-6">
      {/* Lugar de Nacimiento */}
      <LocationAutocomplete
        value={formData.birthLocationId || null}
        onChange={handleBirthLocationChange}
        placeholder="Buscar ciudad, provincia o pa√≠s"
        label="Lugar de Nacimiento"
      />

      {/* Lugar de Fallecimiento */}
      <LocationAutocomplete
        value={formData.deathLocationId || null}
        onChange={handleDeathLocationChange}
        placeholder="Buscar ciudad, provincia o pa√≠s"
        disabled={false}  // Cambiar a false para permitir edici√≥n siempre
        label="Lugar de Fallecimiento"
      />
    </div>
  );
}

// ==================================================
// src/components/admin/people/PersonFormFields/NationalitiesField.tsx
// ==================================================
// src/components/admin/people/PersonFormFields/NationalitiesField.tsx

import React, { useState, useEffect } from 'react'
import { X } from 'lucide-react'
import { apiClient } from '@/services/api-client'

interface Location {
  id: number
  name: string
  slug: string
}

interface NationalitiesFieldProps {
  value: number[]
  onChange: (nationalities: number[]) => void
  disabled?: boolean
}

export default function NationalitiesField({
  value = [],
  onChange,
  disabled = false
}: NationalitiesFieldProps) {
  const [countries, setCountries] = useState<Location[]>([])
  const [searchTerm, setSearchTerm] = useState('')
  const [isSearching, setIsSearching] = useState(false)
  const [showDropdown, setShowDropdown] = useState(false)
  const [selectedCountries, setSelectedCountries] = useState<Location[]>([])

  // Cargar pa√≠ses (locations sin parent)
  useEffect(() => {
    loadCountries()
  }, [])

  // Cargar pa√≠ses seleccionados
  useEffect(() => {
    if (value.length > 0 && countries.length > 0) {
      const selected = countries.filter(c => value.includes(c.id))
      setSelectedCountries(selected)
    }
  }, [value, countries])

  const loadCountries = async () => {
    try {
      const response = await apiClient.get<Location[]>('/locations/countries')
      setCountries(response)
    } catch (error) {
      console.error('Error loading countries:', error)
    }
  }

  const filteredCountries = countries.filter(
    country => 
      !value.includes(country.id) && 
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
  )

  const handleAddCountry = (country: Location) => {
    const newValue = [...value, country.id]
    onChange(newValue)
    setSelectedCountries([...selectedCountries, country])
    setSearchTerm('')
    setShowDropdown(false)
  }

  const handleRemoveCountry = (countryId: number) => {
    const newValue = value.filter(id => id !== countryId)
    onChange(newValue)
    setSelectedCountries(selectedCountries.filter(c => c.id !== countryId))
  }

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700">
        Nacionalidades
      </label>
      
      {/* Tags de nacionalidades seleccionadas */}
      {selectedCountries.length > 0 && (
        <div className="flex flex-wrap gap-2 mb-2">
          {selectedCountries.map(country => (
            <span
              key={country.id}
              className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800"
            >
              {country.name}
              {!disabled && (
                <button
                  type="button"
                  onClick={() => handleRemoveCountry(country.id)}
                  className="ml-1 hover:text-blue-600"
                >
                  <X className="h-3 w-3" />
                </button>
              )}
            </span>
          ))}
        </div>
      )}

      {/* Campo de b√∫squeda */}
      {!disabled && (
        <div className="relative">
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => {
              setSearchTerm(e.target.value)
              setShowDropdown(true)
            }}
            onFocus={() => setShowDropdown(true)}
            placeholder="Buscar pa√≠s para agregar..."
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          />
          
          {/* Dropdown de resultados */}
          {showDropdown && searchTerm && filteredCountries.length > 0 && (
            <div className="absolute z-10 w-full mt-1 bg-white rounded-md shadow-lg max-h-48 overflow-y-auto border border-gray-200">
              {filteredCountries.slice(0, 10).map(country => (
                <button
                  key={country.id}
                  type="button"
                  onClick={() => handleAddCountry(country)}
                  className="w-full px-3 py-2 text-left hover:bg-gray-100 focus:bg-gray-100 focus:outline-none"
                >
                  {country.name}
                </button>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Click outside to close dropdown */}
      {showDropdown && (
        <div 
          className="fixed inset-0 z-0" 
          onClick={() => setShowDropdown(false)}
        />
      )}
    </div>
  )
}

// ==================================================
// src/components/admin/roles/RoleCard.tsx
// ==================================================
// src/components/admin/roles/RoleCard.tsx
'use client';

import { Edit, Trash2, Users, Star } from 'lucide-react';
import { getDepartmentLabel, getDepartmentColor } from '@/lib/roles/roleUtils';
import { Department } from '@/lib/roles/rolesTypes';

interface Role {
  id: number;
  name: string;
  department: string;
  description?: string | null;
  isMainRole: boolean;
  isActive: boolean;
  _count?: {
    crewRoles: number;
  };
}

interface RoleCardProps {
  role: Role;
  onEdit: (role: Role) => void;
  onDelete: (id: number) => void;
}

export function RoleCard({ role, onEdit, onDelete }: RoleCardProps) {
  const departmentLabel = getDepartmentLabel(role.department as Department);
  const departmentColor = getDepartmentColor(role.department as Department);
  const usageCount = role._count?.crewRoles || 0;

  return (
    <div className="bg-white rounded-lg border shadow-sm hover:shadow-md transition-shadow">
      {/* Header con departamento */}
      <div className="p-4 border-b">
        <div className="flex items-center justify-between mb-2">
          <span
            className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium text-white"
            style={{ backgroundColor: departmentColor }}
          >
            {departmentLabel}
          </span>
          <div className="flex items-center gap-1">
            {role.isMainRole && (
              <Star className="w-4 h-4 text-yellow-500 fill-current" />
            )}
            {!role.isActive && (
              <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">
                Inactivo
              </span>
            )}
          </div>
        </div>
        
        <h3 className="font-semibold text-gray-900 text-lg">
          {role.name}
        </h3>
        
        {role.description && (
          <p className="text-sm text-gray-600 mt-1 line-clamp-2">
            {role.description}
          </p>
        )}
      </div>

      {/* Stats */}
      <div className="px-4 py-3 bg-gray-50">
        <div className="flex items-center justify-between text-sm">
          <div className="flex items-center gap-1 text-gray-600">
            <Users className="w-4 h-4" />
            <span>{usageCount} uso{usageCount !== 1 ? 's' : ''}</span>
          </div>
          
          <div className="flex items-center gap-1">
            {role.isMainRole && (
              <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded font-medium">
                Principal
              </span>
            )}
            <span className={`text-xs px-2 py-1 rounded font-medium ${
              role.isActive 
                ? 'bg-green-100 text-green-800' 
                : 'bg-gray-100 text-gray-600'
            }`}>
              {role.isActive ? 'Activo' : 'Inactivo'}
            </span>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div className="p-4 pt-3">
        <div className="flex gap-2">
          <button
            onClick={() => onEdit(role)}
            className="flex-1 flex items-center justify-center gap-1 px-3 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50"
          >
            <Edit className="w-4 h-4" />
            Editar
          </button>
          <button
            onClick={() => onDelete(role.id)}
            disabled={usageCount > 0}
            title={usageCount > 0 ? 'No se puede eliminar un rol en uso' : 'Eliminar rol'}
            className="px-3 py-2 border border-gray-300 text-red-600 hover:text-red-700 hover:bg-red-50 disabled:opacity-50 disabled:cursor-not-allowed rounded-md"
          >
            <Trash2 className="w-4 h-4" />
          </button>
        </div>
        
        {usageCount > 0 && (
          <p className="text-xs text-gray-500 mt-2 text-center">
            No se puede eliminar (en uso)
          </p>
        )}
      </div>
    </div>
  );
}

// ==================================================
// src/components/admin/roles/RoleModal.tsx
// ==================================================
// src/components/admin/roles/RoleModal.tsx
'use client';

import React from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { X } from 'lucide-react';
import toast from 'react-hot-toast';
import { rolesService } from '@/services/roles.service';
import { getDepartmentOptions, getDepartmentColor, DEPARTMENTS } from '@/lib/roles/roleUtils';
import { Department } from '@/lib/roles/rolesTypes';

const roleSchema = z.object({
  name: z.string().min(2, 'El nombre debe tener al menos 2 caracteres'),
  description: z.string().optional(),
  department: z.string(),
  isMainRole: z.boolean(),
  isActive: z.boolean()
});

type RoleFormData = z.infer<typeof roleSchema>;

interface Role {
  id: number;
  name: string;
  description?: string | null;
  department: string;
  isMainRole: boolean;
  isActive: boolean;
}

interface RoleModalProps {
  isOpen: boolean;
  onClose: () => void;
  role?: Role | null;
  onSuccess: () => void;
}

export function RoleModal({
  isOpen,
  onClose,
  role,
  onSuccess
}: RoleModalProps) {
  const isEdit = !!role;
  const departmentOptions = getDepartmentOptions();

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue
  } = useForm<RoleFormData>({
    resolver: zodResolver(roleSchema),
    defaultValues: {
      name: '',
      description: '',
      department: Department.DIRECCION,
      isMainRole: false,
      isActive: true
    }
  });

  // Cargar datos al editar
  React.useEffect(() => {
    if (isEdit && role) {
      reset({
        name: role.name,
        description: role.description || '',
        department: role.department,
        isMainRole: role.isMainRole,
        isActive: role.isActive
      });
    } else {
      reset({
        name: '',
        description: '',
        department: Department.DIRECCION,
        isMainRole: false,
        isActive: true
      });
    }
  }, [role, isEdit, reset]);

  const onSubmit = async (data: RoleFormData) => {
    try {
      const formattedData = {
        ...data,
        department: data.department as Department
      };
      
      if (isEdit && role) {
        await rolesService.update(role.id, formattedData);
        toast.success('Rol actualizado correctamente');
      } else {
        await rolesService.create(formattedData);
        toast.success('Rol creado correctamente');
      }
      
      onSuccess();
    } catch (error) {
      console.error('Error saving role:', error);
      toast.error(isEdit ? 'Error al actualizar rol' : 'Error al crear rol');
    }
  };

  const handleClose = () => {
    if (!isSubmitting) {
      onClose();
    }
  };

  const selectedDepartment = watch('department');
  const selectedDepartmentColor = getDepartmentColor(selectedDepartment as Department);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-medium text-gray-900">
            {isEdit ? 'Editar Rol' : 'Nuevo Rol'}
          </h3>
          <button
            onClick={handleClose}
            disabled={isSubmitting}
            className="text-gray-400 hover:text-gray-600"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit(onSubmit)} className="p-6 space-y-4">
          {/* Nombre */}
          <div className="space-y-2">
            <label htmlFor="name" className="block text-sm font-medium text-gray-700">
              Nombre del rol <span className="text-red-500">*</span>
            </label>
            <input
              id="name"
              {...register('name')}
              placeholder="Ej: Director, Productor, Gaffer..."
              disabled={isSubmitting}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.name && (
              <p className="text-sm text-red-600">{errors.name.message}</p>
            )}
          </div>

          {/* Departamento */}
          <div className="space-y-2">
            <label htmlFor="department" className="block text-sm font-medium text-gray-700">
              Departamento <span className="text-red-500">*</span>
            </label>
            <select
              id="department"
              {...register('department')}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isSubmitting}
            >
              {departmentOptions.map(dept => (
                <option key={dept.value} value={dept.value}>
                  {dept.label}
                </option>
              ))}
            </select>
            {errors.department && (
              <p className="text-sm text-red-600">{errors.department.message}</p>
            )}
          </div>

          {/* Descripci√≥n */}
          <div className="space-y-2">
            <label htmlFor="description" className="block text-sm font-medium text-gray-700">
              Descripci√≥n
            </label>
            <textarea
              id="description"
              {...register('description')}
              placeholder="Descripci√≥n del rol (opcional)..."
              rows={3}
              disabled={isSubmitting}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.description && (
              <p className="text-sm text-red-600">{errors.description.message}</p>
            )}
          </div>

          {/* Rol principal */}
          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="isMainRole" className="block text-sm font-medium text-gray-700">
                Rol principal
              </label>
              <p className="text-sm text-gray-500">
                Marca si es un rol de liderazgo en el departamento
              </p>
            </div>
            <input
              id="isMainRole"
              type="checkbox"
              {...register('isMainRole')}
              disabled={isSubmitting}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
          </div>

          {/* Estado activo */}
          <div className="flex items-center justify-between">
            <label htmlFor="isActive" className="block text-sm font-medium text-gray-700">
              Rol activo
            </label>
            <input
              id="isActive"
              type="checkbox"
              {...register('isActive')}
              disabled={isSubmitting}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
          </div>

          {/* Preview del rol */}
          <div className="p-3 rounded-lg border bg-gray-50">
            <p className="text-sm text-gray-600 mb-2">Vista previa:</p>
            <div className="flex items-center gap-2">
              <span
                className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium text-white"
                style={{ backgroundColor: selectedDepartmentColor }}
              >
                {departmentOptions.find(d => d.value === selectedDepartment)?.label}
              </span>
              <span className="font-medium">
                {watch('name') || 'Nombre del rol'}
              </span>
              {watch('isMainRole') && (
                <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                  Principal
                </span>
              )}
            </div>
          </div>

          {/* Botones */}
          <div className="flex justify-end gap-2 pt-4">
            <button
              type="button"
              onClick={handleClose}
              disabled={isSubmitting}
              className="px-4 py-2 border border-gray-300 text-sm rounded-md hover:bg-gray-50 disabled:opacity-50"
            >
              Cancelar
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="px-4 py-2 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {isSubmitting ? 'Guardando...' : isEdit ? 'Actualizar' : 'Crear'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

// ==================================================
// src/components/admin/ScreeningVenueSelector.tsx
// ==================================================
// src/components/admin/ScreeningVenueSelector.tsx - VERSI√ìN SIMPLIFICADA
'use client'

import { useState, useEffect } from 'react'
import { X, Search, Building, Globe, Tv, Film } from 'lucide-react'

interface ScreeningVenue {
    id: number
    name: string
    type: string
    city?: string
    isActive: boolean
}

interface ScreeningVenueSelectorProps {
    selectedVenueIds: number[]  // Solo IDs
    onChange: (venueIds: number[]) => void
    releaseDate?: string  // Fecha de estreno de la pel√≠cula
}

const venueTypeIcons = {
    CINEMA: Building,
    STREAMING: Globe,
    TV_CHANNEL: Tv,
    OTHER: Film
}

const venueTypeLabels = {
    CINEMA: 'Cine',
    STREAMING: 'Streaming',
    TV_CHANNEL: 'Canal de TV',
    OTHER: 'Otro'
}

export default function ScreeningVenueSelector({
    selectedVenueIds,
    onChange,
    releaseDate
}: ScreeningVenueSelectorProps) {
    const [venues, setVenues] = useState<ScreeningVenue[]>([])
    const [filteredVenues, setFilteredVenues] = useState<ScreeningVenue[]>([])
    const [searchTerm, setSearchTerm] = useState('')
    const [showDropdown, setShowDropdown] = useState(false)
    const [loading, setLoading] = useState(false)

    // Cargar todas las pantallas activas
    useEffect(() => {
        fetchVenues()
    }, [])

    const fetchVenues = async () => {
        try {
            setLoading(true)
            const response = await fetch('/api/screening-venues?isActive=true&limit=100')
            const data = await response.json()
            setVenues(data.venues || [])
            setFilteredVenues(data.venues || [])
        } catch (error) {
            console.error('Error loading screening venues:', error)
            setVenues([])
            setFilteredVenues([])
        } finally {
            setLoading(false)
        }
    }

    // Filtrar pantallas seg√∫n b√∫squeda
    useEffect(() => {
        if (searchTerm) {
            const filtered = venues.filter(venue =>
                venue.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                venueTypeLabels[venue.type as keyof typeof venueTypeLabels]?.toLowerCase().includes(searchTerm.toLowerCase())
            )
            setFilteredVenues(filtered)
        } else {
            setFilteredVenues(venues)
        }
    }, [searchTerm, venues])

    // Agregar pantalla
    const addVenue = (venueId: number) => {
        if (!selectedVenueIds.includes(venueId)) {
            onChange([...selectedVenueIds, venueId])
        }
        setSearchTerm('')
        setShowDropdown(false)
    }

    // Eliminar pantalla
    const removeVenue = (venueId: number) => {
        onChange(selectedVenueIds.filter(id => id !== venueId))
    }

    // Obtener venue por ID
    const getVenueById = (id: number) => venues.find(v => v.id === id)

    // Agrupar pantallas por tipo
    const groupedVenues = filteredVenues.reduce((groups, venue) => {
        const type = venue.type || 'OTHER'
        if (!groups[type]) groups[type] = []
        groups[type].push(venue)
        return groups
    }, {} as Record<string, ScreeningVenue[]>)

    return (
        <div className="space-y-3">
            {/* Pantallas seleccionadas */}
            {selectedVenueIds.length > 0 && (
                <div className="flex flex-wrap gap-2">
                    {selectedVenueIds.map(venueId => {
                        const venue = getVenueById(venueId)
                        if (!venue) return null

                        const Icon = venueTypeIcons[venue.type as keyof typeof venueTypeIcons] || Film

                        return (
                            <span
                                key={venueId}
                                className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800"
                            >
                                <Icon className="w-3 h-3" />
                                {venue.name}
                                {venue.city && (
                                    <span className="text-xs opacity-75">({venue.city})</span>
                                )}
                                <button
                                    type="button"
                                    onClick={() => removeVenue(venueId)}
                                    className="ml-1 hover:text-blue-600"
                                >
                                    <X className="w-3 h-3" />
                                </button>
                            </span>
                        )
                    })}
                </div>
            )}

            {/* Buscador */}
            <div className="relative">
                <div className="relative">
                    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
                    <input
                        type="text"
                        placeholder="Buscar pantalla de estreno..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        onFocus={() => setShowDropdown(true)}
                        className="w-full pl-9 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                    />
                </div>

                {/* Dropdown */}
                {showDropdown && (
                    <div className="absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                        {loading ? (
                            <div className="p-4 text-center text-gray-500">Cargando...</div>
                        ) : Object.entries(groupedVenues).length === 0 ? (
                            <div className="p-4 text-center text-gray-500">
                                {searchTerm ? 'No se encontraron pantallas' : 'No hay pantallas disponibles'}
                            </div>
                        ) : (
                            Object.entries(groupedVenues).map(([type, venuesInType]) => (
                                <div key={type}>
                                    <div className="px-3 py-2 text-xs font-semibold text-gray-500 bg-gray-50">
                                        {venueTypeLabels[type as keyof typeof venueTypeLabels]}
                                    </div>
                                    {venuesInType.map((venue) => {
                                        const Icon = venueTypeIcons[venue.type as keyof typeof venueTypeIcons] || Film
                                        const isSelected = selectedVenueIds.includes(venue.id)

                                        return (
                                            <button
                                                key={venue.id}
                                                type="button"
                                                onClick={() => !isSelected && addVenue(venue.id)}
                                                disabled={isSelected}
                                                className={`w-full text-left px-3 py-2 hover:bg-gray-50 flex items-center gap-2 ${isSelected ? 'opacity-50 cursor-not-allowed bg-gray-50' : ''
                                                    }`}
                                            >
                                                <Icon className="w-4 h-4 text-gray-400" />
                                                <span className="text-sm text-gray-900">{venue.name}</span>
                                                {venue.city && (
                                                    <span className="text-xs text-gray-500">- {venue.city}</span>
                                                )}
                                                {isSelected && (
                                                    <span className="ml-auto text-xs text-gray-500">Ya agregada</span>
                                                )}
                                            </button>
                                        )
                                    })}
                                </div>
                            ))
                        )}
                    </div>
                )}
            </div>

            {/* Click fuera para cerrar */}
            {showDropdown && (
                <div
                    className="fixed inset-0 z-0"
                    onClick={() => setShowDropdown(false)}
                />
            )}
        </div>
    )
}

// ==================================================
// src/components/admin/shared/GenderSelectionModal.tsx
// ==================================================
// src/components/admin/shared/GenderSelectionModal.tsx

import { useState } from 'react'
import { X, User, UserCircle } from 'lucide-react'

interface GenderSelectionModalProps {
  isOpen: boolean
  firstName: string
  onSelect: (gender: 'MALE' | 'FEMALE' | 'OTHER' | null, saveToDatabase: boolean) => void
  onCancel: () => void
}

export default function GenderSelectionModal({
  isOpen,
  firstName,
  onSelect,
  onCancel
}: GenderSelectionModalProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)

  if (!isOpen) return null

  const handleSelect = async (gender: 'MALE' | 'FEMALE' | 'OTHER' | null) => {
    setIsSubmitting(true)
    
    // Solo guardar en la base de datos si es MALE o FEMALE
    const shouldSave = gender === 'MALE' || gender === 'FEMALE'
    
    onSelect(gender, shouldSave)
    setIsSubmitting(false)
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4 overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 bg-gray-50">
          <div className="flex items-center gap-2">
            <UserCircle className="h-5 w-5 text-blue-600" />
            <h3 className="text-lg font-semibold text-gray-900">
              Seleccionar g√©nero
            </h3>
          </div>
          <button
            type="button"
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600 transition-colors"
            disabled={isSubmitting}
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          <p className="text-gray-600 mb-6 text-center">
            No se pudo determinar el g√©nero autom√°ticamente para{' '}
            <span className="font-semibold text-gray-900">"{firstName}"</span>.
            <br />
            Por favor, selecciona el g√©nero correspondiente:
          </p>

          <div className="grid grid-cols-2 gap-3">
            {/* Masculino */}
            <button
              type="button"
              onClick={() => handleSelect('MALE')}
              disabled={isSubmitting}
              className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center">
                <User className="h-6 w-6 text-blue-600" />
              </div>
              <span className="font-medium text-gray-900">Masculino</span>
              <span className="text-xs text-gray-500">Se guardar√° en la base de datos</span>
            </button>

            {/* Femenino */}
            <button
              type="button"
              onClick={() => handleSelect('FEMALE')}
              disabled={isSubmitting}
              className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-pink-500 hover:bg-pink-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <div className="w-12 h-12 rounded-full bg-pink-100 flex items-center justify-center">
                <User className="h-6 w-6 text-pink-600" />
              </div>
              <span className="font-medium text-gray-900">Femenino</span>
              <span className="text-xs text-gray-500">Se guardar√° en la base de datos</span>
            </button>

            {/* Otro */}
            <button
              type="button"
              onClick={() => handleSelect('OTHER')}
              disabled={isSubmitting}
              className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <div className="w-12 h-12 rounded-full bg-purple-100 flex items-center justify-center">
                <User className="h-6 w-6 text-purple-600" />
              </div>
              <span className="font-medium text-gray-900">Otro</span>
              <span className="text-xs text-gray-500">No se guardar√° el nombre</span>
            </button>

            {/* Desconocido */}
            <button
              type="button"
              onClick={() => handleSelect(null)}
              disabled={isSubmitting}
              className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <div className="w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center">
                <User className="h-6 w-6 text-gray-400" />
              </div>
              <span className="font-medium text-gray-900">Desconocido</span>
              <span className="text-xs text-gray-500">No se guardar√° el nombre</span>
            </button>
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 bg-gray-50 border-t border-gray-200">
          <p className="text-xs text-gray-500 text-center">
            üí° Si eliges <strong>Masculino</strong> o <strong>Femenino</strong>, el nombre "{firstName}" se guardar√° 
            para futuras asignaciones autom√°ticas.
          </p>
        </div>
      </div>
    </div>
  )
}

// ==================================================
// src/components/admin/shared/NameSplitModal.tsx
// ==================================================
// src/components/admin/shared/NameSplitModal.tsx

import { useState, useEffect } from 'react'
import { X, User, UserCircle, Check } from 'lucide-react'

interface NameSplitModalProps {
  isOpen: boolean
  fullName: string
  onConfirm: (
    firstName: string,
    lastName: string,
    gender: 'MALE' | 'FEMALE' | 'OTHER' | null,
    saveToDatabase: boolean
  ) => void
  onCancel: () => void
}

/**
 * Modal para seleccionar qu√© palabras forman el nombre y el g√©nero.
 * Se muestra cuando no se reconoce ning√∫n nombre en FirstNameGender.
 */
export default function NameSplitModal({
  isOpen,
  fullName,
  onConfirm,
  onCancel
}: NameSplitModalProps) {
  const [words, setWords] = useState<string[]>([])
  const [firstNameWordCount, setFirstNameWordCount] = useState(1)
  const [selectedGender, setSelectedGender] = useState<'MALE' | 'FEMALE' | 'OTHER' | null>(null)
  const [step, setStep] = useState<'name' | 'gender'>('name')
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Parsear palabras cuando cambia fullName
  useEffect(() => {
    if (fullName) {
      // Tokenizar respetando apodos entre comillas
      const tokens = tokenizeName(fullName.trim())
      setWords(tokens)
      setFirstNameWordCount(1)
      setSelectedGender(null)
      setStep('name')
    }
  }, [fullName])

  if (!isOpen) return null

  // Calcular nombre y apellido basado en selecci√≥n
  const firstName = words.slice(0, firstNameWordCount).join(' ')
  const lastName = words.slice(firstNameWordCount).join(' ')

  const handleNameConfirm = () => {
    if (firstNameWordCount > 0 && firstNameWordCount < words.length) {
      setStep('gender')
    }
  }

  const handleGenderSelect = async (gender: 'MALE' | 'FEMALE' | 'OTHER' | null) => {
    setIsSubmitting(true)
    setSelectedGender(gender)
    
    // Solo guardar en la base de datos si es MALE o FEMALE
    const shouldSave = gender === 'MALE' || gender === 'FEMALE'
    
    onConfirm(firstName, lastName, gender, shouldSave)
    setIsSubmitting(false)
  }

  const handleBack = () => {
    setStep('name')
    setSelectedGender(null)
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4 overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 bg-gray-50">
          <div className="flex items-center gap-2">
            <UserCircle className="h-5 w-5 text-blue-600" />
            <h3 className="text-lg font-semibold text-gray-900">
              {step === 'name' ? 'Separar nombre y apellido' : 'Seleccionar g√©nero'}
            </h3>
          </div>
          <button
            type="button"
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600 transition-colors"
            disabled={isSubmitting}
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          {step === 'name' ? (
            <>
              <p className="text-gray-600 mb-4 text-center">
                No se reconoci√≥ ning√∫n nombre en{' '}
                <span className="font-semibold text-gray-900">"{fullName}"</span>.
                <br />
                Selecciona cu√°ntas palabras forman el <strong>nombre</strong>:
              </p>

              {/* Selector de palabras */}
              <div className="flex flex-wrap gap-2 justify-center mb-6">
                {words.map((word, index) => {
                  const isSelected = index < firstNameWordCount
                  return (
                    <button
                      key={index}
                      type="button"
                      onClick={() => setFirstNameWordCount(index + 1)}
                      className={`
                        px-4 py-2 rounded-lg font-medium transition-all border-2
                        ${isSelected 
                          ? 'bg-blue-100 border-blue-500 text-blue-800' 
                          : 'bg-gray-100 border-gray-300 text-gray-600 hover:border-gray-400'
                        }
                      `}
                    >
                      {word}
                      {isSelected && (
                        <Check className="inline-block ml-1 h-4 w-4" />
                      )}
                    </button>
                  )
                })}
              </div>

              {/* Slider alternativo */}
              <div className="mb-6">
                <input
                  type="range"
                  min={1}
                  max={words.length - 1}
                  value={firstNameWordCount}
                  onChange={(e) => setFirstNameWordCount(parseInt(e.target.value))}
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>1 palabra</span>
                  <span>{words.length - 1} palabras</span>
                </div>
              </div>

              {/* Preview */}
              <div className="bg-gray-50 rounded-lg p-4 mb-6">
                <div className="text-sm text-gray-500 mb-2 text-center">Vista previa:</div>
                <div className="grid grid-cols-2 gap-4 text-center">
                  <div>
                    <div className="text-xs text-gray-400 uppercase tracking-wide mb-1">Nombre</div>
                    <div className="font-semibold text-blue-700 text-lg">
                      {firstName || <span className="text-gray-400 italic">vac√≠o</span>}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-gray-400 uppercase tracking-wide mb-1">Apellido</div>
                    <div className="font-semibold text-green-700 text-lg">
                      {lastName || <span className="text-gray-400 italic">vac√≠o</span>}
                    </div>
                  </div>
                </div>
              </div>

              {/* Bot√≥n continuar */}
              <div className="flex justify-end">
                <button
                  type="button"
                  onClick={handleNameConfirm}
                  disabled={!firstName || !lastName}
                  className="px-6 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Continuar
                </button>
              </div>
            </>
          ) : (
            <>
              <p className="text-gray-600 mb-2 text-center">
                Nombre: <span className="font-semibold text-blue-700">{firstName}</span>
                <br />
                Apellido: <span className="font-semibold text-green-700">{lastName}</span>
              </p>
              <p className="text-gray-600 mb-6 text-center">
                Selecciona el g√©nero para <span className="font-semibold">"{firstName}"</span>:
              </p>

              <div className="grid grid-cols-2 gap-3">
                {/* Masculino */}
                <button
                  type="button"
                  onClick={() => handleGenderSelect('MALE')}
                  disabled={isSubmitting}
                  className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center">
                    <User className="h-6 w-6 text-blue-600" />
                  </div>
                  <span className="font-medium text-gray-900">Masculino</span>
                  <span className="text-xs text-gray-500">Se guardar√° en la base</span>
                </button>

                {/* Femenino */}
                <button
                  type="button"
                  onClick={() => handleGenderSelect('FEMALE')}
                  disabled={isSubmitting}
                  className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-pink-500 hover:bg-pink-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <div className="w-12 h-12 rounded-full bg-pink-100 flex items-center justify-center">
                    <User className="h-6 w-6 text-pink-600" />
                  </div>
                  <span className="font-medium text-gray-900">Femenino</span>
                  <span className="text-xs text-gray-500">Se guardar√° en la base</span>
                </button>

                {/* Otro */}
                <button
                  type="button"
                  onClick={() => handleGenderSelect('OTHER')}
                  disabled={isSubmitting}
                  className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <div className="w-12 h-12 rounded-full bg-purple-100 flex items-center justify-center">
                    <User className="h-6 w-6 text-purple-600" />
                  </div>
                  <span className="font-medium text-gray-900">Otro</span>
                  <span className="text-xs text-gray-500">No se guardar√°</span>
                </button>

                {/* Desconocido */}
                <button
                  type="button"
                  onClick={() => handleGenderSelect(null)}
                  disabled={isSubmitting}
                  className="flex flex-col items-center gap-2 p-4 border-2 border-gray-200 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <div className="w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center">
                    <User className="h-6 w-6 text-gray-400" />
                  </div>
                  <span className="font-medium text-gray-900">Desconocido</span>
                  <span className="text-xs text-gray-500">No se guardar√°</span>
                </button>
              </div>

              {/* Bot√≥n volver */}
              <div className="flex justify-start mt-4">
                <button
                  type="button"
                  onClick={handleBack}
                  disabled={isSubmitting}
                  className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors"
                >
                  ‚Üê Volver
                </button>
              </div>
            </>
          )}
        </div>

        {/* Footer */}
        <div className="px-6 py-4 bg-gray-50 border-t border-gray-200">
          <p className="text-xs text-gray-500 text-center">
            {step === 'name' 
              ? 'üí° Haz clic en las palabras que forman el nombre o usa el slider.'
              : `üí° Si eliges Masculino o Femenino, "${firstName}" se guardar√° para futuras asignaciones.`
            }
          </p>
        </div>
      </div>
    </div>
  )
}

/**
 * Tokeniza un nombre respetando apodos entre comillas
 */
function tokenizeName(fullName: string): string[] {
  const tokens: string[] = []
  let current = ''
  let inQuotes = false
  let quoteChar = ''
  
  for (let i = 0; i < fullName.length; i++) {
    const char = fullName[i]
    const prevChar = i > 0 ? fullName[i - 1] : ''
    
    // Detectar inicio de comillas (solo si hay espacio antes o es el inicio)
    if (!inQuotes && (char === '"' || char === "'" || char === '¬´' || char === '"')) {
      if (prevChar === ' ' || i === 0) {
        inQuotes = true
        quoteChar = char === '¬´' ? '¬ª' : (char === '"' ? '"' : char)
        current += char
        continue
      }
    }
    
    // Detectar fin de comillas
    if (inQuotes && (char === quoteChar || (quoteChar === '"' && char === '"'))) {
      current += char
      inQuotes = false
      quoteChar = ''
      continue
    }
    
    // Espacios fuera de comillas separan tokens
    if (char === ' ' && !inQuotes) {
      if (current.trim()) {
        tokens.push(current.trim())
      }
      current = ''
    } else {
      current += char
    }
  }
  
  // Agregar √∫ltima palabra
  if (current.trim()) {
    tokens.push(current.trim())
  }
  
  return tokens
}

// ==================================================
// src/components/admin/shared/PersonSearchInput.tsx
// ==================================================
// src/components/admin/shared/PersonSearchInput.tsx
import { useState, useEffect, useRef } from 'react'
import { Search, User, X, Plus, ArrowRight } from 'lucide-react'
import { useDebounce } from '@/hooks/useDebounce'
import { peopleService } from '@/services/people.service'
import toast from 'react-hot-toast'
import GenderSelectionModal from './GenderSelectionModal'
import NameSplitModal from './NameSplitModal'

interface PersonAlternativeName {
  id: number
  fullName: string
}

interface Person {
  id: number
  firstName?: string | null
  lastName?: string | null
  slug: string
  name?: string
  alternativeNames?: PersonAlternativeName[]
  matchedAlternativeName?: string | null
  matchedAlternativeNameId?: number | null
}

interface PersonSearchInputProps {
  value?: number
  alternativeNameId?: number | null
  initialPersonName?: string
  onChange: (
    personId: number, 
    personName?: string, 
    alternativeNameId?: number | null,
    alternativeName?: string | null
  ) => void
  placeholder?: string
  disabled?: boolean
  required?: boolean
  showAlternativeNames?: boolean
}

// Funci√≥n para consultar el g√©nero de un nombre
async function checkFirstNameGender(firstName: string): Promise<{
  found: boolean
  gender: 'MALE' | 'FEMALE' | 'UNISEX' | null
}> {
  try {
    const response = await fetch(`/api/first-name-gender?name=${encodeURIComponent(firstName)}`)
    if (!response.ok) {
      throw new Error('Error consultando g√©nero')
    }
    return response.json()
  } catch (error) {
    console.error('Error consultando g√©nero del nombre:', error)
    return { found: false, gender: null }
  }
}

// Funci√≥n para guardar un nombre con su g√©nero
async function saveFirstNameGender(firstName: string, gender: 'MALE' | 'FEMALE'): Promise<boolean> {
  console.log(`üíæ Intentando guardar nombre "${firstName}" con g√©nero ${gender}...`)
  
  try {
    const response = await fetch('/api/first-name-gender', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: firstName, gender })
    })
    
    const data = await response.json()
    
    if (!response.ok) {
      console.error('‚ùå Error en respuesta:', data)
      throw new Error(data.error || 'Error guardando g√©nero')
    }
    
    console.log(`‚úÖ Nombre "${firstName}" guardado exitosamente en first_name_genders:`, data)
    return true
  } catch (error) {
    console.error('‚ùå Error guardando g√©nero del nombre:', error)
    throw error
  }
}

// Detectar si una palabra es inicial (A., J., O., etc.)
function isInitial(word: string): boolean {
  return /^[A-Z√Å√â√ç√ì√ö√ë√ú]{1,2}\.$/i.test(word)
}

// Detectar si una palabra es apodo (entre comillas)
function isNickname(word: string): boolean {
  const quotePatterns = [
    /^".*"$/,
    /^'.*'$/,
    /^¬´.*¬ª$/,
    /^".*"$/,
  ]
  return quotePatterns.some(pattern => pattern.test(word))
}

// Tokenizar nombre respetando apodos
function tokenizeName(fullName: string): string[] {
  const tokens: string[] = []
  let current = ''
  let inQuotes = false
  let quoteChar = ''
  
  for (let i = 0; i < fullName.length; i++) {
    const char = fullName[i]
    const prevChar = i > 0 ? fullName[i - 1] : ''
    
    if (!inQuotes && (char === '"' || char === "'" || char === '¬´' || char === '"')) {
      if (prevChar === ' ' || i === 0) {
        inQuotes = true
        quoteChar = char === '¬´' ? '¬ª' : (char === '"' ? '"' : char)
        current += char
        continue
      }
    }
    
    if (inQuotes && (char === quoteChar || (quoteChar === '"' && char === '"'))) {
      current += char
      inQuotes = false
      quoteChar = ''
      continue
    }
    
    if (char === ' ' && !inQuotes) {
      if (current.trim()) {
        tokens.push(current.trim())
      }
      current = ''
    } else {
      current += char
    }
  }
  
  if (current.trim()) {
    tokens.push(current.trim())
  }
  
  return tokens
}

// Verificar si el nombre tiene apodos o iniciales
function hasNicknameOrInitial(fullName: string): boolean {
  const tokens = tokenizeName(fullName)
  return tokens.some(t => isNickname(t) || isInitial(t))
}

export default function PersonSearchInput({
  value,
  alternativeNameId,
  initialPersonName,
  onChange,
  placeholder = "Buscar persona...",
  disabled = false,
  required = false,
  showAlternativeNames = true
}: PersonSearchInputProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [people, setPeople] = useState<Person[]>([])
  const [loading, setLoading] = useState(false)
  const [creating, setCreating] = useState(false)
  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)
  const [selectedAlternativeNameId, setSelectedAlternativeNameId] = useState<number | null>(alternativeNameId || null)
  
  // Estado para el modal de selecci√≥n de g√©nero (caso con apodo/inicial)
  const [showGenderModal, setShowGenderModal] = useState(false)
  const [pendingPersonName, setPendingPersonName] = useState('')
  const [pendingFirstName, setPendingFirstName] = useState('')
  
  // Estado para el modal de separaci√≥n de nombre (caso sin nombres conocidos)
  const [showNameSplitModal, setShowNameSplitModal] = useState(false)
  
  const containerRef = useRef<HTMLDivElement>(null)
  const debouncedSearch = useDebounce(searchTerm, 300)

  // Cargar persona seleccionada si existe
  useEffect(() => {
    if (value && value > 0) {
      if (initialPersonName) {
        setSearchTerm(initialPersonName)
        return
      }
      
      peopleService.getById(value)
        .then((person: any) => {
          let displayName = person.name || `${person.firstName || ''} ${person.lastName || ''}`.trim()
          
          if (alternativeNameId && person.alternativeNames) {
            const altName = person.alternativeNames.find((an: any) => an.id === alternativeNameId)
            if (altName) {
              displayName = altName.fullName
            }
          }
          
          setSelectedPerson(person)
          setSearchTerm(displayName)
          setSelectedAlternativeNameId(alternativeNameId || null)
        })
        .catch(err => console.error('Error cargando persona:', err))
    }
  }, [value, alternativeNameId, initialPersonName])

  // Cerrar dropdown al hacer click fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Buscar personas
  useEffect(() => {
    const searchPeople = async () => {
      if (!debouncedSearch || debouncedSearch.length < 2) {
        setPeople([])
        return
      }

      setLoading(true)
      try {
        const response = await fetch(`/api/people?search=${encodeURIComponent(debouncedSearch)}&limit=10`)
        const result = await response.json()
        
        let peopleData: Person[] = []
        
        if (Array.isArray(result)) {
          peopleData = result
        } else if (result.data && Array.isArray(result.data)) {
          peopleData = result.data
        } else {
          peopleData = []
        }
        
        setPeople(peopleData)
      } catch (error) {
        console.error('Error buscando personas:', error)
        setPeople([])
      } finally {
        setLoading(false)
      }
    }

    if (isOpen) {
      searchPeople()
    }
  }, [debouncedSearch, isOpen])

  // Seleccionar nombre principal de la persona
  const handleSelectPerson = (person: Person, useAlternativeName?: { id: number; name: string }) => {
    let displayName: string
    let altNameId: number | null = null
    let altName: string | null = null
    
    if (useAlternativeName) {
      displayName = useAlternativeName.name
      altNameId = useAlternativeName.id
      altName = useAlternativeName.name
    } else {
      displayName = formatPersonName(person)
    }
    
    setSelectedPerson(person)
    setSearchTerm(displayName)
    setSelectedAlternativeNameId(altNameId)
    onChange(person.id, displayName, altNameId, altName)
    setIsOpen(false)
  }

  const handleClear = () => {
    setSearchTerm('')
    setSelectedPerson(null)
    setSelectedAlternativeNameId(null)
    onChange(0, '', null, null)
    setIsOpen(false)
  }

  const formatPersonName = (person: Person) => {
    if (person.name) {
      return person.name
    }
    return `${person.firstName || ''} ${person.lastName || ''}`.trim() || 'Sin nombre'
  }

  // Funci√≥n mejorada para crear nueva persona con detecci√≥n de g√©nero
  const handleCreatePerson = async () => {
    if (!debouncedSearch || debouncedSearch.length < 2) {
      toast.error('El nombre debe tener al menos 2 caracteres')
      return
    }

    const fullName = debouncedSearch.trim()
    const tokens = tokenizeName(fullName)
    const firstToken = tokens[0]

    // Guardar datos para uso posterior
    setPendingPersonName(fullName)
    setPendingFirstName(firstToken)

    setCreating(true)
    setIsOpen(false)

    try {
      // 1. Consultar el g√©nero del primer token (si no es inicial ni apodo)
      if (!isInitial(firstToken) && !isNickname(firstToken)) {
        console.log(`üîç Consultando g√©nero para "${firstToken}"...`)
        const genderResult = await checkFirstNameGender(firstToken)
        
        if (genderResult.found && genderResult.gender && genderResult.gender !== 'UNISEX') {
          // G√©nero determinado autom√°ticamente
          console.log(`‚úÖ G√©nero determinado autom√°ticamente: ${genderResult.gender}`)
          await createPersonWithGender(fullName, genderResult.gender)
          return
        }
      }
      
      // 2. Si no se encontr√≥ el g√©nero, decidir qu√© modal mostrar
      setCreating(false)
      
      if (hasNicknameOrInitial(fullName)) {
        // Tiene apodo o inicial ‚Üí el algoritmo puede separar bien, solo pedir g√©nero
        console.log(`‚ùì Nombre tiene apodo/inicial, mostrando modal de g√©nero`)
        setShowGenderModal(true)
      } else {
        // No tiene nada conocido ‚Üí mostrar modal de separaci√≥n + g√©nero
        console.log(`‚ùì No se reconoce ning√∫n nombre, mostrando modal de separaci√≥n`)
        setShowNameSplitModal(true)
      }
    } catch (error) {
      console.error('Error en proceso de creaci√≥n:', error)
      toast.error('Error al procesar la solicitud')
      setCreating(false)
    }
  }

  // Funci√≥n para crear persona con g√©nero ya determinado (separaci√≥n autom√°tica por API)
  const createPersonWithGender = async (
    fullName: string, 
    gender: 'MALE' | 'FEMALE' | 'OTHER' | null
  ) => {
    try {
      console.log(`üöÄ Creando persona "${fullName}" con g√©nero: ${gender || 'sin especificar'}`)
      
      const response = await fetch('/api/people', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          name: fullName,
          gender: gender
        })
      })

      if (!response.ok) {
        const errorData = await response.text()
        throw new Error(`Error ${response.status}: ${errorData || response.statusText}`)
      }

      const newPerson = await response.json()
      console.log('‚úÖ Persona creada:', newPerson)
      
      toast.success(`Persona "${formatPersonName(newPerson)}" creada exitosamente`)
      
      handleSelectPerson(newPerson)
      
    } catch (error) {
      console.error('‚ùå Error creando persona:', error)
      toast.error(error instanceof Error ? error.message : 'Error al crear la persona')
    } finally {
      setCreating(false)
    }
  }

  // Funci√≥n para crear persona con nombre y apellido ya separados
  const createPersonWithSplit = async (
    firstName: string,
    lastName: string,
    gender: 'MALE' | 'FEMALE' | 'OTHER' | null
  ) => {
    try {
      console.log(`üöÄ Creando persona firstName="${firstName}", lastName="${lastName}", gender=${gender}`)
      
      const response = await fetch('/api/people', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          firstName,
          lastName,
          gender
        })
      })

      if (!response.ok) {
        const errorData = await response.text()
        throw new Error(`Error ${response.status}: ${errorData || response.statusText}`)
      }

      const newPerson = await response.json()
      console.log('‚úÖ Persona creada:', newPerson)
      
      toast.success(`Persona "${formatPersonName(newPerson)}" creada exitosamente`)
      
      handleSelectPerson(newPerson)
      
    } catch (error) {
      console.error('‚ùå Error creando persona:', error)
      toast.error(error instanceof Error ? error.message : 'Error al crear la persona')
    } finally {
      setCreating(false)
    }
  }

  // Handler para cuando se selecciona g√©nero en el modal simple
  const handleGenderSelect = async (
    gender: 'MALE' | 'FEMALE' | 'OTHER' | null, 
    saveToDatabase: boolean
  ) => {
    console.log(`üéØ handleGenderSelect:`, { gender, saveToDatabase, pendingFirstName, pendingPersonName })
    
    setShowGenderModal(false)
    setCreating(true)

    try {
      // Si es MALE o FEMALE, guardar el nombre en first_name_genders
      if (saveToDatabase && (gender === 'MALE' || gender === 'FEMALE')) {
        console.log(`üíæ Guardando "${pendingFirstName}" como ${gender}...`)
        
        try {
          await saveFirstNameGender(pendingFirstName, gender)
          toast.success(`El nombre "${pendingFirstName}" se guard√≥ como ${gender === 'MALE' ? 'masculino' : 'femenino'}`)
        } catch (saveError) {
          console.error('‚ö†Ô∏è Error guardando en first_name_genders:', saveError)
          toast.error(`No se pudo guardar el nombre "${pendingFirstName}" en la base de datos de nombres`)
        }
      }

      // Crear la persona con el g√©nero seleccionado (la API separa autom√°ticamente)
      await createPersonWithGender(pendingPersonName, gender)
      
    } catch (error) {
      console.error('Error en selecci√≥n de g√©nero:', error)
      toast.error('Error al procesar la selecci√≥n')
      setCreating(false)
    }
  }

  // Handler para cuando se confirma el modal de separaci√≥n
  const handleNameSplitConfirm = async (
    firstName: string,
    lastName: string,
    gender: 'MALE' | 'FEMALE' | 'OTHER' | null,
    saveToDatabase: boolean
  ) => {
    console.log(`üéØ handleNameSplitConfirm:`, { firstName, lastName, gender, saveToDatabase })
    
    setShowNameSplitModal(false)
    setCreating(true)

    try {
      // Si es MALE o FEMALE, guardar CADA PALABRA del nombre en first_name_genders
      if (saveToDatabase && (gender === 'MALE' || gender === 'FEMALE')) {
        const firstNameWords = tokenizeName(firstName).filter(w => !isInitial(w) && !isNickname(w))
        
        console.log(`üíæ Guardando ${firstNameWords.length} nombre(s): ${firstNameWords.join(', ')}`)
        
        for (const word of firstNameWords) {
          try {
            await saveFirstNameGender(word, gender)
            console.log(`‚úÖ "${word}" guardado como ${gender}`)
          } catch (saveError) {
            // Puede fallar si ya existe, ignorar
            console.log(`‚ö†Ô∏è "${word}" ya existe o error:`, saveError)
          }
        }
        
        if (firstNameWords.length > 0) {
          toast.success(`Nombre(s) guardado(s): ${firstNameWords.join(', ')}`)
        }
      }

      // Crear la persona con firstName y lastName ya separados
      await createPersonWithSplit(firstName, lastName, gender)
      
    } catch (error) {
      console.error('Error en confirmaci√≥n de nombre:', error)
      toast.error('Error al procesar la solicitud')
      setCreating(false)
    }
  }

  // Handler para cancelar el modal de g√©nero
  const handleGenderCancel = () => {
    setShowGenderModal(false)
    setPendingPersonName('')
    setPendingFirstName('')
    setIsOpen(true)
  }

  // Handler para cancelar el modal de separaci√≥n
  const handleNameSplitCancel = () => {
    setShowNameSplitModal(false)
    setPendingPersonName('')
    setPendingFirstName('')
    setIsOpen(true)
  }

  // Renderizar un resultado de persona con sus nombres alternativos
  const renderPersonResult = (person: Person) => {
    const mainName = formatPersonName(person)
    const hasMatchedAlternative = person.matchedAlternativeName && person.matchedAlternativeNameId
    
    return (
      <div key={person.id} className="border-b border-gray-100 last:border-b-0">
        {/* Nombre principal */}
        <button
          type="button"
          onClick={() => handleSelectPerson(person)}
          className={`w-full text-left px-3 py-2 hover:bg-blue-50 flex items-center space-x-3 transition-colors ${
            hasMatchedAlternative ? 'bg-gray-50' : ''
          }`}
        >
          <User className="h-4 w-4 text-gray-400 flex-shrink-0" />
          <div className="flex-1 min-w-0">
            <div className="font-medium text-gray-900 truncate">
              {mainName}
            </div>
            <div className="text-xs text-gray-500">
              ID: {person.id} ‚Ä¢ {person.slug}
            </div>
          </div>
        </button>
        
        {/* Nombre alternativo que hizo match (si aplica) */}
        {hasMatchedAlternative && (
          <button
            type="button"
            onClick={() => handleSelectPerson(person, { 
              id: person.matchedAlternativeNameId!, 
              name: person.matchedAlternativeName! 
            })}
            className="w-full text-left px-3 py-2 pl-10 hover:bg-yellow-50 flex items-center space-x-2 transition-colors bg-yellow-25"
          >
            <ArrowRight className="h-3 w-3 text-yellow-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <div className="text-sm text-yellow-800 truncate">
                <span className="font-medium">{person.matchedAlternativeName}</span>
                <span className="text-yellow-600 ml-2">‚Üí {mainName}</span>
              </div>
              <div className="text-xs text-yellow-600">
                Nombre alternativo
              </div>
            </div>
          </button>
        )}
        
        {/* Otros nombres alternativos */}
        {showAlternativeNames && person.alternativeNames && person.alternativeNames.length > 0 && (
          <>
            {person.alternativeNames
              .filter(alt => alt.id !== person.matchedAlternativeNameId)
              .map(alt => (
                <button
                  key={alt.id}
                  type="button"
                  onClick={() => handleSelectPerson(person, { id: alt.id, name: alt.fullName })}
                  className="w-full text-left px-3 py-1.5 pl-10 hover:bg-gray-50 flex items-center space-x-2 transition-colors text-sm"
                >
                  <ArrowRight className="h-3 w-3 text-gray-400 flex-shrink-0" />
                  <div className="flex-1 min-w-0">
                    <span className="text-gray-600 truncate">
                      {alt.fullName}
                      <span className="text-gray-400 ml-2">‚Üí {mainName}</span>
                    </span>
                  </div>
                </button>
              ))
            }
          </>
        )}
      </div>
    )
  }

  return (
    <>
      <div className="relative" ref={containerRef}>
        <div className="relative">
          <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => {
              setSearchTerm(e.target.value)
              if (!isOpen) setIsOpen(true)
            }}
            onFocus={() => setIsOpen(true)}
            placeholder={placeholder}
            disabled={disabled || creating}
            required={required}
            className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
          />
          {searchTerm && !disabled && !creating && (
            <button
              type="button"
              onClick={handleClear}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <X className="h-4 w-4" />
            </button>
          )}
          {creating && (
            <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
              <div className="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            </div>
          )}
        </div>

        {/* Indicador de nombre alternativo seleccionado */}
        {selectedAlternativeNameId && selectedPerson && (
          <div className="mt-1 text-xs text-yellow-700 bg-yellow-50 px-2 py-1 rounded flex items-center">
            <ArrowRight className="h-3 w-3 mr-1" />
            <span>Usando nombre alternativo de: {formatPersonName(selectedPerson)}</span>
          </div>
        )}

        {/* Dropdown de resultados */}
        {isOpen && !disabled && !creating && (
          <div className="absolute z-50 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg max-h-80 overflow-auto">
            {loading ? (
              <div className="p-3 text-center text-gray-500">
                <div className="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div>
                <span className="ml-2">Buscando personas...</span>
              </div>
            ) : debouncedSearch.length < 2 ? (
              <div className="p-3 text-center text-gray-500">
                Escribe al menos 2 caracteres para buscar
              </div>
            ) : !Array.isArray(people) || people.length === 0 ? (
              <>
                <div className="p-3 text-center text-gray-500">
                  No se encontraron personas con "{debouncedSearch}"
                </div>
                <div className="border-t border-gray-200">
                  <button
                    type="button"
                    className="w-full text-left px-3 py-2 hover:bg-green-50 flex items-center space-x-2 text-green-700 transition-colors"
                    onClick={handleCreatePerson}
                  >
                    <Plus className="h-4 w-4" />
                    <span className="text-sm font-medium">
                      Crear nueva persona: "{debouncedSearch}"
                    </span>
                  </button>
                </div>
              </>
            ) : (
              <>
                <div className="py-1">
                  {people.map(person => renderPersonResult(person))}
                </div>
                <div className="border-t border-gray-200">
                  <button
                    type="button"
                    className="w-full text-left px-3 py-2 hover:bg-green-50 flex items-center space-x-2 text-green-700 text-sm transition-colors"
                    onClick={handleCreatePerson}
                  >
                    <Plus className="h-4 w-4" />
                    <span>¬øNo encuentras a quien buscas? Crear: "{debouncedSearch}"</span>
                  </button>
                </div>
              </>
            )}
          </div>
        )}
      </div>

      {/* Modal de selecci√≥n de g√©nero (para casos con apodo/inicial) */}
      <GenderSelectionModal
        isOpen={showGenderModal}
        firstName={pendingFirstName}
        onSelect={handleGenderSelect}
        onCancel={handleGenderCancel}
      />

      {/* Modal de separaci√≥n de nombre (para casos sin nombres conocidos) */}
      <NameSplitModal
        isOpen={showNameSplitModal}
        fullName={pendingPersonName}
        onConfirm={handleNameSplitConfirm}
        onCancel={handleNameSplitCancel}
      />
    </>
  )
}

// ==================================================
// src/components/admin/ThemeSelector.tsx
// ==================================================
// src/components/admin/ThemeSelector.tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import { X, Search, Tag } from 'lucide-react'

interface Theme {
  id: number
  name: string
  slug: string
  movieCount?: number
}

interface ThemeSelectorProps {
  availableThemes: Theme[]
  selectedThemes: number[]
  onChange: (themes: number[]) => void
  placeholder?: string
}

export function ThemeSelector({
  availableThemes,
  selectedThemes,
  onChange,
  placeholder = "Buscar theme..."
}: ThemeSelectorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const dropdownRef = useRef<HTMLDivElement>(null)

  // Cerrar dropdown al hacer clic fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const filteredThemes = availableThemes.filter(theme =>
    theme.name.toLowerCase().includes(searchTerm.toLowerCase())
  )

  const selectedThemeObjects = availableThemes.filter(theme => 
    selectedThemes.includes(theme.id)
  )

  const toggleTheme = (themeId: number) => {
    if (selectedThemes.includes(themeId)) {
      onChange(selectedThemes.filter(id => id !== themeId))
    } else {
      onChange([...selectedThemes, themeId])
    }
  }

  const removeTheme = (themeId: number) => {
    onChange(selectedThemes.filter(id => id !== themeId))
  }

  return (
    <div className="relative" ref={dropdownRef}>
      {/* Themes seleccionados */}
      {selectedThemeObjects.length > 0 && (
        <div className="flex flex-wrap gap-2 mb-2">
          {selectedThemeObjects.map(theme => (
            <span
              key={theme.id}
              className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
            >
              <Tag className="w-3 h-3" />
              {theme.name}
              <button
                type="button"
                onClick={() => removeTheme(theme.id)}
                className="ml-1 hover:text-blue-900"
              >
                <X className="w-3 h-3" />
              </button>
            </span>
          ))}
        </div>
      )}
      
      <p className="text-sm text-gray-500 mb-2">
        {selectedThemes.length} seleccionado{selectedThemes.length !== 1 ? 's' : ''}
      </p>

      {/* Input de b√∫squeda */}
      <div className="relative">
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          onFocus={() => setIsOpen(true)}
          placeholder={placeholder}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent pr-10"
        />
        <Search className="absolute right-3 top-2.5 w-5 h-5 text-gray-400 pointer-events-none" />
      </div>

      {/* Dropdown */}
      {isOpen && (
        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
          {filteredThemes.length === 0 ? (
            <p className="p-3 text-sm text-gray-500">No se encontraron themes</p>
          ) : (
            filteredThemes.map(theme => (
              <button
                key={theme.id}
                type="button"
                onClick={() => toggleTheme(theme.id)}
                className={`w-full px-3 py-2 text-left hover:bg-gray-50 flex items-center justify-between ${
                  selectedThemes.includes(theme.id) ? 'bg-blue-50' : ''
                }`}
              >
                <span className="flex items-center gap-2">
                  <Tag className="w-4 h-4 text-gray-400" />
                  {theme.name}
                  {theme.movieCount !== undefined && theme.movieCount > 0 && (
                    <span className="text-xs text-gray-500">({theme.movieCount})</span>
                  )}
                </span>
                {selectedThemes.includes(theme.id) && (
                  <span className="text-blue-600">‚úì</span>
                )}
              </button>
            ))
          )}
        </div>
      )}
    </div>
  )
}

// ==================================================
// src/components/ads/AdBanner.tsx
// ==================================================
// src/components/ads/AdBanner.tsx
'use client'

import { useEffect, useRef } from 'react'

// Variable de entorno para deshabilitar todos los ads
const ADS_ENABLED = process.env.NEXT_PUBLIC_ADS_ENABLED !== 'false'

type AdFormat = 'horizontal' | 'in-article' | 'sidebar' | 'multiplex'

interface AdBannerProps {
  slot: string
  format?: AdFormat
  className?: string
}

const AD_CLIENT = 'ca-pub-4540700730503978'

// Configuraci√≥n por formato
const FORMAT_CONFIG: Record<AdFormat, {
  dataAdFormat: string
  dataLayout?: string
  style: React.CSSProperties
  containerClass: string
}> = {
  horizontal: {
    dataAdFormat: 'auto',
    style: { display: 'block', minWidth: '300px', minHeight: '50px' },
    containerClass: 'bg-zinc-900/50 border-y border-zinc-800 py-4'
  },
  'in-article': {
    dataAdFormat: 'fluid',
    dataLayout: 'in-article',
    style: { display: 'block', textAlign: 'center' as const },
    containerClass: 'my-8'
  },
  sidebar: {
    dataAdFormat: 'auto',
    style: { display: 'block', minHeight: '250px' },
    containerClass: 'sticky top-4'
  },
  multiplex: {
    dataAdFormat: 'autorelaxed',
    style: { display: 'block' },
    containerClass: 'border-t border-zinc-800 py-8'
  }
}

export default function AdBanner({ 
  slot, 
  format = 'horizontal',
  className = ''
}: AdBannerProps) {
  // Si los ads est√°n deshabilitados globalmente, no renderizar
  if (!ADS_ENABLED) {
    return null
  }

  const adRef = useRef<HTMLModElement>(null)
  const isLoaded = useRef(false)

  useEffect(() => {
    // Evitar cargar el mismo anuncio dos veces
    if (isLoaded.current) return
    
    // Peque√±o delay para asegurar que el DOM est√© listo
    const timer = setTimeout(() => {
      try {
        if (adRef.current && adRef.current.offsetWidth > 0) {
          // @ts-ignore
          (window.adsbygoogle = window.adsbygoogle || []).push({})
          isLoaded.current = true
        }
      } catch (err) {
        console.error('AdSense error:', err)
      }
    }, 100)

    return () => clearTimeout(timer)
  }, [])

  const config = FORMAT_CONFIG[format]

  // Props del anuncio
  const adProps: Record<string, string> = {
    'data-ad-client': AD_CLIENT,
    'data-ad-slot': slot,
    'data-ad-format': config.dataAdFormat,
  }

  // Agregar layout si existe (para in-article)
  if (config.dataLayout) {
    adProps['data-ad-layout'] = config.dataLayout
  }

  // Full width responsive para horizontal
  if (format === 'horizontal') {
    adProps['data-full-width-responsive'] = 'true'
  }

  return (
    <div className={`${config.containerClass} ${className}`}>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <ins
          ref={adRef}
          className="adsbygoogle"
          style={config.style}
          {...adProps}
        />
      </div>
    </div>
  )
}

// Componentes pre-configurados para facilitar el uso
export function HeroAd() {
  return <AdBanner slot="1634150481" format="horizontal" />
}

export function InArticleAd({ slot }: { slot: string }) {
  return <AdBanner slot={slot} format="in-article" />
}

export function SidebarAd({ slot }: { slot: string }) {
  return <AdBanner slot={slot} format="sidebar" className="hidden lg:block" />
}

export function MultiplexAd({ slot }: { slot: string }) {
  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <p className="text-sm text-gray-500 mb-4">Tambi√©n te puede interesar</p>
      <AdBanner slot={slot} format="multiplex" />
    </div>
  )
}

// ==================================================
// src/components/ads/HomeBottomBanner.tsx
// ==================================================
// src/components/ads/HomeBottomBanner.tsx
'use client'

import AdBanner from './AdBanner'

export default function HomeBottomBanner() {
  return <AdBanner slot="1192731540" format="horizontal" className="my-12" />
}

// ==================================================
// src/components/ads/HomeMiddleBanner.tsx
// ==================================================
// src/components/ads/HomeMiddleBanner.tsx
'use client'

import AdBanner from './AdBanner'

export default function HomeMiddleBanner() {
  return <AdBanner slot="7063278975" format="horizontal" className="my-12" />
}

// ==================================================
// src/components/home/EfemeridesSection.tsx
// ==================================================
import Link from 'next/link';
import Image from 'next/image';
import { Efemeride, DirectorInfo } from '@/types/home.types';

interface EfemeridesSectionProps {
  efemerides: Efemeride[];
}

/**
 * Renderiza los links de directores
 * Si hay m√∫ltiples directores, los separa con comas y "y"
 */
function renderDirectorLinks(item: Efemeride) {
  const directors = item.directors;
  
  // Si hay array de directores, usarlo
  if (directors && directors.length > 0) {
    if (directors.length === 1) {
      return (
        <Link 
          href={`/persona/${directors[0].slug}`}
          className="text-white hover:text-cine-accent transition-colors"
        >
          {directors[0].name}
        </Link>
      );
    }

    if (directors.length === 2) {
      return (
        <>
          <Link 
            href={`/persona/${directors[0].slug}`}
            className="text-white hover:text-cine-accent transition-colors"
          >
            {directors[0].name}
          </Link>
          {' y '}
          <Link 
            href={`/persona/${directors[1].slug}`}
            className="text-white hover:text-cine-accent transition-colors"
          >
            {directors[1].name}
          </Link>
        </>
      );
    }

    // 3 o m√°s directores: "A, B y C"
    return (
      <>
        {directors.slice(0, -1).map((director, index) => (
          <span key={director.slug}>
            <Link 
              href={`/persona/${director.slug}`}
              className="text-white hover:text-cine-accent transition-colors"
            >
              {director.name}
            </Link>
            {index < directors.length - 2 ? ', ' : ' '}
          </span>
        ))}
        {'y '}
        <Link 
          href={`/persona/${directors[directors.length - 1].slug}`}
          className="text-white hover:text-cine-accent transition-colors"
        >
          {directors[directors.length - 1].name}
        </Link>
      </>
    );
  }
  
  // Fallback al campo director/directorSlug √∫nico (compatibilidad)
  if (item.director && item.directorSlug) {
    return (
      <Link 
        href={`/persona/${item.directorSlug}`}
        className="text-white hover:text-cine-accent transition-colors"
      >
        {item.director}
      </Link>
    );
  }
  
  // Si solo hay nombre pero no slug
  if (item.director) {
    return <span>{item.director}</span>;
  }
  
  return null;
}

export default function EfemeridesSection({ efemerides }: EfemeridesSectionProps) {
  const renderEvento = (item: Efemeride) => {
    const directorLinks = renderDirectorLinks(item);
    const hasDirector = item.directors?.length || item.director;
    
    if (item.tipo === 'pelicula') {
      switch (item.tipoEvento) {
        case 'estreno':
          return (
            <>
              se estrenaba{' '}
              {item.slug ? (
                <Link 
                  href={`/pelicula/${item.slug}`}
                  className="text-white hover:text-cine-accent transition-colors"
                >
                  {item.titulo}
                </Link>
              ) : (
                <span>{item.titulo}</span>
              )}
              {hasDirector && (
                <>
                  , de {directorLinks}
                </>
              )}
            </>
          );
        case 'inicio_rodaje':
          return (
            <>
              empezaba el rodaje de{' '}
              {item.slug ? (
                <Link 
                  href={`/pelicula/${item.slug}`}
                  className="text-white hover:text-cine-accent transition-colors"
                >
                  {item.titulo}
                </Link>
              ) : (
                <span>{item.titulo}</span>
              )}
              {hasDirector && (
                <>
                  , de {directorLinks}
                </>
              )}
            </>
          );
        case 'fin_rodaje':
          return (
            <>
              terminaba el rodaje de{' '}
              {item.slug ? (
                <Link 
                  href={`/pelicula/${item.slug}`}
                  className="text-white hover:text-cine-accent transition-colors"
                >
                  {item.titulo}
                </Link>
              ) : (
                <span>{item.titulo}</span>
              )}
              {hasDirector && (
                <>
                  , de {directorLinks}
                </>
              )}
            </>
          );
        default:
          return <span>{item.evento}</span>;
      }
    } else if (item.tipo === 'persona') {
      switch (item.tipoEvento) {
        case 'nacimiento':
          return (
            <>
              nac√≠a{' '}
              {item.slug ? (
                <Link 
                  href={`/persona/${item.slug}`}
                  className="text-white hover:text-cine-accent transition-colors"
                >
                  {item.titulo}
                </Link>
              ) : (
                <span>{item.titulo}</span>
              )}
            </>
          );
        case 'muerte':
          return (
            <>
              mor√≠a{' '}
              {item.slug ? (
                <Link 
                  href={`/persona/${item.slug}`}
                  className="text-white hover:text-cine-accent transition-colors"
                >
                  {item.titulo}
                </Link>
              ) : (
                <span>{item.titulo}</span>
              )}
            </>
          );
        default:
          return <span>{item.evento}</span>;
      }
    }
    
    // Fallback al texto original si no hay tipoEvento
    return <span>{item.evento}</span>;
  };

  const renderImage = (item: Efemeride) => {
    if (item.tipo === "pelicula") {
      // Para pel√≠culas
      if (item.posterUrl) {
        // Si tiene poster, mostrarlo
        return item.slug ? (
          <Link 
            href={`/pelicula/${item.slug}`}
            className="block w-16 h-24 rounded overflow-hidden hover:opacity-80 transition-opacity"
          >
            <img 
              src={item.posterUrl} 
              alt={item.titulo || 'Pel√≠cula'}
              className="w-full h-full object-cover"
            />
          </Link>
        ) : (
          <div className="w-16 h-24 rounded overflow-hidden">
            <img 
              src={item.posterUrl} 
              alt={item.titulo || 'Pel√≠cula'}
              className="w-full h-full object-cover"
            />
          </div>
        );
      } else {
        // Si no tiene poster, mostrar placeholder
        return item.slug ? (
          <Link 
            href={`/pelicula/${item.slug}`}
            className="w-16 h-24 rounded movie-placeholder flex items-center justify-center hover:opacity-80 transition-opacity"
          >
            <svg className="w-8 h-8 text-cine-accent opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
            </svg>
          </Link>
        ) : (
          <div className="w-16 h-24 rounded movie-placeholder flex items-center justify-center">
            <svg className="w-8 h-8 text-cine-accent opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
            </svg>
          </div>
        );
      }
    } else {
      // Para personas
      if (item.photoUrl) {
        // Si tiene foto, mostrarla
        return item.slug ? (
          <Link 
            href={`/persona/${item.slug}`}
            className="block w-24 h-24 rounded-full overflow-hidden hover:opacity-80 transition-opacity"
          >
            <img 
              src={item.photoUrl} 
              alt={item.titulo || 'Persona'}
              className="w-full h-full object-cover"
            />
          </Link>
        ) : (
          <div className="w-24 h-24 rounded-full overflow-hidden">
            <img 
              src={item.photoUrl} 
              alt={item.titulo || 'Persona'}
              className="w-full h-full object-cover"
            />
          </div>
        );
      } else {
        // Si no tiene foto, mostrar placeholder
        return item.slug ? (
          <Link 
            href={`/persona/${item.slug}`}
            className="w-24 h-24 rounded-full person-placeholder flex items-center justify-center hover:opacity-80 transition-opacity"
          >
            <svg className="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
          </Link>
        ) : (
          <div className="w-24 h-24 rounded-full person-placeholder flex items-center justify-center">
            <svg className="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
          </div>
        );
      }
    }
  };

  return (
    <section>
      <h2 className="serif-heading text-3xl mb-6 text-white">Efem√©rides</h2>
      <div className="glass-effect rounded-lg p-6">
        {efemerides.length > 0 ? (
          <div className="space-y-4">
            {efemerides.map((item) => (
              <div key={item.id} className="flex items-center space-x-4 pb-4 border-b border-gray-700 last:border-0 last:pb-0">
                <div className="w-24 h-24 flex items-center justify-center flex-shrink-0">
                  {renderImage(item)}
                </div>
                <div className="flex-1">
                  <h3 className="font-medium text-cine-accent text-lg">{item.hace}</h3>
                  <p className="text-sm mt-1 text-gray-300">
                    ... {renderEvento(item)}
                  </p>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center py-8">
            <p className="text-gray-400">No hay efem√©rides para la fecha</p>
          </div>
        )}
      </div>
      <div className="mt-6 text-center">
        <Link
          href="/efemerides"
          className="inline-block border border-cine-accent text-cine-accent hover:bg-cine-accent hover:text-white px-6 py-2 rounded-lg font-medium transition-colors"
        >
          Ver m√°s efem√©rides
        </Link>
      </div>
    </section>
  );
}

// ==================================================
// src/components/home/ErrorMessage.tsx
// ==================================================
// src/components/home/ErrorMessage.tsx
interface ErrorMessageProps {
  message: string;
  onRetry?: () => void;
}

export default function ErrorMessage({ message, onRetry }: ErrorMessageProps) {
  return (
    <div className="mb-8 p-4 bg-red-900/20 border border-red-500 rounded-lg">
      <p className="text-red-300">{message}</p>
      {onRetry ? (
        <button
          onClick={onRetry}
          className="mt-2 text-sm underline hover:no-underline text-red-300"
        >
          Reintentar
        </button>
      ) : (
        <button
          onClick={() => window.location.reload()}
          className="mt-2 text-sm underline hover:no-underline text-red-300"
        >
          Recargar p√°gina
        </button>
      )}
    </div>
  );
}

// ==================================================
// src/components/home/HeroSection.tsx
// ==================================================
// src/components/home/HeroSection.tsx
'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';

interface HeroImage {
  id: number;
  cloudinaryPublicId: string;
  type: string;
  movie: {
    id: number;
    title: string;
    year: number | null;        // A√±o de producci√≥n (prioridad)
    releaseYear: number | null; // A√±o de estreno (fallback)
    slug: string;
  } | null;
  people: Array<{
    position: number;
    person: {
      id: number;
      firstName: string | null;
      lastName: string | null;
    };
  }>;
}

interface HeroSectionProps {
  images: HeroImage[];
}

function getHeroImageUrl(publicId: string): string {
  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;
  return `https://res.cloudinary.com/${cloudName}/image/upload/w_1280,q_auto,f_auto/${publicId}`;
}

/**
 * Obtiene el a√±o a mostrar para una pel√≠cula.
 * Prioridad: a√±o de producci√≥n (year) > a√±o de estreno (releaseYear)
 * Retorna null si ambos est√°n vac√≠os o son 0
 */
function getDisplayYear(movie: HeroImage['movie']): number | null {
  if (!movie) return null;
  
  // Prioridad 1: a√±o de producci√≥n
  if (movie.year && movie.year > 0) {
    return movie.year;
  }
  
  // Prioridad 2: a√±o de estreno
  if (movie.releaseYear && movie.releaseYear > 0) {
    return movie.releaseYear;
  }
  
  // Ninguno disponible
  return null;
}

function generateCaption(image: HeroImage): string {
  const parts: string[] = [];

  if (image.people && image.people.length > 0) {
    const sortedPeople = [...image.people].sort((a, b) => a.position - b.position);
    const names = sortedPeople
      .map(ip => {
        const { firstName, lastName } = ip.person;
        return [firstName, lastName].filter(Boolean).join(' ');
      })
      .filter(Boolean);

    if (names.length === 1) {
      parts.push(names[0]);
    } else if (names.length === 2) {
      parts.push(`${names[0]} y ${names[1]}`);
    } else if (names.length > 2) {
      const lastPerson = names.pop();
      parts.push(`${names.join(', ')} y ${lastPerson}`);
    }
  }

  if (image.movie) {
    const displayYear = getDisplayYear(image.movie);
    const movieRef = displayYear 
      ? `${image.movie.title} (${displayYear})`
      : image.movie.title;
    
    if (parts.length > 0) {
      parts.push(`en ${movieRef}`);
    } else {
      parts.push(movieRef);
    }
  }

  return parts.join(' ') || '';
}

function HeroImageWithGradients({ 
  image, 
  isVisible 
}: { 
  image: HeroImage; 
  isVisible: boolean;
}) {
  return (
    <div 
      className={`absolute inset-0 flex items-center justify-center transition-opacity duration-500 ${
        isVisible ? 'opacity-100' : 'opacity-0'
      }`}
    >
      {/* Wrapper relativo a la imagen */}
      <div className="relative inline-block max-h-[500px]">
        <img
          src={getHeroImageUrl(image.cloudinaryPublicId)}
          alt={generateCaption(image)}
          className="max-w-full max-h-[500px] block"
        />
        
        {/* Gradientes relativos a la imagen */}
        <div 
          className="absolute left-0 top-0 bottom-0 w-1/4 pointer-events-none"
          style={{
            background: 'linear-gradient(90deg, #0f1419 0%, rgba(15,20,25,0.7) 40%, transparent 100%)'
          }}
        />
        
        <div 
          className="absolute right-0 top-0 bottom-0 w-1/4 pointer-events-none"
          style={{
            background: 'linear-gradient(270deg, #0f1419 0%, rgba(15,20,25,0.7) 40%, transparent 100%)'
          }}
        />
        
        <div 
          className="absolute top-0 left-0 right-0 h-1/4 pointer-events-none"
          style={{
            background: 'linear-gradient(180deg, #0f1419 0%, rgba(15,20,25,0.6) 50%, transparent 100%)'
          }}
        />
        
        <div 
          className="absolute bottom-0 left-0 right-0 h-1/3 pointer-events-none"
          style={{
            background: 'linear-gradient(0deg, #0f1419 0%, rgba(15,20,25,0.7) 50%, transparent 100%)'
          }}
        />

        <div 
          className="absolute inset-0 pointer-events-none"
          style={{
            background: 'radial-gradient(ellipse at center, transparent 40%, rgba(15,20,25,0.3) 100%)'
          }}
        />
      </div>
    </div>
  );
}

export default function HeroSection({ images }: HeroSectionProps) {
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    if (images.length <= 1) return;

    const interval = setInterval(() => {
      setCurrentIndex((prev) => (prev + 1) % images.length);
    }, 15000);

    return () => clearInterval(interval);
  }, [images.length]);

  if (!images || images.length === 0) return null;

  const currentImage = images[currentIndex];

  return (
    <div className="relative bg-cine-dark -mt-16 pt-16">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="relative">
          {/* Contenedor con fondo negro */}
          <div className="relative h-[500px] overflow-hidden rounded-lg bg-[#0f1419]">
            {images.map((image, idx) => (
              <HeroImageWithGradients
                key={image.id}
                image={image}
                isVisible={idx === currentIndex}
              />
            ))}
          </div>

          {/* Caption y controles */}
          <div className="flex items-center justify-between mt-2">
            {images.length > 1 && (
              <div className="flex gap-2">
                {images.map((_, idx) => (
                  <button
                    key={idx}
                    onClick={() => setCurrentIndex(idx)}
                    className={`h-1.5 rounded-full transition-all ${
                      idx === currentIndex 
                        ? 'bg-white w-6' 
                        : 'bg-white/40 hover:bg-white/60 w-1.5'
                    }`}
                    aria-label={`Ir a imagen ${idx + 1}`}
                  />
                ))}
              </div>
            )}

            <div className="text-right">
              {currentImage.movie ? (
                <Link 
                  href={`/pelicula/${currentImage.movie.slug}`}
                  className="text-xs text-gray-400 hover:text-white transition-colors"
                >
                  {generateCaption(currentImage)}
                </Link>
              ) : (
                <p className="text-xs text-gray-400">
                  {generateCaption(currentImage)}
                </p>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ==================================================
// src/components/home/MovieCard.tsx
// ==================================================
// src/components/home/MovieCard.tsx
import Link from 'next/link';
import { MovieWithRelease } from '@/types/home.types';
import { formatPartialDate } from '@/lib/shared/dateUtils';
import { POSTER_PLACEHOLDER } from '@/lib/movies/movieConstants';

interface MovieCardProps {
  movie: MovieWithRelease;
  showDate?: boolean;
  dateFormatter?: (movie: MovieWithRelease) => string;
  dateType?: 'past' | 'future';
}

export default function MovieCard({ 
  movie, 
  showDate, 
  dateFormatter,
  dateType = 'past' 
}: MovieCardProps) {
  
  // Funci√≥n actualizada para obtener TODOS los directores (solo roleId === 2)
  const obtenerDirectores = (movie: MovieWithRelease): string => {
    if (movie.crew && movie.crew.length > 0) {
      const directores = movie.crew.filter((c) => c.roleId === 2);
      
      if (directores.length > 0) {
        const nombresDirectores = directores
          .map((director) => {
            if (director?.person) {
              const firstName = director.person.firstName || '';
              const lastName = director.person.lastName || '';
              return `${firstName} ${lastName}`.trim();
            }
            return null;
          })
          .filter(Boolean);
        
        if (nombresDirectores.length > 0) {
          if (nombresDirectores.length > 2) {
            return `${nombresDirectores.slice(0, 2).join(', ')} y otros`;
          }
          return nombresDirectores.join(' y ');
        }
      }
    }
    return 'Director no especificado';
  };

  const obtenerGeneros = (movie: MovieWithRelease): string => {
    if (movie.genres && movie.genres.length > 0) {
      const genreNames = movie.genres
        .map((g) => g.genre?.name || g.name || null)
        .filter(Boolean);

      if (genreNames.length > 0) {
        return genreNames.slice(0, 2).join(', ');
      }
    }
    return '';
  };

  const defaultDateFormatter = (movie: MovieWithRelease): string => {
    if (!movie.releaseYear) return 'Sin fecha';
    
    const partialDate = {
      year: movie.releaseYear,
      month: movie.releaseMonth,
      day: movie.releaseDay
    };
    
    return formatPartialDate(partialDate, {
      monthFormat: 'short',
      includeDay: true,
      fallback: movie.releaseYear.toString()
    });
  };

  const formatDate = dateFormatter || defaultDateFormatter;
  
  // Color del badge seg√∫n si es fecha pasada o futura
  const badgeColor = dateType === 'future' 
    ? 'bg-blue-600/80' 
    : 'bg-black/80';

  return (
    <Link
      href={`/pelicula/${movie.slug}`}
      className="group cursor-pointer"
    >
      <div className="aspect-[2/3] rounded-lg overflow-hidden mb-2 transform group-hover:scale-105 transition-transform poster-shadow relative">
        <img
          src={movie.posterUrl || POSTER_PLACEHOLDER.cloudinaryUrl}
          alt={movie.title}
          className="w-full h-full object-cover"
          loading="lazy"
          style={{
            // Oscurecer un poco el placeholder para que se note que es gen√©rico
            filter: !movie.posterUrl ? 'brightness(0.5)' : 'none'
          }}
        />
        
        {showDate && (
          <div className={`absolute top-2 right-2 ${badgeColor} backdrop-blur-sm px-2 py-1 rounded text-xs text-white`}>
            {formatDate(movie)}
          </div>
        )}
      </div>
      <h3 className="font-medium text-sm text-white line-clamp-2">{movie.title}</h3>
      <p className="text-gray-400 text-xs">{obtenerGeneros(movie)}</p>
      <p className="text-gray-400 text-xs">Dir: {obtenerDirectores(movie)}</p>
    </Link>
  );
}

// ==================================================
// src/components/home/MoviesGrid.tsx
// ==================================================
// src/components/home/MoviesGrid.tsx
import Link from 'next/link';
import { MovieWithRelease } from '@/types/home.types';
import MovieCard from './MovieCard';
import SkeletonLoader from './SkeletonLoader';

interface MoviesGridProps {
  title: string;
  movies: MovieWithRelease[];
  loading: boolean;
  emptyMessage?: string;
  showDate?: boolean;
  dateFormatter?: (movie: MovieWithRelease) => string;
  dateType?: 'past' | 'future';
  ctaText?: string;
  ctaHref?: string;
}

export default function MoviesGrid({
  title,
  movies,
  loading,
  emptyMessage = 'No hay pel√≠culas disponibles',
  showDate = false,
  dateFormatter,
  dateType = 'past',
  ctaText,
  ctaHref
}: MoviesGridProps) {
  return (
    <section className="mb-12">
      <h2 className="serif-heading text-3xl mb-6 text-white">{title}</h2>

      {loading ? (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
          {[...Array(6)].map((_, index) => (
            <SkeletonLoader key={index} type="movie" />
          ))}
        </div>
      ) : movies.length === 0 ? (
        <div className="text-center py-8">
          <p className="text-gray-400">{emptyMessage}</p>
        </div>
      ) : (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
          {movies.map((movie) => (
            <MovieCard
              key={movie.id}
              movie={movie}
              showDate={showDate}
              dateFormatter={dateFormatter}
              dateType={dateType}
            />
          ))}
        </div>
      )}
      {ctaText && ctaHref && (
        <div className="mt-6 text-center">
          <Link
            href={ctaHref}
            className="inline-block border border-cine-accent text-cine-accent hover:bg-cine-accent hover:text-white px-6 py-2 rounded-lg font-medium transition-colors"
          >
            {ctaText}
          </Link>
        </div>
      ) }
    </section>
  );
}

// ==================================================
// src/components/home/ObituariosSection.tsx
// ==================================================
// src/components/home/ObituariosSection.tsx
import Link from 'next/link';
import { formatPartialDate, calculateYearsBetween } from '@/lib/shared/dateUtils';

interface ObituariosSectionProps {
  obituarios: any[];
  loading?: boolean; // Agregar prop loading como opcional
}

export default function ObituariosSection({ obituarios, loading = false }: ObituariosSectionProps) {
  // Si est√° cargando, mostrar skeleton
  if (loading) {
    return (
      <section>
        <h2 className="serif-heading text-3xl mb-6 text-white">Obituarios</h2>
        <div className="glass-effect rounded-lg p-6">
          <div className="space-y-4">
            {[1, 2].map((i) => (
              <div key={i} className="flex items-center space-x-4 pb-4 border-b border-gray-700 last:border-0 last:pb-0">
                <div className="w-24 h-24 rounded-full flex-shrink-0 bg-gray-800 animate-pulse" />
                <div className="flex-1 space-y-2">
                  <div className="h-5 bg-gray-800 rounded w-3/4 animate-pulse" />
                  <div className="h-4 bg-gray-800 rounded w-1/2 animate-pulse" />
                </div>
              </div>
            ))}
          </div>
        </div>
      </section>
    );
  }

  // Si no hay obituarios, no mostrar la secci√≥n
  if (!obituarios || obituarios.length === 0) {
    return null;
  }

  // Funci√≥n para calcular la edad al fallecer
  const calcularEdad = (person: any) => {
    if (!person.birthYear || !person.deathYear) {
      return null;
    }
    
    const birthDate = {
      year: person.birthYear,
      month: person.birthMonth,
      day: person.birthDay
    };
    
    const deathDate = {
      year: person.deathYear,
      month: person.deathMonth,
      day: person.deathDay
    };
    
    return calculateYearsBetween(birthDate, deathDate);
  };

  // Funci√≥n para formatear el nombre completo
  const formatearNombre = (person: any) => {
    const parts = [];
    if (person.firstName) parts.push(person.firstName);
    if (person.lastName) parts.push(person.lastName);
    return parts.join(' ') || 'Sin nombre';
  };

  return (
    <section>
      <h2 className="serif-heading text-3xl mb-6 text-white">Obituarios</h2>
      <div className="glass-effect rounded-lg p-6">
        <div className="space-y-4">
          {obituarios.map((persona) => {
            const edad = calcularEdad(persona);
            
            return (
              <Link 
                key={persona.id} 
                href={`/persona/${persona.slug}`}
                className="flex items-center space-x-4 pb-4 border-b border-gray-700 last:border-0 last:pb-0 hover:bg-gray-800/30 transition-colors rounded-lg p-2 -m-2"
              >
                <div className="w-24 h-24 rounded-full flex-shrink-0 overflow-hidden bg-gray-800">
                  {persona.photoUrl ? (
                    <img 
                      src={persona.photoUrl} 
                      alt={formatearNombre(persona)}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center">
                      <svg className="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                    </div>
                  )}
                </div>
                <div className="flex-1">
                  <h3 className="font-medium text-white text-lg hover:text-cine-accent transition-colors">
                    {formatearNombre(persona)}
                  </h3>
                  <p className="text-sm text-gray-400">
                    {persona.birthYear && persona.deathYear && (
                      <>
                        {persona.birthYear} - {persona.deathYear}
                        {edad && ` (${edad} a√±os)`}
                      </>
                    )}
                  </p>
                </div>
              </Link>
            );
          })}
        </div>
      </div>
      {
      <div className="mt-6 text-center">
        <Link
          href="/listados/obituarios"
          className="inline-block border border-cine-accent text-cine-accent hover:bg-cine-accent hover:text-white px-6 py-2 rounded-lg font-medium transition-colors"
        >
          Ver m√°s obituarios
        </Link>
      </div>
      }
    </section>
  );
}

// ==================================================
// src/components/home/PersonCard.tsx
// ==================================================
// src/components/home/PersonCard.tsx
'use client';

import Link from 'next/link';
import { PersonWithDeath } from '@/lib/obituarios/obituariosTypes';
import { formatPersonName, calculateAge, formatDeathDate } from '@/lib/obituarios/obituariosUtils';

interface PersonCardProps {
  person: PersonWithDeath;
}

export default function PersonCard({ person }: PersonCardProps) {
  const personName = formatPersonName(person);
  const photoUrl = person.photoUrl;
  
  // Calcular edad
  const age = calculateAge(
    person.birthYear,
    person.birthMonth,
    person.birthDay,
    person.deathYear,
    person.deathMonth,
    person.deathDay
  );

  // Formatear fecha de muerte (sin a√±o)
  const deathDateLabel = formatDeathDate(person.deathMonth, person.deathDay);

  return (
    <Link 
      href={`/persona/${person.slug}`}
      className="group block"
    >
      {/* Imagen rectangular con aspect ratio 3:4 */}
      <div className="relative aspect-[3/4] rounded-lg overflow-hidden bg-gray-800 mb-3 transition-transform duration-300 group-hover:scale-[1.02] shadow-lg">
        {photoUrl ? (
          <img
            src={photoUrl}
            alt={personName}
            className="w-full h-full object-cover"
          />
        ) : (
          // Placeholder SVG
          <div className="w-full h-full flex flex-col items-center justify-center">
            <svg 
              className="w-16 h-16 text-gray-600 mb-2" 
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth="1.5" 
                d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" 
              />
            </svg>
            <span className="text-xs text-gray-500">Sin foto</span>
          </div>
        )}
        
        {/* Overlay en hover */}
        <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-black/0 to-black/0 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />

        {/* Badge de fecha de muerte */}
        {deathDateLabel && (
          <div className="absolute top-2 right-2 bg-black/70 backdrop-blur-sm text-white text-xs px-2 py-1 rounded">
            {deathDateLabel}
          </div>
        )}
      </div>

      {/* Informaci√≥n */}
      <div className="space-y-1">
        <h3 className="font-medium text-white group-hover:text-orange-400 transition-colors line-clamp-2">
          {personName}
        </h3>
        
        {/* Fechas: 1950 - 2024 (74 a√±os) o ???? - 2024 si no hay a√±o de nacimiento */}
        {person.deathYear && (
          <p className="text-sm text-gray-400">
            {person.birthYear || '????'} - {person.deathYear}
            {age !== null && ` (${age} a√±os)`}
          </p>
        )}
      </div>
    </Link>
  );
}

// ==================================================
// src/components/home/RecentMoviesSection.tsx
// ==================================================
// src/components/home/RecentMoviesSection.tsx
import Link from 'next/link';
import { SimpleMovie } from '@/types/home.types';
import SkeletonLoader from './SkeletonLoader';

interface RecentMoviesSectionProps {
  movies: SimpleMovie[];
  loading: boolean;
}

export default function RecentMoviesSection({ movies, loading }: RecentMoviesSectionProps) {
  return (
    <section className="mb-12">
      <h2 className="serif-heading text-3xl mb-6 text-white">√öltimas pel√≠culas ingresadas</h2>

      {loading ? (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-3">
          {[...Array(8)].map((_, index) => (
            <div key={index} className="animate-pulse">
              <div className="aspect-[2/3] rounded bg-gray-800 mb-1"></div>
              <div className="h-3 bg-gray-800 rounded"></div>
            </div>
          ))}
        </div>
      ) : movies.length === 0 ? (
        <div className="text-center py-8">
          <p className="text-gray-400">No hay pel√≠culas recientes</p>
        </div>
      ) : (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-3">
          {movies.map((pelicula) => (
            <Link
              key={pelicula.id}
              href={`/pelicula/${pelicula.slug}`}
              className="group cursor-pointer"
            >
              <div className="aspect-[2/3] rounded overflow-hidden mb-1 transform group-hover:scale-105 transition-transform">
                {pelicula.posterUrl ? (
                  <img
                    src={pelicula.posterUrl}
                    alt={pelicula.title}
                    className="w-full h-full object-cover"
                    loading="lazy"
                    onError={(e) => {
                      e.currentTarget.style.display = 'none';
                      e.currentTarget.nextElementSibling?.classList.remove('hidden');
                    }}
                  />
                ) : null}
                <div className={`placeholder-small w-full h-full ${pelicula.posterUrl ? 'hidden' : ''}`}>
                  <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                  </svg>
                </div>
              </div>
              <h3 className="text-xs font-medium text-white truncate">{pelicula.title}</h3>
            </Link>
          ))}
        </div>
      )}
      {/*
      <div className="mt-6 text-center">
        <Link
          href="/listados/peliculas?sort=createdAt"
          className="inline-block border border-cine-accent text-cine-accent hover:bg-cine-accent hover:text-white px-6 py-2 rounded-lg font-medium transition-colors"
        >
          Ver m√°s pel√≠culas recientes
        </Link>
      </div>
      */}
    </section>
  );
}

// ==================================================
// src/components/home/RecentPeopleSection.tsx
// ==================================================
// src/components/home/RecentPeopleSection.tsx
import Link from 'next/link';
import { SimplePerson } from '@/types/home.types';
import SkeletonLoader from './SkeletonLoader';

interface RecentPeopleSectionProps {
  people: SimplePerson[];
  loading: boolean;
}

export default function RecentPeopleSection({ people, loading }: RecentPeopleSectionProps) {
  const formatPersonName = (person: SimplePerson): string => {
    const parts = [];
    if (person.firstName) parts.push(person.firstName);
    if (person.lastName) parts.push(person.lastName);
    return parts.join(' ') || 'Sin nombre';
  };

  return (
    <section className="mb-12">
      <h2 className="serif-heading text-3xl mb-6 text-white">√öltimas personas ingresadas</h2>

      {loading ? (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
          {[...Array(6)].map((_, index) => (
            <SkeletonLoader key={index} type="person" />
          ))}
        </div>
      ) : people.length === 0 ? (
        <div className="text-center py-8">
          <p className="text-gray-400">No hay personas recientes</p>
        </div>
      ) : (
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
          {people.map((persona) => (
            <Link
              key={persona.id}
              href={`/persona/${persona.slug}`}
              className="text-center cursor-pointer group"
            >
              <div className="w-24 h-24 mx-auto rounded-full overflow-hidden mb-2 person-placeholder group-hover:ring-2 group-hover:ring-cine-accent transition-all">
                {persona.photoUrl ? (
                  <img
                    src={persona.photoUrl}
                    alt={formatPersonName(persona)}
                    className="w-full h-full object-cover"
                    loading="lazy"
                    onError={(e) => {
                      e.currentTarget.style.display = 'none';
                      e.currentTarget.parentElement?.classList.add('person-placeholder');
                    }}
                  />
                ) : (
                  <svg className="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                  </svg>
                )}
              </div>
              <h3 className="text-sm font-medium text-white group-hover:text-cine-accent transition-colors">
                {formatPersonName(persona)}
              </h3>
              <p className="text-xs text-gray-400">{persona.role || 'Profesional del cine'}</p>
            </Link>
          ))}
        </div>
      )}
      <div className="mt-6 text-center">
        <Link
          href="/listados/personas"
          className="inline-block border border-cine-accent text-cine-accent hover:bg-cine-accent hover:text-white px-6 py-2 rounded-lg font-medium transition-colors"
        >
          Ver m√°s personas
        </Link>
      </div>
    </section>
  );
}

// ==================================================
// src/components/home/SkeletonLoader.tsx
// ==================================================
// src/components/home/SkeletonLoader.tsx
interface SkeletonLoaderProps {
  type: 'movie' | 'person';
}

export default function SkeletonLoader({ type }: SkeletonLoaderProps) {
  if (type === 'movie') {
    return (
      <div className="animate-pulse">
        <div className="aspect-[2/3] rounded-lg bg-gray-800 mb-2"></div>
        <div className="h-4 bg-gray-800 rounded mb-1"></div>
        <div className="h-3 bg-gray-800 rounded w-3/4"></div>
      </div>
    );
  }

  return (
    <div className="animate-pulse">
      <div className="w-24 h-24 rounded-full bg-gray-800 mx-auto mb-2"></div>
      <div className="h-4 bg-gray-800 rounded mb-1"></div>
      <div className="h-3 bg-gray-800 rounded w-3/4 mx-auto"></div>
    </div>
  );
}

// ==================================================
// src/components/layout/Footer.tsx
// ==================================================
// src/app/components/layout/Footer.tsx
import Link from 'next/link'
import { X, Mail } from 'lucide-react'
import Image from 'next/image'
import { FaInstagram, FaFacebook, FaYoutube } from 'react-icons/fa'

export default function Footer() {
  const currentYear = new Date().getFullYear()

  // const footerLinks = {
  //   explore: [
  //     { href: '/peliculas', label: 'Todas las Pel√≠culas' },
  //     { href: '/personas', label: 'Directores y Actores' },
  //     { href: '/generos', label: 'Explorar por G√©nero' },
  //     { href: '/anos', label: 'Pel√≠culas por A√±o' },
  //   ],
  //   about: [
  //     { href: '/sobre-nosotros', label: 'Sobre cinenacional.com' },
  //     { href: '/contacto', label: 'Contacto' },
  //     { href: '/api', label: 'API para Desarrolladores' },
  //     { href: '/colaborar', label: 'C√≥mo Colaborar' },
  //   ],
  //   legal: [
  //     { href: '/terminos', label: 'T√©rminos de Uso' },
  //     { href: '/privacidad', label: 'Pol√≠tica de Privacidad' },
  //     { href: '/copyright', label: 'Derechos de Autor' },
  //   ],
  // }

  return (
    <footer className="bg-zinc-900 border-t border-zinc-800 mt-auto">
      <div className="container mx-auto px-4 py-12">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          {/* Brand Section */}
          <div className="col-span-1 md:col-span-4 text-center md:text-left">
            <Link href="/" className="flex items-center space-x-2 text-white mb-4 justify-center md:justify-start">
              <Image
                src="/images/logo.svg"
                alt="cinenacional.com"
                width={180}
                height={40}
                className="h-10 sm:h-12 w-auto"
                priority
              />
            </Link>
            <p className="text-gray-400 text-sm mb-4">
              La base de datos m√°s completa del cine argentino.
            </p>
            <div className="flex space-x-4 justify-center md:justify-start">
              <a href="https://x.com/cinenacional" className="text-gray-400 hover:text-white transition-colors">
                <X className="w-5 h-5" />
              </a>
              <a href="https://instagram.com/cinenacional" className="text-gray-400 hover:text-white transition-colors">
                <FaInstagram className="w-5 h-5" />
              </a>
              <a href="mailto:info@cinenacional.com" className="text-gray-400 hover:text-white transition-colors">
                <Mail className="w-5 h-5" />
              </a>
            </div>
          </div>

          {/* Explore Links */}
          {/* <div>
            <h3 className="text-white font-semibold mb-4">Explorar</h3>
            <ul className="space-y-2">
              {footerLinks.explore.map((link) => (
                <li key={link.href}>
                  <Link href={link.href} className="text-gray-400 hover:text-white transition-colors text-sm">
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </div> */}

          {/* About Links */}
          {/* <div>
            <h3 className="text-white font-semibold mb-4">Informaci√≥n</h3>
            <ul className="space-y-2">
              {footerLinks.about.map((link) => (
                <li key={link.href}>
                  <Link href={link.href} className="text-gray-400 hover:text-white transition-colors text-sm">
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </div> */}

          {/* Legal Links */}
          {/* <div>
            <h3 className="text-white font-semibold mb-4">Legal</h3>
            <ul className="space-y-2">
              {footerLinks.legal.map((link) => (
                <li key={link.href}>
                  <Link href={link.href} className="text-gray-400 hover:text-white transition-colors text-sm">
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </div> */}
        </div>

        {/* Bottom Bar */}
        <div className="border-t border-zinc-800 mt-8 pt-8 text-center">
          <p className="text-gray-400 text-sm">
            ¬© {currentYear} cinenacional.com. Todos los derechos reservados.
          </p>
        </div>
      </div>
    </footer>
  )
}   

// ==================================================
// src/components/layout/Header.tsx
// ==================================================
'use client'

import Link from 'next/link'
import Image from 'next/image'
import SearchBar from './SearchBar'

export default function Header() {
  return (
    <>
      <header className="bg-zinc-900 border-b border-zinc-800 sticky top-0 z-40">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex items-center justify-between h-16 gap-4">
            {/* Logo y nombre */}
            <Link href="/" className="flex items-center space-x-2 flex-shrink-0">
              <Image 
                src="/images/logo.svg" 
                alt="cinenacional.com" 
                width={180} 
                height={40}
                className="h-10 sm:h-12 w-auto"
                priority
              />
            </Link>

            {/* Buscador en el centro - visible en desktop */}
            <div className="hidden md:block flex-1 max-w-2xl mx-4">
              <SearchBar />
            </div>
          </div>

          {/* Buscador m√≥vil - debajo del header principal */}
          <div className="md:hidden pb-3">
            <SearchBar />
          </div>
        </div>
      </header>

      {/* Banda de estad√≠sticas - Server Component */}
    </>
  )
}

// ==================================================
// src/components/layout/HeaderStats.tsx
// ==================================================
'use client'

import { useEffect, useState } from 'react'

interface Stats {
  peliculas: number
  personas: number
  efemerides: number
  afiches: number
  fotos: number
}

function formatNumber(num: number): string {
  return num.toLocaleString('es-AR')
}

export default function HeaderStats() {
  const [stats, setStats] = useState<Stats>({
    peliculas: 0,
    personas: 0,
    efemerides: 0,
    afiches: 0,
    fotos: 0,
  })

  useEffect(() => {
    fetch('/api/stats')
      .then(res => res.json())
      .then(data => setStats(data))
      .catch(err => console.error('Error loading stats:', err))
  }, [])

  const statsDisplay = [
    { label: 'fichas t√©cnicas', value: formatNumber(stats.peliculas) },
    { label: 'filmograf√≠as', value: formatNumber(stats.personas) },
    { label: 'efem√©rides', value: formatNumber(stats.efemerides) },
    { label: 'afiches', value: formatNumber(stats.afiches) },
    { label: 'fotos', value: formatNumber(stats.fotos) },
  ]

  return (
    <div className="bg-zinc-800/50 border-b border-zinc-700/50 relative z-30">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-2">
        <div className="flex flex-wrap items-center justify-center gap-3 sm:gap-6 text-xs sm:text-sm">
          {statsDisplay.map((stat, index) => (
            <div key={stat.label} className="flex items-baseline gap-1">
              <span className="font-semibold text-white">{stat.value}</span>
              <span className="text-zinc-400">{stat.label}</span>
              {index < statsDisplay.length - 1 && (
                <span className="hidden sm:inline ml-6 text-zinc-700">|</span>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

// ==================================================
// src/components/layout/SearchBar.tsx
// ==================================================
// src/components/layout/SearchBar.tsx

'use client'

import { useState, useRef, useEffect } from 'react'
import { Search, X, Film, User, Loader2, ArrowRight } from 'lucide-react'
import { useGlobalSearch } from '@/hooks/useGlobalSearch'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import Image from 'next/image'

/**
 * Formatea los a√±os de nacimiento y muerte de una persona.
 * - Ambos a√±os: "1936-2017"
 * - Solo nacimiento: "n. 1936"
 * - Solo muerte: "m. 2017"
 */
function formatPersonYears(birthYear?: number, deathYear?: number): string | null {
  if (birthYear && deathYear) {
    return `${birthYear}-${deathYear}`
  }
  if (birthYear) {
    return `n. ${birthYear}`
  }
  if (deathYear) {
    return `m. ${deathYear}`
  }
  return null
}

export default function SearchBar() {
    const [showResults, setShowResults] = useState(false)
    const searchRef = useRef<HTMLDivElement>(null)
    const inputRef = useRef<HTMLInputElement>(null)
    const router = useRouter()

    const {
        query,
        setQuery,
        results,
        loading,
        clearSearch,
        hasResults
    } = useGlobalSearch(2)

    // Cerrar el dropdown cuando se hace clic fuera
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
                setShowResults(false)
            }
        }

        document.addEventListener('mousedown', handleClickOutside)
        return () => document.removeEventListener('mousedown', handleClickOutside)
    }, [])

    // Mostrar resultados cuando hay query
    useEffect(() => {
        if (query.length >= 2) {
            setShowResults(true)
        } else {
            setShowResults(false)
        }
    }, [query])

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault()
        if (query.trim()) {
            router.push(`/buscar?q=${encodeURIComponent(query)}`)
            setShowResults(false)
            clearSearch()
        }
    }

    const handleResultClick = () => {
        setShowResults(false)
        clearSearch()
    }

    const handleClear = () => {
        clearSearch()
        inputRef.current?.focus()
    }

    return (
        <div ref={searchRef} className="relative flex-1 max-w-md">
            <form onSubmit={handleSubmit}>
                <div className="relative">
                    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-zinc-400 pointer-events-none" />
                    <input
                        ref={inputRef}
                        type="text"
                        value={query}
                        onChange={(e) => setQuery(e.target.value)}
                        onFocus={() => query.length >= 2 && setShowResults(true)}
                        placeholder="Buscar pel√≠culas o personas..."
                        className="w-full pl-10 pr-10 py-2 bg-zinc-800 border border-zinc-700 rounded-full text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:border-transparent focus:bg-zinc-700 transition-all"
                    />
                    {query && (
                        <button
                            type="button"
                            onClick={handleClear}
                            className="absolute right-3 top-1/2 transform -translate-y-1/2 p-1 hover:bg-zinc-700 rounded-full transition-colors"
                            aria-label="Limpiar b√∫squeda"
                        >
                            <X className="w-4 h-4 text-zinc-400 hover:text-white" />
                        </button>
                    )}
                </div>
            </form>

            {/* Dropdown de resultados */}
            {showResults && (hasResults || loading || query.length >= 2) && (
                <div className="absolute top-full left-0 right-0 mt-2 bg-zinc-900 rounded-lg shadow-2xl border border-zinc-800 z-50 overflow-hidden">
                    <div className="max-h-[70vh] overflow-y-auto">
                        {loading ? (
                            <div className="p-4 flex items-center justify-center text-zinc-400">
                                <Loader2 className="w-5 h-5 animate-spin mr-2" />
                                <span>Buscando...</span>
                            </div>
                        ) : hasResults ? (
                            <>
                                {/* Resultados de pel√≠culas */}
                                {results!.movies.length > 0 && (
                                    <div className="border-b border-zinc-800 last:border-0">
                                        <div className="px-4 py-2 bg-zinc-800/50 text-xs font-semibold text-zinc-400 uppercase tracking-wider">
                                            Pel√≠culas
                                        </div>
                                        {results!.movies.map((movie) => (
                                            <Link
                                                key={movie.id}
                                                href={`/pelicula/${movie.slug}`}
                                                onClick={handleResultClick}
                                                className="flex items-center px-4 py-3 hover:bg-zinc-800 transition-colors group"
                                            >
                                                <div className="flex-shrink-0 w-10 h-14 bg-zinc-800 rounded overflow-hidden mr-3">
                                                    {movie.posterUrl ? (
                                                        <Image
                                                            src={movie.posterUrl}
                                                            alt={movie.title}
                                                            width={40}
                                                            height={56}
                                                            className="object-cover w-full h-full"
                                                        />
                                                    ) : (
                                                        <div className="w-full h-full flex items-center justify-center bg-zinc-700">
                                                            <Film className="w-5 h-5 text-zinc-500" />
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium text-white truncate group-hover:text-zinc-300 transition-colors">
                                                        {movie.title}
                                                    </p>
                                                    <p className="text-xs text-zinc-400">
                                                        {movie.year && `${movie.year}`}
                                                        {movie.originalTitle && movie.originalTitle !== movie.title && (
                                                            <span className="ml-1">‚Ä¢ {movie.originalTitle}</span>
                                                        )}
                                                    </p>
                                                </div>
                                            </Link>
                                        ))}
                                    </div>
                                )}

                                {/* Resultados de personas */}
                                {results!.people.length > 0 && (
                                    <div className="border-b border-zinc-800 last:border-0">
                                        <div className="px-4 py-2 bg-zinc-800/50 text-xs font-semibold text-zinc-400 uppercase tracking-wider">
                                            Personas
                                        </div>
                                        {results!.people.map((person) => (
                                            <Link
                                                key={person.id}
                                                href={`/persona/${person.slug}`}
                                                onClick={handleResultClick}
                                                className="flex items-center px-4 py-3 hover:bg-zinc-800 transition-colors group"
                                            >
                                                <div className="flex-shrink-0 w-10 h-10 bg-zinc-800 rounded-full overflow-hidden mr-3">
                                                    {person.photoUrl ? (
                                                        <Image
                                                            src={person.photoUrl}
                                                            alt={person.name}
                                                            width={40}
                                                            height={40}
                                                            className="object-cover w-full h-full"
                                                        />
                                                    ) : (
                                                        <div className="w-full h-full flex items-center justify-center bg-zinc-700">
                                                            <User className="w-5 h-5 text-zinc-500" />
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium text-white truncate group-hover:text-zinc-300 transition-colors">
                                                        {person.name}
                                                    </p>
                                                    {formatPersonYears(person.birthYear, person.deathYear) && (
                                                        <p className="text-xs text-zinc-400">
                                                            {formatPersonYears(person.birthYear, person.deathYear)}
                                                        </p>
                                                    )}
                                                </div>
                                            </Link>
                                        ))}
                                    </div>
                                )}

                                {/* Link para ver todos los resultados */}
                                <Link
                                    href={`/buscar?q=${encodeURIComponent(query)}`}
                                    onClick={handleResultClick}
                                    className="flex items-center justify-between px-4 py-3 bg-zinc-800/50 hover:bg-zinc-800 text-sm text-zinc-400 hover:text-white font-medium group transition-colors"
                                >
                                    <span>Ver todos los resultados para "{query}"</span>
                                    <ArrowRight className="w-4 h-4 group-hover:translate-x-1 transition-transform" />
                                </Link>
                            </>
                        ) : query.length >= 2 ? (
                            <div className="p-8 text-center">
                                <div className="text-zinc-600 mb-2">
                                    <Search className="w-12 h-12 mx-auto" />
                                </div>
                                <p className="text-sm text-zinc-400">
                                    No se encontraron resultados para
                                </p>
                                <p className="text-sm font-medium text-white">"{query}"</p>
                            </div>
                        ) : null}
                    </div>
                </div>
            )}
        </div>
    )
}

// ==================================================
// src/components/listados/estrenos/EstrenosDecadeSelector.tsx
// ==================================================
// src/components/listados/estrenos/EstrenosDecadeSelector.tsx
'use client';

import { DecadePeriod } from '@/lib/estrenos/estrenosTypes';
import { generateDecades } from '@/lib/estrenos/estrenosUtils';
import { ChevronDown } from 'lucide-react';
import { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';

interface EstrenosDecadeSelectorProps {
  value: DecadePeriod;
  onChange: (period: DecadePeriod) => void;
}

export default function EstrenosDecadeSelector({ value, onChange }: EstrenosDecadeSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [mounted, setMounted] = useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0, width: 0 });
  
  const decades = generateDecades();
  
  useEffect(() => {
    setMounted(true);
  }, []);
  
  useEffect(() => {
    if (isOpen && buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      setDropdownPosition({
        top: rect.bottom + window.scrollY + 8,
        left: rect.left + window.scrollX,
        width: rect.width
      });
    }
  }, [isOpen]);
  
  // ‚úÖ Cerrar dropdown al hacer clic fuera - CORREGIDO
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      const target = event.target as Node;
      
      if (
        dropdownRef.current && 
        !dropdownRef.current.contains(target) &&
        buttonRef.current &&
        !buttonRef.current.contains(target)
      ) {
        setIsOpen(false);
      }
    }
    
    if (isOpen) {
      // Usar setTimeout para evitar que el evento se dispare inmediatamente
      setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside);
      }, 0);
      
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isOpen]);
  
  useEffect(() => {
    function handleScroll() {
      if (isOpen) {
        setIsOpen(false);
      }
    }
    
    if (isOpen) {
      window.addEventListener('scroll', handleScroll);
      return () => window.removeEventListener('scroll', handleScroll);
    }
  }, [isOpen]);
  
  const getCurrentLabel = () => {
    if (value === 'all') return 'Todos';
    if (value === 'upcoming') return 'Pr√≥ximos';
    
    const decade = decades.find(d => d.id === value);
    return decade ? decade.label : 'Seleccionar';
  };
  
  // ‚úÖ Mejorado con logs y event handling
  const handleSelect = (period: DecadePeriod) => {
    console.log('üéØ Selecting period:', period);
    onChange(period);
    setIsOpen(false);
  };
  
  return (
    <>
      <button
        ref={buttonRef}
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 transition-colors min-w-[140px] justify-between"
      >
        <span className="font-medium">{getCurrentLabel()}</span>
        <ChevronDown 
          className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} 
        />
      </button>
      
      {mounted && isOpen && dropdownPosition.top > 0 && createPortal(
        <div 
          ref={dropdownRef}
          className="fixed bg-gray-800 rounded-lg shadow-xl min-w-[140px] max-h-[400px] overflow-y-auto"
          style={{
            top: `${dropdownPosition.top}px`,
            left: `${dropdownPosition.left}px`,
            width: `${dropdownPosition.width}px`,
            zIndex: 9999
          }}
        >
          {/* All */}
          <button
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              handleSelect('all');
            }}
            className={`w-full text-left px-4 py-2 hover:bg-gray-700 transition-colors first:rounded-t-lg ${
              value === 'all' ? 'bg-gray-700 text-orange-400' : 'text-white'
            }`}
          >
            Todos
          </button>
          
          {/* Upcoming */}
          <button
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              handleSelect('upcoming');
            }}
            className={`w-full text-left px-4 py-2 hover:bg-gray-700 transition-colors ${
              value === 'upcoming' ? 'bg-gray-700 text-orange-400' : 'text-white'
            }`}
          >
            Pr√≥ximos
          </button>
          
          <div className="border-t border-gray-700 my-1" />
          
          {/* D√©cadas */}
          {decades.map((decade) => (
            <button
              key={decade.id}
              onMouseDown={(e) => {
                e.preventDefault();
                e.stopPropagation();
                handleSelect(decade.id);
              }}
              className={`w-full text-left px-4 py-2 hover:bg-gray-700 transition-colors last:rounded-b-lg ${
                value === decade.id ? 'bg-gray-700 text-orange-400' : 'text-white'
              }`}
            >
              {decade.label}
            </button>
          ))}
        </div>,
        document.body
      )}
    </>
  );
}

// ==================================================
// src/components/listados/estrenos/EstrenosGrid.tsx
// ==================================================
// src/components/listados/estrenos/EstrenosGrid.tsx
'use client';

import MovieCard from '@/components/home/MovieCard';
import { MovieWithRelease } from '@/types/home.types';

interface EstrenosGridProps {
  movies: MovieWithRelease[];
  isLoading: boolean;
  showDates?: boolean;
  dateType?: 'past' | 'future';
}

export default function EstrenosGrid({ 
  movies, 
  isLoading, 
  showDates = true,
  dateType = 'past'
}: EstrenosGridProps) {
  
  if (isLoading) {
    return (
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
        {Array.from({ length: 12 }).map((_, i) => (
          <div key={i} className="animate-pulse">
            <div className="aspect-[2/3] bg-gray-800 rounded-lg mb-2" />
            <div className="h-4 bg-gray-800 rounded mb-1" />
            <div className="h-3 bg-gray-800 rounded w-2/3" />
          </div>
        ))}
      </div>
    );
  }
  
  if (movies.length === 0) {
    return (
      <div className="text-center py-16">
        <div className="text-gray-400 text-lg mb-2">
          No se encontraron estrenos
        </div>
        <p className="text-gray-500 text-sm">
          Intenta seleccionar otro per√≠odo
        </p>
      </div>
    );
  }
  
  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
      {movies.map((movie) => (
        <MovieCard 
          key={movie.id} 
          movie={movie} 
          showDate={showDates}
          dateType={dateType}
        />
      ))}
    </div>
  );
}

// ==================================================
// src/components/listados/estrenos/EstrenosYearBar.tsx
// ==================================================
// src/components/listados/estrenos/EstrenosYearBar.tsx
'use client';

import { useEffect, useRef } from 'react';
import { getDecadeById, getCurrentYear, generateDecades } from '@/lib/estrenos/estrenosUtils';
import { DecadePeriod } from '@/lib/estrenos/estrenosTypes';
import { ChevronLeft, ChevronRight } from 'lucide-react';

interface EstrenosYearBarProps {
    period: DecadePeriod;
    selectedYear: number | null;
    onYearChange: (year: number | null) => void;
    onPeriodChange: (period: DecadePeriod) => void;
}

export default function EstrenosYearBar({
    period,
    selectedYear,
    onYearChange,
    onPeriodChange
}: EstrenosYearBarProps) {
    // ‚úÖ HOOKS PRIMERO - ANTES DE CUALQUIER RETURN
    const scrollContainerRef = useRef<HTMLDivElement>(null);

    // ‚úÖ Hacer scroll al a√±o seleccionado cuando cambie
    useEffect(() => {
        if (scrollContainerRef.current && period !== 'all' && period !== 'upcoming') {
            const elementId = selectedYear === null ? 'decade-button' : `year-${selectedYear}`;
            const element = document.getElementById(elementId);
            
            if (element) {
                element.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                    inline: 'center'
                });
            }
        }
    }, [selectedYear, period]);

    // AHORA S√ç LOS RETURNS CONDICIONALES
    if (period === 'all' || period === 'upcoming') {
        return null;
    }

    const decade = getDecadeById(period);
    if (!decade) {
        return null;
    }

    const currentYear = getCurrentYear();
    const allDecades = generateDecades();

    // Encontrar √≠ndice de la d√©cada actual
    const currentDecadeIndex = allDecades.findIndex(d => d.id === period);

    // Verificar si hay d√©cada anterior y posterior
    const hasPreviousDecade = currentDecadeIndex < allDecades.length - 1;
    const hasNextDecade = currentDecadeIndex > 0;

    // Obtener d√©cada anterior y posterior
    const previousDecade = hasPreviousDecade ? allDecades[currentDecadeIndex + 1] : null;
    const nextDecade = hasNextDecade ? allDecades[currentDecadeIndex - 1] : null;

    const handlePreviousDecade = () => {
        if (previousDecade) {
            onPeriodChange(previousDecade.id);
        }
    };

    const handleNextDecade = () => {
        if (nextDecade) {
            onPeriodChange(nextDecade.id);
        }
    };

    return (
        <div className="border-b border-gray-800 bg-gray-900/50 backdrop-blur-sm sticky top-0 z-40">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex items-center justify-center gap-2 py-2">
                    {/* Flecha izquierda - D√©cada anterior */}
                    <button
                        onClick={handlePreviousDecade}
                        disabled={!hasPreviousDecade}
                        className={`
                            flex-shrink-0 p-2 rounded-lg transition-all
                            ${hasPreviousDecade
                                ? 'bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white'
                                : 'bg-gray-800/50 text-gray-600 cursor-not-allowed'
                            }
                        `}
                        title={previousDecade ? `${previousDecade.label}` : 'No hay d√©cada anterior'}
                    >
                        <ChevronLeft className="w-5 h-5" />
                    </button>

                    {/* A√±os de la d√©cada */}
                    <div 
                        ref={scrollContainerRef}
                        className="flex items-center gap-2 overflow-x-auto px-2 
                            [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]"
                    >
                        {/* Bot√≥n de la d√©cada completa */}
                        <button
                            id="decade-button"
                            onClick={() => onYearChange(null as any)}
                            className={`
                                flex-shrink-0 px-4 py-2 rounded-lg font-medium transition-all
                                ${selectedYear === null
                                    ? 'bg-orange-600 text-white shadow-lg scale-105' 
                                    : 'bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white'
                                }
                            `}
                        >
                            {decade.label}
                        </button>

                        {decade.years.map((year) => {
                            const isSelected = selectedYear === year;
                            const isFuture = year > currentYear;

                            return (
                                <button
                                    key={year}
                                    id={`year-${year}`}
                                    onClick={() => onYearChange(year)}
                                    disabled={isFuture}
                                    className={`
                                        flex-shrink-0 px-4 py-2 rounded-lg font-medium transition-all
                                        ${isSelected
                                            ? 'bg-orange-600 text-white shadow-lg scale-105'
                                            : isFuture
                                                ? 'bg-gray-800 text-gray-600 cursor-not-allowed'
                                                : 'bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white'
                                        }
                                    `}
                                >
                                    {year}
                                </button>
                            );
                        })}
                    </div>

                    {/* Flecha derecha - D√©cada posterior */}
                    <button
                        onClick={handleNextDecade}
                        disabled={!hasNextDecade}
                        className={`
                            flex-shrink-0 p-2 rounded-lg transition-all
                            ${hasNextDecade
                                ? 'bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white'
                                : 'bg-gray-800/50 text-gray-600 cursor-not-allowed'
                            }
                        `}
                        title={nextDecade ? `${nextDecade.label}` : 'No hay d√©cada posterior'}
                    >
                        <ChevronRight className="w-5 h-5" />
                    </button>
                </div>
            </div>
        </div>
    );
}

// ==================================================
// src/components/listados/obituarios/ObituariosYearSelector.tsx
// ==================================================
// src/components/listados/obituarios/ObituariosYearSelector.tsx
'use client';

import { ChevronDown } from 'lucide-react';
import { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';

interface ObituariosYearSelectorProps {
  availableYears: number[];
  selectedYear: number;
  onChange: (year: number) => void;
}

export default function ObituariosYearSelector({ 
  availableYears, 
  selectedYear, 
  onChange 
}: ObituariosYearSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [mounted, setMounted] = useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0, width: 0 });
  
  useEffect(() => {
    setMounted(true);
  }, []);
  
  useEffect(() => {
    if (isOpen && buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      setDropdownPosition({
        top: rect.bottom + window.scrollY + 8,
        left: rect.left + window.scrollX,
        width: rect.width
      });
    }
  }, [isOpen]);
  
  // Cerrar dropdown al hacer clic fuera
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      const target = event.target as Node;
      
      if (
        dropdownRef.current && 
        !dropdownRef.current.contains(target) &&
        buttonRef.current &&
        !buttonRef.current.contains(target)
      ) {
        setIsOpen(false);
      }
    }
    
    if (isOpen) {
      setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside);
      }, 0);
      
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isOpen]);
  
  useEffect(() => {
    function handleScroll() {
      if (isOpen) {
        setIsOpen(false);
      }
    }
    
    if (isOpen) {
      window.addEventListener('scroll', handleScroll);
      return () => window.removeEventListener('scroll', handleScroll);
    }
  }, [isOpen]);
  
  const handleSelect = (year: number) => {
    onChange(year);
    setIsOpen(false);
  };
  
  return (
    <>
      <button
        ref={buttonRef}
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 transition-colors min-w-[140px] justify-between"
      >
        <span className="font-medium">{selectedYear}</span>
        <ChevronDown 
          className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} 
        />
      </button>
      
      {mounted && isOpen && dropdownPosition.top > 0 && createPortal(
        <div 
          ref={dropdownRef}
          className="fixed bg-gray-800 rounded-lg shadow-xl min-w-[140px] max-h-[400px] overflow-y-auto"
          style={{
            top: `${dropdownPosition.top}px`,
            left: `${dropdownPosition.left}px`,
            width: `${dropdownPosition.width}px`,
            zIndex: 9999
          }}
        >
          {availableYears.map((year) => (
            <button
              key={year}
              onMouseDown={(e) => {
                e.preventDefault();
                e.stopPropagation();
                handleSelect(year);
              }}
              className={`w-full text-left px-4 py-2 hover:bg-gray-700 transition-colors first:rounded-t-lg last:rounded-b-lg ${
                year === selectedYear ? 'bg-gray-700 text-orange-400' : 'text-white'
              }`}
            >
              {year}
            </button>
          ))}
        </div>,
        document.body
      )}
    </>
  );
}

// ==================================================
// src/components/movies/CastSection.tsx
// ==================================================
// src/components/movies/CastSection.tsx

'use client';

import { useState } from 'react';
import Link from 'next/link';

interface CastMember {
  name: string;
  character: string;
  image?: string;
  personId?: number;
  personSlug?: string;
  isPrincipal?: boolean;
  billingOrder?: number;
  creditedAs?: string | null;  // üÜï Nombre alternativo usado en cr√©ditos
  gender?: string | null;       // üÜï G√©nero para "Acreditado/a"
}

interface CastSectionProps {
  mainCast: CastMember[];
  fullCast?: CastMember[];
}

// üÜï Helper para obtener el texto "Acreditado/a" seg√∫n g√©nero
function getCreditedLabel(gender?: string | null): string {
  // FEMALE ‚Üí "Acreditada", otros casos ‚Üí "Acreditado"
  return gender === 'FEMALE' ? 'Acreditada' : 'Acreditado';
}

export function CastSection({ mainCast, fullCast = [] }: CastSectionProps) {
  const [showFullCast, setShowFullCast] = useState(false);

  // Si no hay cast, no mostrar la secci√≥n en absoluto
  if (mainCast.length === 0 && fullCast.length === 0) {
    return null;
  }

  return (
    <div className="mb-8">
      <h3 className="text-lg font-medium mb-4 text-cine-accent">
        {mainCast.length > 0 ? 'Reparto Principal' : 'Reparto'}
      </h3>
      
      {/* Main Cast */}
      {mainCast.length > 0 && (
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
          {mainCast.map((actor, index) => (
            <div key={`main-${index}`} className="text-center">
              {actor.personSlug ? (
                <Link href={`/persona/${actor.personSlug}`} className="block group">
                  <div className="w-20 h-20 rounded-full person-placeholder mx-auto mb-2 group-hover:ring-2 group-hover:ring-cine-accent transition-all">
                    {actor.image ? (
                      <img 
                        src={actor.image} 
                        alt={actor.name}
                        className="w-full h-full object-cover rounded-full"
                      />
                    ) : (
                      <svg className="w-8 h-8 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                      </svg>
                    )}
                  </div>
                  <p className="font-medium text-white group-hover:text-cine-accent transition-colors">{actor.name}</p>
                </Link>
              ) : (
                <>
                  <div className="w-20 h-20 rounded-full person-placeholder mx-auto mb-2">
                    {actor.image ? (
                      <img 
                        src={actor.image} 
                        alt={actor.name}
                        className="w-full h-full object-cover rounded-full"
                      />
                    ) : (
                      <svg className="w-8 h-8 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                      </svg>
                    )}
                  </div>
                  <p className="font-medium text-white">{actor.name}</p>
                </>
              )}
              {actor.character && (
                <p className="text-sm text-gray-400">{actor.character}</p>
              )}
              {/* üÜï Mostrar "Acreditado/a como" si hay nombre alternativo */}
              {actor.creditedAs && (
                <p className="text-xs text-gray-500 italic">
                  {getCreditedLabel(actor.gender)} como: {actor.creditedAs}
                </p>
              )}
            </div>
          ))}
        </div>
      )}
      
      {/* Full Cast (if provided) */}
      {fullCast.length > 0 && (
        <>
          {showFullCast && (
            <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4 mt-6 pt-6 border-t border-gray-700 animate-fade-in">
              <div className="col-span-full mb-2">
                <h4 className="text-sm font-medium text-gray-400 uppercase tracking-wider">Reparto Completo</h4>
              </div>
              {fullCast.map((actor, index) => (
                <div key={`full-${index}`} className="text-center">
                  {actor.personSlug ? (
                    <Link href={`/persona/${actor.personSlug}`} className="block group">
                      <div className="w-16 h-16 rounded-full person-placeholder mx-auto mb-2 group-hover:ring-2 group-hover:ring-cine-accent transition-all">
                        {actor.image ? (
                          <img 
                            src={actor.image} 
                            alt={actor.name}
                            className="w-full h-full object-cover rounded-full"
                          />
                        ) : (
                          <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                          </svg>
                        )}
                      </div>
                      <p className="font-medium text-white text-sm group-hover:text-cine-accent transition-colors">{actor.name}</p>
                    </Link>
                  ) : (
                    <>
                      <div className="w-16 h-16 rounded-full person-placeholder mx-auto mb-2">
                        {actor.image ? (
                          <img 
                            src={actor.image} 
                            alt={actor.name}
                            className="w-full h-full object-cover rounded-full"
                          />
                        ) : (
                          <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                          </svg>
                        )}
                      </div>
                      <p className="font-medium text-white text-sm">{actor.name}</p>
                    </>
                  )}
                  {actor.character && (
                    <p className="text-xs text-gray-400">{actor.character}</p>
                  )}
                  {/* üÜï Mostrar "Acreditado/a como" si hay nombre alternativo */}
                  {actor.creditedAs && (
                    <p className="text-xs text-gray-500 italic">
                      {getCreditedLabel(actor.gender)} como: {actor.creditedAs}
                    </p>
                  )}
                </div>
              ))}
            </div>
          )}
          
          <div className="mt-6">
            <button 
              onClick={() => setShowFullCast(!showFullCast)}
              className="text-cine-accent hover:text-blue-300 font-medium transition-colors flex items-center space-x-2"
            >
              <span>{showFullCast ? 'Ocultar reparto completo' : `Ver reparto completo (${fullCast.length} m√°s)`}</span>
              <svg 
                className={`w-4 h-4 transition-transform duration-200 ${showFullCast ? 'rotate-180' : ''}`} 
                fill="none" stroke="currentColor" viewBox="0 0 24 24"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </button>
          </div>
        </>
      )}
    </div>
  );
}

// ==================================================
// src/components/movies/CloudinaryImage.tsx
// ==================================================
// src/components/movies/CloudinaryImage.tsx
'use client'

import { CldImage } from 'next-cloudinary'
import { useState } from 'react'

interface CloudinaryImageProps {
  src: string
  alt: string
  width: number
  height: number
  priority?: boolean
  className?: string
}

export function CloudinaryImage({
  src,
  alt,
  width,
  height,
  priority = false,
  className
}: CloudinaryImageProps) {
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState(false)

  // Si no hay src, mostrar placeholder
  if (!src) {
    return (
      <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
        <span className="text-gray-400">Sin imagen</span>
      </div>
    )
  }

  // Si hay error, mostrar placeholder
  if (error) {
    return (
      <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
        <span className="text-gray-400">Error al cargar imagen</span>
      </div>
    )
  }

  // Para im√°genes que no son de Cloudinary, usar img normal
  if (!src.includes('cloudinary')) {
    return (
      <img
        src={src}
        alt={alt}
        width={width}
        height={height}
        className={className}
        loading={priority ? 'eager' : 'lazy'}
        onError={() => setError(true)}
      />
    )
  }

  // Extraer public_id de la URL de Cloudinary
  const publicId = src.split('/upload/')[1]?.split('.')[0] || src

  return (
    <div className="relative">
      {isLoading && (
        <div className={`absolute inset-0 bg-gray-200 animate-pulse ${className}`} />
      )}
      <CldImage
        width={width}
        height={height}
        src={publicId}
        alt={alt}
        loading={priority ? 'eager' : 'lazy'}
        className={className}
        crop="fill"
        gravity="auto"
        format="auto"
        quality="auto"
        onLoad={() => setIsLoading(false)}
        onError={() => setError(true)}
      />
    </div>
  )
}

// ==================================================
// src/components/movies/CrewSection.tsx
// ==================================================
// src/components/movies/CrewSection.tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';

interface CrewMember {
  name: string;
  role: string;
  personSlug?: string;
  creditedAs?: string | null;  // üÜï Nombre alternativo usado en cr√©ditos
  gender?: string | null;       // üÜï G√©nero para "Acreditado/a"
}

interface CrewDepartment {
  [department: string]: CrewMember[];
}

interface CrewSectionProps {
  basicCrew: CrewDepartment;
  fullCrew?: CrewDepartment;
}

// üÜï Helper para obtener el texto "Acreditado/a" seg√∫n g√©nero
function getCreditedLabel(gender?: string | null): string {
  // FEMALE ‚Üí "Acreditada", otros casos ‚Üí "Acreditado"
  return gender === 'FEMALE' ? 'Acreditada' : 'Acreditado';
}

export function CrewSection({ basicCrew, fullCrew }: CrewSectionProps) {
  const [showFullCrew, setShowFullCrew] = useState(false);

  const renderCrewMember = (member: CrewMember, index: number, showRole: boolean = false) => {
    // Crear el elemento del nombre con o sin enlace
    const nameElement = member.personSlug ? (
      <Link 
        href={`/persona/${member.personSlug}`} 
        className="text-white hover:text-cine-accent transition-colors"
      >
        {member.name}
      </Link>
    ) : (
      <span className="text-white">{member.name}</span>
    );

    // üÜï Elemento para "Acreditado/a como" si existe
    const creditedAsElement = member.creditedAs ? (
      <span className="text-gray-500 text-xs italic ml-1">
        ({getCreditedLabel(member.gender)} como: {member.creditedAs})
      </span>
    ) : null;

    if (showRole) {
      return (
        <div key={index} className="flex justify-between items-start">
          <div className="flex flex-wrap items-baseline">
            {nameElement}
            {creditedAsElement}
          </div>
          <span className="text-gray-400 text-xs ml-2 flex-shrink-0">{member.role}</span>
        </div>
      );
    }
    
    // Sin roles
    return (
      <div key={index} className="flex flex-wrap items-baseline">
        {nameElement}
        {creditedAsElement}
      </div>
    );
  };

  const renderDepartment = (title: string, members: CrewMember[], showRoles: boolean = false) => (
    <div>
      <h4 className="text-gray-400 font-medium mb-2">{title}</h4>
      <div className="ml-4 space-y-1">
        {members.map((member, index) => renderCrewMember(member, index, showRoles))}
      </div>
    </div>
  );

  return (
    <div>
      <h3 className="text-lg font-medium mb-4 text-cine-accent">Equipo T√©cnico</h3>
      
      {!showFullCrew ? (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 text-sm">
          <div className="space-y-4">
            {Object.entries(basicCrew).slice(0, Math.ceil(Object.keys(basicCrew).length / 2)).map(([dept, members]) => (
              <div key={dept}>
                {renderDepartment(dept, members, false)} {/* false = no mostrar roles */}
              </div>
            ))}
          </div>
          <div className="space-y-4">
            {Object.entries(basicCrew).slice(Math.ceil(Object.keys(basicCrew).length / 2)).map(([dept, members]) => (
              <div key={dept}>
                {renderDepartment(dept, members, false)} {/* false = no mostrar roles */}
              </div>
            ))}
          </div>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 text-sm animate-fade-in">
          <div className="space-y-4">
            {fullCrew && Object.entries(fullCrew).slice(0, Math.ceil(Object.keys(fullCrew).length / 2)).map(([dept, members]) => (
              <div key={dept}>
                {renderDepartment(dept, members, true)} {/* true = mostrar roles */}
              </div>
            ))}
          </div>
          <div className="space-y-4">
            {fullCrew && Object.entries(fullCrew).slice(Math.ceil(Object.keys(fullCrew).length / 2)).map(([dept, members]) => (
              <div key={dept}>
                {renderDepartment(dept, members, true)} {/* true = mostrar roles */}
              </div>
            ))}
          </div>
        </div>
      )}
      
      {fullCrew && Object.keys(fullCrew).length > 0 && (
        <div className="mt-6">
          <button 
            onClick={() => setShowFullCrew(!showFullCrew)}
            className="text-cine-accent hover:text-blue-300 font-medium transition-colors flex items-center space-x-2"
          >
            <span>{showFullCrew ? 'Ocultar equipo t√©cnico completo' : 'Ver equipo t√©cnico completo'}</span>
            <svg 
              className={`w-4 h-4 transition-transform duration-200 ${showFullCrew ? 'rotate-180' : ''}`} 
              fill="none" stroke="currentColor" viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </button>
        </div>
      )}
    </div>
  );
}

// ==================================================
// src/components/movies/ImageGallery.tsx
// ==================================================
// src/components/movies/ImageGallery.tsx
'use client';

import { useState, useEffect } from 'react';
import { generateImageCaption } from '@/lib/images/imageUtils';

// Tipo para las im√°genes de galer√≠a
interface GalleryImage {
  id: number;
  url: string;
  cloudinaryPublicId: string;
  type: string;
  eventName?: string | null;
  people: Array<{
    personId: number;
    position: number;
    person: {
      id: number;
      firstName?: string | null;
      lastName?: string | null;
    }
  }>;
  movie?: {
    id: number;
    title: string;
    releaseYear?: number | null;
  } | null;
}

interface ImageGalleryProps {
  images: GalleryImage[];
  movieTitle: string;
}

export function ImageGallery({ images, movieTitle }: ImageGalleryProps) {
  const [currentSlide, setCurrentSlide] = useState(0);
  const [lightboxImage, setLightboxImage] = useState<{ src: string, caption: string, index: number } | null>(null);

  // Generar caption para una imagen
  const getCaption = (image: GalleryImage): string => {
    // Convertir a formato ImageWithRelations para generateImageCaption
    const imageForCaption = {
      id: image.id,
      cloudinaryPublicId: image.cloudinaryPublicId,
      type: image.type as any,
      eventName: image.eventName,
      people: image.people,
      movie: image.movie,
      createdAt: '',
      updatedAt: ''
    };
    return generateImageCaption(imageForCaption);
  };

  // Slider functions
  const nextSlide = () => {
    const totalSlides = images.length;
    const visibleSlides = 3;
    setCurrentSlide(prev => {
      const next = prev + 1;
      return next > Math.max(0, totalSlides - visibleSlides) ? 0 : next;
    });
  };

  const prevSlide = () => {
    const totalSlides = images.length;
    const visibleSlides = 3;
    setCurrentSlide(prev => {
      const next = prev - 1;
      return next < 0 ? Math.max(0, totalSlides - visibleSlides) : next;
    });
  };

  const openLightbox = (image: GalleryImage, index: number) => {
    const caption = getCaption(image);
    setLightboxImage({ src: image.url, caption, index });
    document.body.style.overflow = 'hidden';
  };

  const closeLightbox = () => {
    setLightboxImage(null);
    document.body.style.overflow = 'auto';
  };

  // Navegaci√≥n en el lightbox
  const navigateLightbox = (direction: 'prev' | 'next') => {
    if (!lightboxImage || images.length === 0) return;

    let newIndex: number;
    if (direction === 'next') {
      newIndex = (lightboxImage.index + 1) % images.length;
    } else {
      newIndex = lightboxImage.index === 0 ? images.length - 1 : lightboxImage.index - 1;
    }

    const newImage = images[newIndex];
    const caption = getCaption(newImage);
    
    setLightboxImage({
      src: newImage.url,
      caption,
      index: newIndex
    });
  };

  // Cerrar lightbox con Escape y navegar con flechas
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!lightboxImage) return;

      switch (e.key) {
        case 'Escape':
          closeLightbox();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          navigateLightbox('prev');
          break;
        case 'ArrowRight':
          e.preventDefault();
          navigateLightbox('next');
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [lightboxImage, images]);

  return (
    <>
      <div className="relative">
        <div className="overflow-hidden">
          <div
            className="flex transition-transform duration-500 ease-in-out"
            style={{ transform: `translateX(-${currentSlide * (100 / 3)}%)` }}
          >
            {images.length > 0 ? (
              images.map((image, index) => {
                const caption = getCaption(image);
                return (
                  <div key={image.id} className="flex-shrink-0 w-1/3 px-2">
                    <div
                      className="group cursor-pointer relative overflow-hidden rounded-lg aspect-video bg-cine-gray"
                      onClick={() => openLightbox(image, index)}
                    >
                      <img
                        src={image.url}
                        alt={caption}
                        className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                        loading="lazy"
                        onError={(e) => {
                          (e.target as HTMLImageElement).src = 'https://images.unsplash.com/photo-1518998053901-5348d3961a04?w=800&fit=crop&auto=format';
                        }}
                      />
                      <div className="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors duration-300"></div>
                      <div className="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <p className="text-white text-sm font-medium line-clamp-2">{caption}</p>
                      </div>
                    </div>
                  </div>
                );
              })
            ) : (
              <div className="flex-shrink-0 w-1/3 px-2">
                <div className="group cursor-pointer relative overflow-hidden rounded-lg aspect-video bg-cine-gray">
                  <div className="w-full h-full flex items-center justify-center">
                    <div className="text-center">
                      <svg className="w-8 h-8 text-cine-accent mx-auto mb-2 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                      </svg>
                      <p className="text-sm text-gray-400">Cargando im√°genes...</p>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Navigation arrows */}
        {images.length > 3 && (
          <>
            <button
              onClick={prevSlide}
              className="absolute left-0 top-1/2 -translate-y-1/2 -translate-x-4 bg-cine-gray/90 hover:bg-cine-accent text-white p-3 rounded-full transition-colors duration-300 backdrop-blur-sm"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path>
              </svg>
            </button>
            <button
              onClick={nextSlide}
              className="absolute right-0 top-1/2 -translate-y-1/2 translate-x-4 bg-cine-gray/90 hover:bg-cine-accent text-white p-3 rounded-full transition-colors duration-300 backdrop-blur-sm"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </button>
          </>
        )}
      </div>

      {/* Lightbox Modal */}
      {lightboxImage && (
        <div
          className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 opacity-0 invisible transition-all duration-300 animate-fade-in"
          style={{ opacity: 1, visibility: 'visible' }}
          onClick={(e) => e.target === e.currentTarget && closeLightbox()}
        >
          <div className="relative max-w-4xl max-h-[90vh] w-full px-4 flex items-center justify-center">
            {/* Flecha izquierda */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                navigateLightbox('prev');
              }}
              className="absolute left-4 md:left-8 bg-black/50 hover:bg-cine-accent text-white p-3 rounded-full transition-all duration-300 z-10 hover:scale-110"
              aria-label="Imagen anterior"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path>
              </svg>
            </button>

            {/* Contenedor de imagen */}
            <div className="relative max-w-full max-h-[90vh] transform scale-80 transition-transform duration-300"
              style={{ transform: 'scale(1)' }}>
              <button
                onClick={closeLightbox}
                className="absolute -top-10 right-0 bg-black/50 hover:bg-cine-accent text-white text-2xl w-10 h-10 rounded-full flex items-center justify-center transition-colors duration-300"
              >
                √ó
              </button>
              <img
                src={lightboxImage.src}
                alt={lightboxImage.caption}
                className="max-w-full max-h-[80vh] object-contain rounded-lg shadow-2xl"
              />
              <div className="absolute -bottom-12 left-0 right-0 text-center">
                <p className="text-white text-base font-medium">{lightboxImage.caption}</p>
                <p className="text-gray-400 text-sm mt-1">{lightboxImage.index + 1} de {images.length}</p>
              </div>
            </div>

            {/* Flecha derecha */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                navigateLightbox('next');
              }}
              className="absolute right-4 md:right-8 bg-black/50 hover:bg-cine-accent text-white p-3 rounded-full transition-all duration-300 z-10 hover:scale-110"
              aria-label="Imagen siguiente"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </button>
          </div>
        </div>
      )}
    </>
  );
}

// ==================================================
// src/components/movies/MovieHero.tsx
// ==================================================
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { BACKGROUND_PLACEHOLDER } from '@/lib/movies/movieConstants';

interface MovieHeroProps {
  title: string;
  year: number | null;
  duration: number;
  genres: string[];
  posterUrl?: string | null;
  premiereVenues: string;
  releaseDate?: {
    day: number | null;
    month: number | null;
    year: number | null;
  } | null;
  rating?: {
    id: number;
    name: string;
    abbreviation?: string | null;
  } | null;
  heroBackgroundImage?: string | null;
}

export function MovieHero({ 
  title, 
  year, 
  duration, 
  genres, 
  posterUrl, 
  premiereVenues, 
  releaseDate, 
  rating,
  heroBackgroundImage 
}: MovieHeroProps) {
  const [heroImageError, setHeroImageError] = useState(false);

  // Determinar si tenemos una imagen de hero v√°lida
  const hasValidHeroImage = heroBackgroundImage && heroBackgroundImage.trim() !== '' && !heroImageError;

  // Nombres de meses para formatear
  const months = [
    'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
    'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
  ];

  // Verificar si tenemos fecha completa para mostrar
  const hasCompleteReleaseDate = releaseDate?.day && releaseDate?.month && releaseDate?.year;

  // Formatear d√≠a y mes (para el link)
  const formatDayMonth = () => {
    if (!releaseDate?.day || !releaseDate?.month) return null;
    return `${releaseDate.day} de ${months[releaseDate.month - 1]}`;
  };

  // Generar URL de efem√©rides (formato: /efemerides/MM-DD)
  const getEfemeridesUrl = () => {
    if (!releaseDate?.day || !releaseDate?.month) return null;
    const monthStr = String(releaseDate.month).padStart(2, '0');
    const dayStr = String(releaseDate.day).padStart(2, '0');
    return `/efemerides/${monthStr}-${dayStr}`;
  };

  // Generar URL de listado de estrenos por a√±o (formato: /listados/estrenos?period=2020s&year=2025)
  const getEstrenosYearUrl = () => {
    if (!releaseDate?.year) return null;
    const decade = Math.floor(releaseDate.year / 10) * 10;
    return `/listados/estrenos?period=${decade}s&year=${releaseDate.year}`;
  };

  const dayMonthText = formatDayMonth();
  const efemeridesUrl = getEfemeridesUrl();
  const estrenosYearUrl = getEstrenosYearUrl();

  // A√±o a mostrar: producci√≥n primero, estreno como fallback
  const displayYear = year || releaseDate?.year;

  // Abreviaci√≥n del rating
  const ratingAbbreviation = rating?.abbreviation || rating?.name;

  return (
    <div className="relative min-h-[400px] overflow-hidden bg-[#0f1419]">
      {/* Contenedor de imagen con gradientes - mismo estilo que HeroSection */}
      <div className="relative flex items-center justify-center">
        {hasValidHeroImage ? (
          <div className="relative inline-block max-h-[500px]">
            {/* Imagen completa centrada */}
            <img
              src={heroBackgroundImage}
              alt=""
              className="max-w-full max-h-[500px] block"
              onError={() => setHeroImageError(true)}
            />
            
            {/* Gradientes relativos a la imagen - mismo estilo que HeroSection */}
            <div 
              className="absolute left-0 top-0 bottom-0 w-1/4 pointer-events-none"
              style={{
                background: 'linear-gradient(90deg, #0f1419 0%, rgba(15,20,25,0.7) 40%, transparent 100%)'
              }}
            />
            
            <div 
              className="absolute right-0 top-0 bottom-0 w-1/4 pointer-events-none"
              style={{
                background: 'linear-gradient(270deg, #0f1419 0%, rgba(15,20,25,0.7) 40%, transparent 100%)'
              }}
            />
            
            <div 
              className="absolute top-0 left-0 right-0 h-1/4 pointer-events-none"
              style={{
                background: 'linear-gradient(180deg, #0f1419 0%, rgba(15,20,25,0.6) 50%, transparent 100%)'
              }}
            />
            
            <div 
              className="absolute bottom-0 left-0 right-0 h-1/3 pointer-events-none"
              style={{
                background: 'linear-gradient(0deg, #0f1419 0%, rgba(15,20,25,0.7) 50%, transparent 100%)'
              }}
            />

            {/* Vi√±eta radial */}
            <div 
              className="absolute inset-0 pointer-events-none"
              style={{
                background: 'radial-gradient(ellipse at center, transparent 40%, rgba(15,20,25,0.3) 100%)'
              }}
            />
          </div>
        ) : (
          /* Placeholder cuando no hay imagen */
          <div
            className="w-full h-[400px] bg-cover bg-center"
            style={{
              backgroundImage: `url(${BACKGROUND_PLACEHOLDER.url})`,
              filter: 'brightness(0.3)'
            }}
          />
        )}
      </div>

      {/* Content - posicionado en la parte inferior */}
      <div className="absolute bottom-0 left-0 right-0 z-10">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-8 w-full">
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold text-white mb-4 drop-shadow-lg">
            {title}{displayYear && ` (${displayYear})`}
          </h1>

          {hasCompleteReleaseDate && dayMonthText && efemeridesUrl && estrenosYearUrl && (
            <p className="text-gray-300 mb-3 drop-shadow-md">
              Estreno comercial en Argentina:
              <Link 
                href={efemeridesUrl} 
                className="font-medium ml-2 text-gray-100 hover:text-cine-accent transition-colors"
              >
                {dayMonthText}
              </Link>
              <span> de </span>
              <Link 
                href={estrenosYearUrl} 
                className="font-medium text-gray-100 hover:text-cine-accent transition-colors"
              >
                {releaseDate?.year}
              </Link>
              {premiereVenues && <span className="font-medium text-gray-100"> en {premiereVenues}</span>}
            </p>
          )}

          <div className="flex flex-wrap items-center gap-4 text-gray-300 drop-shadow-md">
            {duration > 0 && (
              <span>{duration} min</span>
            )}
            {genres.length > 0 && (
              <>
                <span>‚Ä¢</span>
                <span>{genres.join(', ')}</span>
              </>
            )}
            {ratingAbbreviation && (
              <>
                <span>‚Ä¢</span>
                <span title={rating?.name} className="cursor-default">{ratingAbbreviation}</span>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

// ==================================================
// src/components/movies/MovieInfo.tsx
// ==================================================
'use client';

import { useEffect, useState } from 'react';
import DOMPurify from 'isomorphic-dompurify';

interface Person {
  id: number;
  firstName?: string | null;
  lastName?: string | null;
  slug: string;
  photoUrl?: string | null;
}

interface CrewMember {
  person: Person;
  roleId?: number | null;
  role?: string;
  department?: string | null;
}

interface MovieWithCrew {
  id: number;
  slug: string;
  title: string;
  synopsis?: string | null;
  trailerUrl?: string | null;
  crew?: CrewMember[];
}

interface Director {
  id: number;
  name: string;
  slug: string;
  photoUrl?: string | null;
}

interface MovieInfoProps {
  movie: MovieWithCrew;
  onTrailerClick?: () => void;
  onShareClick?: () => void;
}

export function MovieInfo({ movie, onTrailerClick, onShareClick }: MovieInfoProps) {
  const [directors, setDirectors] = useState<Director[]>([]);

  useEffect(() => {
    if (movie.crew && Array.isArray(movie.crew) && movie.crew.length > 0) {
      // Filtrar todos los miembros del crew que sean directores (roleId === 2)
      const directorsCrew = movie.crew.filter(member => member.roleId === 2);

      const directorsData = directorsCrew.map(directorCrew => {
        if (directorCrew?.person) {
          const { id, firstName, lastName, slug, photoUrl } = directorCrew.person;
          const fullName = [firstName, lastName].filter(Boolean).join(' ');
          return {
            id,
            name: fullName || 'Director desconocido',
            slug: slug || '',
            photoUrl: photoUrl || null
          };
        }
        return null;
      }).filter(Boolean) as Director[];

      setDirectors(directorsData);
    }
  }, [movie]);

  // Sanitizar la sinopsis para prevenir XSS
  const sanitizedSynopsis = movie.synopsis
    ? DOMPurify.sanitize(movie.synopsis, {
      ALLOWED_TAGS: ['p', 'a', 'strong', 'em', 'br', 'ul', 'ol', 'li', 'b', 'i', 'span'],
      ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
      ADD_ATTR: ['target'],
    })
    : null;

  return (
    <div className="space-y-6">
      {/* Sinopsis - Solo renderizar si existe */}
      {sanitizedSynopsis && (
        <div className="grid grid-cols-1 gap-6">
          <div>
            <h3 className="text-lg font-medium mb-3 text-cine-accent">Sinopsis</h3>
            <div
              className="serif-body text-lg text-gray-300 leading-relaxed"
              dangerouslySetInnerHTML={{ __html: sanitizedSynopsis }}
            />
          </div>
        </div>
      )}

      {/* Directores */}
      {directors.length > 0 && (
        <div className="grid grid-cols-1 gap-6">
          <div>
            <h3 className="text-lg font-medium mb-3 text-cine-accent">Direcci√≥n</h3>
            <div className="flex flex-wrap gap-4">
              {directors.map((director) => (
                <div key={director.id} className="flex items-center space-x-3">
                  <div className="w-12 h-12 rounded-full person-placeholder">
                    {director.photoUrl ? (
                      <img
                        src={director.photoUrl}
                        alt={director.name}
                        className="w-full h-full object-cover rounded-full"
                      />
                    ) : (
                      <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                    )}
                  </div>
                  <div>
                    <a
                      href={`/persona/${director.slug}`}
                      className="font-medium text-white hover:text-cine-accent transition-colors"
                    >
                      {director.name}
                    </a>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Botones de acci√≥n */}
      <div className="flex flex-wrap gap-4">
        <button
          onClick={onShareClick}
          className="border border-gray-600 hover:border-cine-accent px-6 py-3 rounded-lg font-medium transition-colors text-white"
        >
          Compartir
        </button>
      </div>
    </div>
  );
}

// ==================================================
// src/components/movies/MoviePoster.tsx
// ==================================================
'use client';

import { useState } from 'react';
import { POSTER_PLACEHOLDER } from '@/lib/movies/movieConstants';

interface MoviePosterProps {
  imageUrl?: string;
  title: string;
}

export function MoviePoster({ imageUrl, title }: MoviePosterProps) {
  const [imageError, setImageError] = useState(false);
  const showPlaceholder = !imageUrl || imageError;
  
  return (
    <div className="flex justify-center">
      <div className="relative inline-block">
        <img 
          src={imageUrl || POSTER_PLACEHOLDER.cloudinaryUrl} 
          alt={`Poster de ${title}`}
          className="h-[500px] w-auto rounded-lg poster-shadow"
          style={{
            filter: showPlaceholder ? 'brightness(0.4)' : 'none'
          }}
          onError={() => setImageError(true)}
        />
        
        {/* Texto elegante sobre el placeholder */}
        {showPlaceholder && (
          <div className="absolute bottom-4 right-4">
            <p className="text-gray-400/60 text-xs font-light tracking-wide">
              Afiche no disponible
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ==================================================
// src/components/movies/MovieSidebar.tsx
// ==================================================
// src/components/movies/MovieSidebar.tsx
'use client';

interface MovieSidebarProps {
  year: number | null;
  releaseYear?: number | null;
  duration: number | null;
  durationSeconds?: number | null;
  countries?: Array<{ id: number; name: string }> | null;
  rating?: { id: number; name: string; description?: string } | null;
  colorType?: { id: number; name: string } | null;
  soundType?: string | null;
  genres?: Array<{ id: number; name: string }>;
  themes?: Array<{ id: number; name: string }>;
}

export function MovieSidebar({
  year,
  releaseYear,
  duration,
  durationSeconds,
  countries,
  rating,
  colorType,
  soundType,
  genres = [],
  themes = []
}: MovieSidebarProps) {
  // Formatear duraci√≥n con segundos si existen
  const formatDuration = () => {
    if (!duration) return null;
    let durationStr = `${duration} min`;
    if (durationSeconds) {
      durationStr += ` ${durationSeconds} seg`;
    }
    return durationStr;
  };

  // Formatear tipo de pel√≠cula (color/sonido)
  const formatFilmType = () => {
    const parts = [];
    // Solo mostrar colorType si existe y NO es "No disponible" (id: 12)
    if (colorType && colorType.id !== 12) {
      // Traducir nombres comunes
      const colorName = colorType.name === 'COLOR' ? 'Color' : 
                       colorType.name === 'BLACK_AND_WHITE' ? 'Blanco y Negro' :
                       colorType.name === 'MIXED' ? 'Mixto' : 
                       colorType.name;
      parts.push(colorName);
    }
    if (soundType) {
      parts.push(soundType === 'SOUND' || soundType === 'Sonora' ? 'Sonora' : 'Muda');
    }
    return parts.length > 0 ? parts.join(' | ') : null;
  };

  const formattedDuration = formatDuration();
  const filmType = formatFilmType();
  const hasCountries = countries && countries.length > 0;
  const displayYear = year || releaseYear;

  return (
    <div className="glass-effect rounded-lg p-6 space-y-6">
      {/* Technical Information */}
      <div>
        <h3 className="text-lg font-medium mb-4 text-cine-accent">Informaci√≥n</h3>
        <div className="space-y-3 text-sm">
          {/* Mostrar a√±o solo si existe */}
          {displayYear && (
            <div className="flex items-start">
              <span className="text-gray-400 w-32 flex-shrink-0">A√±o de producci√≥n:</span>
              <span className="ml-2 text-white">{displayYear}</span>
            </div>
          )}
          
          {/* Duraci√≥n */}
          {formattedDuration && (
            <div className="flex items-start">
              <span className="text-gray-400 w-32 flex-shrink-0">Duraci√≥n:</span>
              <span className="ml-2 text-white">{formattedDuration}</span>
            </div>
          )}
          
          {/* Pa√≠ses coproductores - solo si hay */}
          {hasCountries && (
            <div className="flex items-start">
              <span className="text-gray-400 w-32 flex-shrink-0">
                Coproducci√≥n con:
              </span>
              <span className="ml-2 text-white">
                {countries.map(c => c.name).join(', ')}
              </span>
            </div>
          )}
          
          {/* Calificaci√≥n por edad - solo si existe */}
          {rating && (
            <div className="flex items-start">
              <span className="text-gray-400 w-32 flex-shrink-0">Calificaci√≥n:</span>
              <span className="ml-2 text-white">{rating.name}</span>
            </div>
          )}
          
          {/* Formato (Color/Sonido) - solo si existe */}
          {filmType && (
            <div className="flex justify-end mt-4 pt-3 border-t border-gray-700">
              <span className="ml-2 text-white">{filmType}</span>
            </div>
          )}
        </div>
      </div>

      {/* Genres - solo si hay */}
      {genres && genres.length > 0 && (
        <div>
          <h3 className="text-lg font-medium mb-4 text-cine-accent">G√©neros</h3>
          <div className="flex flex-wrap gap-2">
            {genres.map((genre) => (
              <span
                key={genre.id}
                className="bg-cine-gray px-3 py-1 rounded-full text-sm text-white hover:bg-cine-accent/20 transition-colors cursor-pointer"
              >
                {genre.name}
              </span>
            ))}
          </div>
        </div>
      )}

      {/* Themes - solo si hay */}
      {themes && themes.length > 0 && (
        <div>
          <h3 className="text-lg font-medium mb-4 text-cine-accent">Temas</h3>
          <div className="flex flex-wrap gap-2">
            {themes.map((theme) => (
              <span
                key={theme.id}
                className="bg-cine-gray px-3 py-1 rounded-full text-sm text-white hover:bg-cine-accent/20 transition-colors cursor-pointer"
              >
                {theme.name}
              </span>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

// ==================================================
// src/components/movies/SimilarMovies.tsx
// ==================================================
'use client';

import Link from 'next/link';

interface Movie {
  id?: string;
  slug?: string;
  title: string;
  year: string | number;
  posterUrl?: string;
}

interface SimilarMoviesProps {
  movies: Movie[];
}

export function SimilarMovies({ movies }: SimilarMoviesProps) {
  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 border-t border-gray-800">
      <h2 className="serif-heading text-2xl text-white mb-6">Pel√≠culas Similares</h2>
      <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
        {movies.map((movie, index) => {
          const movieLink = movie.slug || movie.id || '#';
          
          return (
            <Link 
              key={movie.id || index} 
              href={`/pelicula/${movieLink}`}
              className="group cursor-pointer block"
            >
              <div className="aspect-[2/3] rounded-lg overflow-hidden mb-2 transform group-hover:scale-105 transition-transform">
                {movie.posterUrl ? (
                  <img 
                    src={movie.posterUrl}
                    alt={`Poster de ${movie.title}`}
                    className="w-full h-full object-cover"
                    loading="lazy"
                  />
                ) : (
                  <div className="placeholder-small w-full h-full">
                    <svg className="w-8 h-8 text-gray-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                    </svg>
                    <p className="text-xs text-gray-400 text-center">Sin imagen</p>
                  </div>
                )}
              </div>
              <p className="text-sm font-medium text-white group-hover:text-cine-accent transition-colors">
                {movie.title}
              </p>
              <p className="text-xs text-gray-400">{movie.year}</p>
            </Link>
          );
        })}
      </div>
    </div>
  );
}

// ==================================================
// src/components/movies/TrailerSection.tsx
// ==================================================
// src/app/components/TrailerSection.tsx

interface TrailerSectionProps {
  trailerUrl?: string;
  movieTitle: string;
  variant?: 'default' | 'minimal' | 'card' | 'compact' | 'fullwidth';
}

export function TrailerSection({ trailerUrl, movieTitle, variant = 'fullwidth' }: TrailerSectionProps) {
  if (!trailerUrl) return null;

  // Extraer el ID del video de YouTube de la URL
  const getYouTubeId = (url: string) => {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return match && match[2].length === 11 ? match[2] : null;
  };

  const videoId = getYouTubeId(trailerUrl);

  if (!videoId) return null;

  // Nueva variante fullwidth - ocupa todo el ancho sin el cuadro informativo
  if (variant === 'fullwidth') {
    return (
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 border-t border-gray-800">
        <h2 className="serif-heading text-2xl text-white mb-6">Trailer</h2>
        <div className="relative w-full aspect-video rounded-lg overflow-hidden bg-cine-gray shadow-2xl">
          <iframe
            className="absolute top-0 left-0 w-full h-full"
            src={`https://www.youtube.com/embed/${videoId}?modestbranding=1&rel=0`}
            title={`Trailer de ${movieTitle}`}
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowFullScreen
          />
        </div>
      </div>
    );
  }

  // Variante compacta (original con el cuadro lateral)
  if (variant === 'compact') {
    return (
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 border-t border-gray-800">
        <h2 className="serif-heading text-2xl text-white mb-6">Trailer</h2>
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <div className="lg:col-span-2">
            <div className="relative w-full aspect-video rounded-lg overflow-hidden bg-cine-gray shadow-2xl">
              <iframe
                className="absolute top-0 left-0 w-full h-full"
                src={`https://www.youtube.com/embed/${videoId}?modestbranding=1&rel=0`}
                title={`Trailer de ${movieTitle}`}
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                allowFullScreen
              />
            </div>
          </div>
          <div className="lg:col-span-1">
            <div className="glass-effect rounded-lg p-6">
              <h3 className="text-lg font-medium mb-3 text-cine-accent">Sobre el trailer</h3>
              <p className="text-sm text-gray-300 mb-4">
                Mira el trailer oficial de {movieTitle} y descubre por qu√© se convirti√≥ en un fen√≥meno del cine argentino.
              </p>
              <div className="flex flex-wrap gap-2">
                <span className="bg-cine-gray px-3 py-1 rounded-full text-xs text-white">Trailer Oficial</span>
                <span className="bg-cine-gray px-3 py-1 rounded-full text-xs text-white">HD</span>
                <span className="bg-cine-gray px-3 py-1 rounded-full text-xs text-white">Subtitulado</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Variante por defecto con fondo
  if (variant === 'default') {
    return (
      <div className="bg-black/5 dark:bg-white/5 rounded-lg p-6 mt-8">
        <h2 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">
          Trailer
        </h2>
        <div className="relative w-full aspect-video rounded-lg overflow-hidden shadow-lg">
          <iframe
            className="absolute top-0 left-0 w-full h-full"
            src={`https://www.youtube.com/embed/${videoId}`}
            title={`Trailer de ${movieTitle}`}
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowFullScreen
          />
        </div>
      </div>
    );
  }

  // Variante minimalista
  if (variant === 'minimal') {
    return (
      <div className="mt-8">
        <h2 className="text-2xl font-bold text-white mb-4">Trailer</h2>
        <div className="relative w-full aspect-video rounded-lg overflow-hidden shadow-2xl">
          <iframe
            className="absolute top-0 left-0 w-full h-full"
            src={`https://www.youtube.com/embed/${videoId}?modestbranding=1&rel=0`}
            title={`Trailer de ${movieTitle}`}
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowFullScreen
          />
        </div>
      </div>
    );
  }

  // Variante tipo tarjeta con thumbnail personalizable
  if (variant === 'card') {
    return (
      <div className="mt-8">
        <h2 className="text-2xl font-bold text-white mb-4">Trailer</h2>
        <div className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 backdrop-blur-md rounded-xl p-1">
          <div className="bg-black/40 backdrop-blur-xl rounded-lg p-4">
            <div className="relative w-full aspect-video rounded-lg overflow-hidden">
              <iframe
                className="absolute top-0 left-0 w-full h-full"
                src={`https://www.youtube.com/embed/${videoId}?modestbranding=1&rel=0`}
                title={`Trailer de ${movieTitle}`}
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                allowFullScreen
              />
            </div>
            <p className="text-sm text-gray-300 mt-3 text-center">
              Ver trailer oficial de {movieTitle}
            </p>
          </div>
        </div>
      </div>
    );
  }

  return null;
}

// ==================================================
// src/constants/homeData.ts
// ==================================================
// src/constants/homeData.ts
import { HeroMovie, Efemeride } from '@/types/home.types';

export const PELICULAS_HERO: HeroMovie[] = [
  { 
    id: 1, 
    titulo: "El Secreto de Sus Ojos", 
    a√±o: "2009", 
    genero: "Drama, Thriller", 
    director: "Juan Jos√© Campanella", 
    imagen: "https://images.unsplash.com/photo-1518998053901-5348d3961a04?w=1024&fit=crop&auto=format" 
  },
  { 
    id: 2, 
    titulo: "Relatos Salvajes", 
    a√±o: "2014", 
    genero: "Comedia negra", 
    director: "Dami√°n Szifron", 
    imagen: "https://images.unsplash.com/photo-1507003211169-0a1dd7506d40?w=1024&fit=crop&auto=format" 
  },
  { 
    id: 3, 
    titulo: "Argentina, 1985", 
    a√±o: "2022", 
    genero: "Drama hist√≥rico", 
    director: "Santiago Mitre", 
    imagen: "https://images.unsplash.com/photo-1519225421980-715cb0215aed?w=1024&fit=crop&auto=format" 
  },
  { 
    id: 4, 
    titulo: "La Ci√©naga", 
    a√±o: "2001", 
    genero: "Drama", 
    director: "Lucrecia Martel", 
    imagen: "https://images.unsplash.com/photo-1489599328131-cdd7553e2ad1?w=1024&fit=crop&auto=format" 
  },
  { 
    id: 5, 
    titulo: "Nueve Reinas", 
    a√±o: "2000", 
    genero: "Thriller", 
    director: "Fabi√°n Bielinsky", 
    imagen: "https://images.unsplash.com/photo-1556388158-158ea5ccacbd?w=1024&fit=crop&auto=format" 
  }
];

// ==================================================
// src/contexts/MovieModalContext.tsx
// ==================================================
// src/contexts/MovieModalContext.tsx
import React, { createContext, useContext, useEffect, ReactNode } from 'react';
import { useMovieForm } from '@/hooks/useMovieForm';
import type { Movie } from '@/lib/movies/movieTypes';

interface MovieModalContextValue {
  // Form methods
  register: any;
  handleSubmit: any;
  watch: any;
  setValue: any;
  reset: any;
  control: any;
  formState: any;
  
  // State
  activeTab: string;
  setActiveTab: (tab: string) => void;
  isSubmitting: boolean;
  editingMovie: Movie | null;
  
  // Submit handler
  onSubmit: (data: any) => Promise<void>;
  
  // Date handling
  isPartialDate: boolean;
  setIsPartialDate: (value: boolean) => void;
  partialReleaseDate: any;
  setPartialReleaseDate: (value: any) => void;
  
  // Filming dates
  isPartialFilmingStartDate: boolean;
  setIsPartialFilmingStartDate: (value: boolean) => void;
  partialFilmingStartDate: any;
  setPartialFilmingStartDate: (value: any) => void;
  isPartialFilmingEndDate: boolean;
  setIsPartialFilmingEndDate: (value: boolean) => void;
  partialFilmingEndDate: any;
  setPartialFilmingEndDate: (value: any) => void;
  
  // UI states
  tipoDuracionDisabled: boolean;
  movieFormInitialData: any;
  alternativeTitles: any[];
  setAlternativeTitles: (titles: any[]) => void;
  movieLinks: any[];
  
  // Metadata
  availableRatings: any[];
  availableColorTypes: any[];
  
  // Relation handlers
  handleGenresChange: (genres: number[]) => void;
  handleLinksChange: (links: any[]) => void;
  handleCastChange: (cast: any[]) => void;
  handleCrewChange: (crew: any[]) => void;
  handleCountriesChange: (countries: number[]) => void;
  handleProductionCompaniesChange: (companies: number[]) => void;
  handleDistributionCompaniesChange: (companies: number[]) => void;
  handleThemesChange: (themes: number[]) => void;
  handleScreeningVenuesChange: (venues: number[]) => void;
  
  // Functions
  loadMovieData: (movie: Movie) => Promise<void>;
  resetForNewMovie: () => void;
}

const MovieModalContext = createContext<MovieModalContextValue | null>(null);

interface MovieModalProviderProps {
  children: ReactNode;
  editingMovie: Movie | null;
  onSuccess?: (movie: Movie) => void;
  onError?: (error: Error) => void;
}

export function MovieModalProvider({ 
  children, 
  editingMovie, 
  onSuccess, 
  onError 
}: MovieModalProviderProps) {
  const movieFormData = useMovieForm({
    editingMovie,
    onSuccess,
    onError
  });

  // Cargar datos autom√°ticamente cuando cambia editingMovie
  useEffect(() => {
    if (editingMovie) {
      console.log('üîÑ Loading movie data for editing:', editingMovie.title)
      movieFormData.loadMovieData(editingMovie).catch(error => {
        console.error('‚ùå Error loading movie data:', error)
        if (onError) {
          onError(error instanceof Error ? error : new Error('Error loading movie data'))
        }
      })
    } else {
      // Si no hay pel√≠cula edit√°ndose, resetear para nueva pel√≠cula
      movieFormData.resetForNewMovie()
    }
  }, [editingMovie?.id])

  return (
    <MovieModalContext.Provider value={{
      ...movieFormData,
      editingMovie
    }}>
      {children}
    </MovieModalContext.Provider>
  );
}

export function useMovieModalContext() {
  const context = useContext(MovieModalContext);
  if (!context) {
    throw new Error('useMovieModalContext must be used within MovieModalProvider');
  }
  return context;
}

// Uso simplificado:
// <MovieModalProvider editingMovie={movie} onSuccess={handleSuccess}>
//   <MovieModal />  {/* ¬°Sin props! */}
// </MovieModalProvider>

// ==================================================
// src/hooks/useDebounce.ts
// ==================================================
// src/hooks/useDebounce.ts

import { useState, useEffect } from 'react';

/**
 * Hook que retrasa la actualizaci√≥n de un valor hasta que haya pasado
 * un tiempo determinado sin cambios
 * 
 * @param value - El valor a retrasar
 * @param delay - El tiempo de retraso en milisegundos
 * @returns El valor retrasado
 * 
 * @example
 * const [searchTerm, setSearchTerm] = useState('');
 * const debouncedSearchTerm = useDebounce(searchTerm, 300);
 * 
 * // debouncedSearchTerm se actualizar√° 300ms despu√©s de que 
 * // el usuario deje de escribir
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Crear un timeout para actualizar el valor despu√©s del delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Limpiar el timeout si el value cambia antes del delay
    // Esto "cancela" la actualizaci√≥n anterior y empieza una nueva
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// ==================================================
// src/hooks/useGlobalSearch.ts
// ==================================================
import { useState, useEffect, useCallback } from 'react'
import { useDebounce } from './useDebounce'

export interface SearchResult {
  movies: MovieSearchResult[]
  people: PersonSearchResult[]
  total: number
}

export interface MovieSearchResult {
  id: number
  slug: string
  title: string
  originalTitle?: string
  year?: number
  posterUrl?: string
  type: 'movie'
  director?: string | null
}

export interface PersonSearchResult {
  id: number
  slug: string
  name: string
  photoUrl?: string
  birthYear?: number
  deathYear?: number
  type: 'person'
}

interface UseGlobalSearchReturn {
  query: string
  setQuery: (query: string) => void
  results: SearchResult | null
  loading: boolean
  error: Error | null
  clearSearch: () => void
  hasResults: boolean
}

export function useGlobalSearch(minChars: number = 2): UseGlobalSearchReturn {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<SearchResult | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const debouncedQuery = useDebounce(query, 300)

  const search = useCallback(async (searchQuery: string) => {
    if (searchQuery.length < minChars) {
      setResults(null)
      return
    }

    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}&limit=8`)
      
      if (!response.ok) {
        throw new Error('Error en la b√∫squeda')
      }

      const data = await response.json()
      setResults(data)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Error desconocido'))
      setResults(null)
    } finally {
      setLoading(false)
    }
  }, [minChars])

  useEffect(() => {
    if (debouncedQuery) {
      search(debouncedQuery)
    } else {
      setResults(null)
    }
  }, [debouncedQuery, search])

  const clearSearch = useCallback(() => {
    setQuery('')
    setResults(null)
    setError(null)
  }, [])

  return {
    query,
    setQuery,
    results,
    loading,
    error,
    clearSearch,
    hasResults: !!(results && results.total > 0)
  }
}

// ==================================================
// src/hooks/useHomeData.ts
// ==================================================
// src/hooks/useHomeData.ts
import { useState, useEffect } from 'react';
import { MovieWithRelease, SimpleMovie, SimplePerson, HomeDataResponse } from '@/types/home.types';

interface UseHomeDataReturn {
  ultimosEstrenos: MovieWithRelease[];
  proximosEstrenos: MovieWithRelease[];
  ultimasPeliculas: SimpleMovie[];
  ultimasPersonas: SimplePerson[];
  loadingEstrenos: boolean;
  loadingProximos: boolean;
  loadingRecientes: boolean;
  error: string | null;
  retry: () => void;
}

export function useHomeData(): UseHomeDataReturn {
  const [ultimosEstrenos, setUltimosEstrenos] = useState<MovieWithRelease[]>([]);
  const [proximosEstrenos, setProximosEstrenos] = useState<MovieWithRelease[]>([]);
  const [ultimasPeliculas, setUltimasPeliculas] = useState<SimpleMovie[]>([]);
  const [ultimasPersonas, setUltimasPersonas] = useState<SimplePerson[]>([]);
  const [loadingEstrenos, setLoadingEstrenos] = useState(true);
  const [loadingProximos, setLoadingProximos] = useState(true);
  const [loadingRecientes, setLoadingRecientes] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchHomeData = async (attempt = 1) => {
    try {
      console.log(`üîÑ Intento ${attempt} de cargar datos...`);
      setError(null);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        console.log('‚è±Ô∏è Timeout alcanzado, abortando...');
        controller.abort();
      }, 20000);

      const response = await fetch('/api/movies/home-feed', {
        signal: controller.signal,
        cache: 'no-store'
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Error ${response.status}: ${response.statusText}`);
      }

      const data: HomeDataResponse = await response.json();

      setUltimosEstrenos(data.ultimosEstrenos || []);
      setProximosEstrenos(data.proximosEstrenos || []);
      setUltimasPeliculas(data.ultimasPeliculas || []);
      setUltimasPersonas(data.ultimasPersonas || []);
      setError(null);

    } catch (error: any) {
      console.error(`‚ùå Error en intento ${attempt}:`, error);

      if (error.name === 'AbortError') {
        setError('La carga tard√≥ demasiado. Intentando de nuevo...');
      } else {
        setError(`Error al cargar datos: ${error.message}`);
      }

      if (attempt < 3) {
        const delay = attempt * 2000;
        console.log(`‚è≥ Reintentando en ${delay / 1000} segundos...`);
        setTimeout(() => fetchHomeData(attempt + 1), delay);
      } else {
        setError('No se pudieron cargar los datos despu√©s de varios intentos.');
        setUltimasPeliculas([]);
        setUltimasPersonas([]);
      }
    } finally {
      setLoadingEstrenos(false);
      setLoadingProximos(false);
      setLoadingRecientes(false);
    }
  };

  useEffect(() => {
    fetchHomeData();
  }, []);

  const retry = () => {
    setLoadingEstrenos(true);
    setLoadingProximos(true);
    setLoadingRecientes(true);
    fetchHomeData();
  };

  return {
    ultimosEstrenos,
    proximosEstrenos,
    ultimasPeliculas,
    ultimasPersonas,
    loadingEstrenos,
    loadingProximos,
    loadingRecientes,
    error,
    retry
  };
}

// ==================================================
// src/hooks/useMovieForm.ts
// ==================================================
// src/hooks/useMovieForm.ts
import { useState, useEffect, useCallback } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { toast } from 'react-hot-toast'
import {
    movieFormSchema,
    MovieFormData,
    Movie,
    PartialReleaseDate,
    PartialFilmingDate
} from '@/lib/movies/movieTypes'
import {
    calcularTipoDuracion,
    prepareMovieData
} from '@/lib/movies/movieUtils'
import { moviesService } from '@/services'



interface UseMovieFormProps {
    editingMovie?: Movie | null
    onSuccess?: (movie: Movie) => void
    onError?: (error: Error) => void
}

interface UseMovieFormReturn {
    onSubmit: (data: MovieFormData) => Promise<void>

    // Estados de UI
    activeTab: string
    setActiveTab: (tab: string) => void
    isSubmitting: boolean

    // Estados de fechas parciales
    isPartialDate: boolean
    setIsPartialDate: (value: boolean) => void
    partialReleaseDate: PartialReleaseDate
    setPartialReleaseDate: (value: PartialReleaseDate) => void

    // Estados de fechas de rodaje
    isPartialFilmingStartDate: boolean
    setIsPartialFilmingStartDate: (value: boolean) => void
    partialFilmingStartDate: PartialFilmingDate
    setPartialFilmingStartDate: (value: PartialFilmingDate) => void
    isPartialFilmingEndDate: boolean
    setIsPartialFilmingEndDate: (value: boolean) => void
    partialFilmingEndDate: PartialFilmingDate
    setPartialFilmingEndDate: (value: PartialFilmingDate) => void

    // Estados espec√≠ficos de UI
    tipoDuracionDisabled: boolean
    movieFormInitialData: any
    alternativeTitles: any[]
    setAlternativeTitles: (titles: any[]) => void
    movieLinks: any[]

    // Metadata
    availableRatings: any[]
    availableColorTypes: any[]

    // Callbacks para relaciones
    handleGenresChange: (genres: number[]) => void
    handleLinksChange: (links: any[]) => void
    handleCastChange: (cast: any[]) => void
    handleCrewChange: (crew: any[]) => void
    handleCountriesChange: (countries: number[]) => void
    handleProductionCompaniesChange: (companies: number[]) => void
    handleDistributionCompaniesChange: (companies: number[]) => void
    handleThemesChange: (themes: number[]) => void
    handleScreeningVenuesChange: (venues: number[]) => void

    // Funciones principales
    loadMovieData: (movie: Movie) => Promise<void>
    resetForNewMovie: () => void

    // Form methods (todos como any para evitar problemas de tipos)
    register: any
    handleSubmit: any
    watch: any
    setValue: any
    reset: any
    formState: any
    control: any
    getValues: any
    trigger: any
    clearErrors: any
    setError: any
    setFocus: any
    getFieldState: any
    resetField: any
    unregister: any
}

export function useMovieForm({
    editingMovie = null,
    onSuccess,
    onError
}: UseMovieFormProps = {}): UseMovieFormReturn {

    // Estados del formulario y UI
    const [activeTab, setActiveTab] = useState('basic')
    const [isSubmitting, setIsSubmitting] = useState(false)

    // Estados de fechas parciales
    const [isPartialDate, setIsPartialDate] = useState(false)
    const [partialReleaseDate, setPartialReleaseDate] = useState<PartialReleaseDate>({
        year: null,
        month: null,
        day: null
    })

    // Estados para fechas de rodaje
    const [isPartialFilmingStartDate, setIsPartialFilmingStartDate] = useState(false)
    const [partialFilmingStartDate, setPartialFilmingStartDate] = useState<PartialFilmingDate>({
        year: null,
        month: null,
        day: null
    })

    const [isPartialFilmingEndDate, setIsPartialFilmingEndDate] = useState(false)
    const [partialFilmingEndDate, setPartialFilmingEndDate] = useState<PartialFilmingDate>({
        year: null,
        month: null,
        day: null
    })

    // Estados espec√≠ficos de UI
    const [tipoDuracionDisabled, setTipoDuracionDisabled] = useState(false)
    const [movieFormInitialData, setMovieFormInitialData] = useState<any>(null)

    // Estados de metadata
    const [availableRatings, setAvailableRatings] = useState<any[]>([])
    const [availableColorTypes, setAvailableColorTypes] = useState<any[]>([])

    // Estados de relaciones
    const [movieRelations, setMovieRelations] = useState<{
        genres: number[];
        cast: any[];
        crew: any[];
        countries: number[];
        productionCompanies: number[];
        distributionCompanies: number[];
        themes: number[];
        screeningVenues: number[];
    }>({
        genres: [],
        cast: [],
        crew: [],
        countries: [],
        productionCompanies: [],
        distributionCompanies: [],
        themes: [],
        screeningVenues: []
    })

    // Estados adicionales
    const [alternativeTitles, setAlternativeTitles] = useState<any[]>([])
    const [movieLinks, setMovieLinks] = useState<any[]>([])

    // React Hook Form
    const form = useForm<MovieFormData>({
        resolver: zodResolver(movieFormSchema),
        defaultValues: {
            stage: 'COMPLETA',
            dataCompleteness: 'BASIC_PRESS_KIT',
            metaDescription: '',
            metaKeywords: []
        }
    })

    const { watch, setValue, reset } = form

    // Cargar metadata (ratings y color types)
    useEffect(() => {
        const loadMetadata = async () => {
            try {
                const [ratingsRes, colorTypesRes] = await Promise.all([
                    fetch('/api/calificaciones'),
                    fetch('/api/color-types')
                ])

                if (ratingsRes.ok) {
                    const ratings = await ratingsRes.json()
                    setAvailableRatings(ratings)
                }

                if (colorTypesRes.ok) {
                    const colorTypes = await colorTypesRes.json()
                    setAvailableColorTypes(colorTypes)
                }
            } catch (error) {
                console.error('Error loading metadata:', error)
            }
        }

        loadMetadata()
    }, [])

    // Efecto para observar cambios en duraci√≥n
    useEffect(() => {
        const subscription = watch((value, { name, type }) => {
            if ((name === 'duration' || name === 'durationSeconds') && type === 'change') {
                const minutos = value.duration
                const segundos = value.durationSeconds
                const hayDuracion = (minutos && minutos > 0) || (segundos && segundos > 0)

                if (hayDuracion) {
                    const tipoCalculado = calcularTipoDuracion(minutos, segundos)
                    const tipoActual = value.tipoDuracion

                    if (tipoCalculado !== tipoActual) {
                        setValue('tipoDuracion', tipoCalculado, { shouldValidate: false })
                    }
                    setTipoDuracionDisabled(true)
                } else {
                    setTipoDuracionDisabled(false)
                }
            }
        })

        return () => subscription.unsubscribe()
    }, [watch, setValue])

    // Callbacks para actualizar relaciones
    const handleGenresChange = useCallback((genres: number[]) => {
        // Filtrar valores inv√°lidos antes de guardar
        const validGenres = (genres || []).filter(g => g != null && g !== 0 && !isNaN(g))
        setMovieRelations(prev => ({ ...prev, genres: validGenres }))
    }, [])

    const handleLinksChange = useCallback((links: any[]) => {
        setMovieLinks(links)
    }, [])

    const handleScreeningVenuesChange = useCallback((venueIds: number[]) => {
        setMovieRelations(prev => ({ ...prev, screeningVenues: venueIds }))
    }, [])

    const handleCastChange = useCallback((cast: any[]) => {
        console.log('üë• handleCastChange recibi√≥:', cast)
        setMovieRelations(prev => ({ ...prev, cast }))
    }, [])

    const handleCrewChange = useCallback((crew: any[]) => {
        console.log('üë• handleCrewChange recibi√≥:', crew)
        crew?.forEach((member, index) => {
            console.log(`üë• Crew[${index}]:`, {
                personId: member.personId,
                person: member.person,
                roleId: member.roleId,
                alternativeNameId: member.alternativeNameId,  // ‚úÖ AGREGADO LOG
                notes: member.notes  // ‚úÖ AGREGADO LOG
            })
        })
        setMovieRelations(prev => ({ ...prev, crew }))
    }, [])

    const handleCountriesChange = useCallback((countries: number[]) => {
        setMovieRelations(prev => ({ ...prev, countries }))
    }, [])

    const handleProductionCompaniesChange = useCallback((companies: number[]) => {
        setMovieRelations(prev => ({ ...prev, productionCompanies: companies }))
    }, [])

    const handleThemesChange = useCallback((themes: number[]) => {
        setMovieRelations(prev => ({ ...prev, themes }))
    }, [])

    const handleDistributionCompaniesChange = useCallback((companies: number[]) => {
        setMovieRelations(prev => ({ ...prev, distributionCompanies: companies }))
    }, [])

    // Funci√≥n para cargar datos de pel√≠cula existente
    const loadMovieData = useCallback(async (movie: Movie) => {
        try {
            const fullMovie = await moviesService.getById(movie.id)

            // LIMPIAR VALORES NULL DE CAMPOS STRING
            const cleanedMovie = {
                ...fullMovie,
                tagline: fullMovie.tagline || '',
                imdbId: fullMovie.imdbId || '',
                posterUrl: fullMovie.posterUrl || '',
                trailerUrl: fullMovie.trailerUrl || '',
                originalTitle: fullMovie.originalTitle || '',
                synopsis: fullMovie.synopsis || '',
                synopsisLocked: fullMovie.synopsisLocked ?? false, 
                notes: fullMovie.notes || '',
                aspectRatio: fullMovie.aspectRatio || '',
                soundType: fullMovie.soundType || '',
                filmFormat: fullMovie.filmFormat || '',
                certificateNumber: fullMovie.certificateNumber || '',
                metaDescription: fullMovie.metaDescription || '',
                metaKeywords: fullMovie.metaKeywords || [],
                tipoDuracion: fullMovie.tipoDuracion || ''
            }

            // Configurar tipo de duraci√≥n
            const minutos = cleanedMovie.duration
            const segundos = cleanedMovie.durationSeconds
            const hayDuracion = (minutos && minutos > 0) || (segundos && segundos > 0)

            if (hayDuracion) {
                const tipoCalculado = calcularTipoDuracion(minutos, segundos)
                setValue('tipoDuracion', tipoCalculado)
                setTipoDuracionDisabled(true)
            } else {
                setValue('tipoDuracion', cleanedMovie.tipoDuracion || '')
                setTipoDuracionDisabled(false)
            }

            // Configurar t√≠tulos alternativos
            if (cleanedMovie.alternativeTitles) {
                setAlternativeTitles(cleanedMovie.alternativeTitles)
            }

            // Llenar el formulario con los datos limpios
            Object.keys(cleanedMovie).forEach((key) => {
                if (key === 'metaKeywords' && Array.isArray(cleanedMovie[key])) {
                    setValue(key as any, cleanedMovie[key].join(', '))
                } else if (key === 'releaseDate' && cleanedMovie[key]) {
                    setValue(key as any, new Date(cleanedMovie[key]).toISOString().split('T')[0])
                    setIsPartialDate(false)
                } else if (key === 'durationSeconds') {
                    setValue(key as any, cleanedMovie[key] || 0)
                } else if (key === 'colorType' && cleanedMovie[key]) {
                    setValue('colorTypeId' as any, cleanedMovie[key].id)
                } else {
                    setValue(key as any, cleanedMovie[key])
                }
            })

            // Manejar fecha parcial de estreno
            if (cleanedMovie.releaseYear && !cleanedMovie.releaseDate) {
                setIsPartialDate(true)
                setPartialReleaseDate({
                    year: cleanedMovie.releaseYear,
                    month: cleanedMovie.releaseMonth || null,
                    day: null
                })

                if (cleanedMovie.releaseDay) {
                    setIsPartialDate(false)
                    const dateStr = `${cleanedMovie.releaseYear}-${String(cleanedMovie.releaseMonth || 1).padStart(2, '0')}-${String(cleanedMovie.releaseDay || 1).padStart(2, '0')}`
                    setValue('releaseDate', dateStr)
                }
            } else if (!cleanedMovie.releaseYear && !cleanedMovie.releaseDate) {
                setIsPartialDate(false)
                setPartialReleaseDate({ year: null, month: null, day: null })
            }

            // Manejar fecha parcial de inicio de rodaje
            if (cleanedMovie.filmingStartYear) {
                setIsPartialFilmingStartDate(true)
                setPartialFilmingStartDate({
                    year: cleanedMovie.filmingStartYear,
                    month: cleanedMovie.filmingStartMonth || null,
                    day: null
                })

                if (cleanedMovie.filmingStartDay) {
                    setIsPartialFilmingStartDate(false)
                    const dateStr = `${cleanedMovie.filmingStartYear}-${String(cleanedMovie.filmingStartMonth || 1).padStart(2, '0')}-${String(cleanedMovie.filmingStartDay || 1).padStart(2, '0')}`
                    setValue('filmingStartDate', dateStr)
                }
            } else {
                setIsPartialFilmingStartDate(false)
                setPartialFilmingStartDate({ year: null, month: null, day: null })
            }

            // Manejar fecha parcial de fin de rodaje
            if (cleanedMovie.filmingEndYear) {
                setIsPartialFilmingEndDate(true)
                setPartialFilmingEndDate({
                    year: cleanedMovie.filmingEndYear,
                    month: cleanedMovie.filmingEndMonth || null,
                    day: null
                })

                if (cleanedMovie.filmingEndDay) {
                    setIsPartialFilmingEndDate(false)
                    const dateStr = `${cleanedMovie.filmingEndYear}-${String(cleanedMovie.filmingEndMonth || 1).padStart(2, '0')}-${String(cleanedMovie.filmingEndDay || 1).padStart(2, '0')}`
                    setValue('filmingEndDate', dateStr)
                }
            } else {
                setIsPartialFilmingEndDate(false)
                setPartialFilmingEndDate({ year: null, month: null, day: null })
            }

            // Configurar valores por defecto
            if (!cleanedMovie.stage) {
                setValue('stage', 'COMPLETA')
            }
            setValue('dataCompleteness', cleanedMovie.dataCompleteness || 'BASIC_PRESS_KIT')

            if (cleanedMovie.ratingId) {
                setValue('ratingId', cleanedMovie.ratingId)
            }

            // Configurar datos iniciales y relaciones
            setMovieFormInitialData({
                genres: cleanedMovie.genres || [],
                cast: cleanedMovie.cast || [],
                crew: cleanedMovie.crew || [],
                countries: cleanedMovie.movieCountries || [],
                productionCompanies: cleanedMovie.productionCompanies || [],
                distributionCompanies: cleanedMovie.distributionCompanies || [],
                themes: cleanedMovie.themes || [],
                screeningVenues: cleanedMovie.screenings?.map((s: any) => s.venueId) || []
            })

            if (cleanedMovie.links) {
                setMovieLinks(cleanedMovie.links)
            }

            // Configurar relaciones
            setMovieRelations({
                genres: (cleanedMovie.genres?.map((g: any) => g.genre?.id || g.id) || [])
                    .filter((g: number) => g != null && g !== 0 && !isNaN(g)),

                // ‚úÖ PROCESAMIENTO MEJORADO DEL CAST - CON alternativeNameId
                cast: cleanedMovie.cast?.map((c: any) => {
                    console.log('üé¨ Procesando cast item desde DB:', c)
                    const mapped = {
                        personId: c.personId || c.person?.id,
                        person: c.person, // Mantener el objeto person completo
                        characterName: c.characterName,
                        billingOrder: c.billingOrder,
                        isPrincipal: c.isPrincipal,
                        isActor: c.isActor,
                        notes: c.notes,
                        alternativeNameId: c.alternativeNameId || null,  // ‚úÖ AGREGADO
                        alternativeName: c.alternativeName || null       // ‚úÖ AGREGADO
                    }
                    console.log('üé¨ Cast item mapeado:', mapped)
                    return mapped
                }) || [],

                // ‚úÖ PROCESAMIENTO DEL CREW - CON alternativeNameId y notes
                crew: (() => {
                    const crewData = cleanedMovie.crew?.map((c: any) => {
                        console.log('üìå Crew item desde DB:', c)
                        const mapped = {
                            personId: c.personId || c.person?.id,
                            roleId: c.roleId,
                            billingOrder: c.billingOrder,
                            person: c.person,
                            role: c.role,
                            notes: c.notes || '',                          // ‚úÖ AGREGADO
                            alternativeNameId: c.alternativeNameId || null, // ‚úÖ AGREGADO
                            alternativeName: c.alternativeName || null      // ‚úÖ AGREGADO
                        }
                        console.log('üìå Crew item mapeado:', mapped)
                        return mapped
                    }) || []
                    console.log('üìå Crew final cargado:', crewData)
                    return crewData
                })(),

                countries: cleanedMovie.movieCountries?.map((c: any) => c.countryId) || [],
                productionCompanies: cleanedMovie.productionCompanies?.map((c: any) => c.companyId) || [],
                distributionCompanies: cleanedMovie.distributionCompanies?.map((c: any) => c.companyId) || [],
                themes: cleanedMovie.themes?.map((t: any) => t.themeId) || [],
                screeningVenues: cleanedMovie.screenings?.map((s: any) => s.venueId) || []
            })

        } catch (error) {
            console.error('Error completo en loadMovieData:', error)
            console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack')
            toast.error('Error al cargar los datos de la pel√≠cula')

            // Notificar error al context parent
            if (onError) {
                onError(error instanceof Error ? error : new Error('Error desconocido en loadMovieData'))
            }

            throw error
        }
    }, [setValue, onError])

    // Funci√≥n submit modificada para usar callbacks
    const onSubmit = async (data: MovieFormData) => {
        if (isSubmitting) return; // Prevenir double submit

        setIsSubmitting(true)

        try {
            // Preparar los datos correctamente
            const preparedData = prepareMovieData(data)

            // Procesar fecha de estreno seg√∫n el tipo
            let releaseDateData = {}
            if (isPartialDate) {
                // Fecha parcial - enviar campos separados
                releaseDateData = {
                    releaseYear: partialReleaseDate.year,
                    releaseMonth: partialReleaseDate.month,
                    releaseDay: null
                }
            } else if (data.releaseDate) {
                // Fecha completa - convertir a campos separados
                const [year, month, day] = data.releaseDate.split('-').map(Number)
                releaseDateData = {
                    releaseYear: year,
                    releaseMonth: month,
                    releaseDay: day
                }
            } else {
                // Sin fecha
                releaseDateData = {
                    releaseYear: null,
                    releaseMonth: null,
                    releaseDay: null
                }
            }

            // Procesar fechas de rodaje
            let filmingStartDateData = {}
            if (isPartialFilmingStartDate && partialFilmingStartDate.year) {
                // Fecha parcial de inicio
                filmingStartDateData = {
                    filmingStartYear: partialFilmingStartDate.year,
                    filmingStartMonth: partialFilmingStartDate.month,
                    filmingStartDay: null
                }
            } else if (data.filmingStartDate) {
                // Fecha completa de inicio
                const [year, month, day] = data.filmingStartDate.split('-').map(Number)
                filmingStartDateData = {
                    filmingStartYear: year,
                    filmingStartMonth: month,
                    filmingStartDay: day
                }
            } else {
                // Sin fecha de inicio
                filmingStartDateData = {
                    filmingStartYear: null,
                    filmingStartMonth: null,
                    filmingStartDay: null
                }
            }

            let filmingEndDateData = {}
            if (isPartialFilmingEndDate && partialFilmingEndDate.year) {
                // Fecha parcial de fin
                filmingEndDateData = {
                    filmingEndYear: partialFilmingEndDate.year,
                    filmingEndMonth: partialFilmingEndDate.month,
                    filmingEndDay: null
                }
            } else if (data.filmingEndDate) {
                // Fecha completa de fin
                const [year, month, day] = data.filmingEndDate.split('-').map(Number)
                filmingEndDateData = {
                    filmingEndYear: year,
                    filmingEndMonth: month,
                    filmingEndDay: day
                }
            } else {
                // Sin fecha de fin
                filmingEndDateData = {
                    filmingEndYear: null,
                    filmingEndMonth: null,
                    filmingEndDay: null
                }
            }

            // IMPORTANTE: Eliminar campos de fecha del objeto preparado
            delete preparedData.releaseDate;
            delete preparedData.filmingStartDate;
            delete preparedData.filmingEndDate;

            // DEBUG - Log del cast y crew antes de procesar
            console.log('üé≠ DEBUG - movieRelations.cast antes de procesar:', movieRelations.cast)
            movieRelations.cast.forEach((member, index) => {
                console.log(`üé≠ Cast member ${index}:`, {
                    personId: member.personId,
                    personIdType: typeof member.personId,
                    hasPersonObject: !!member.person,
                    personFromObject: member.person?.id,
                    characterName: member.characterName,
                    alternativeNameId: member.alternativeNameId  // ‚úÖ AGREGADO LOG
                })
            })

            console.log('üé¨ DEBUG - movieRelations.crew antes de procesar:', movieRelations.crew)
            movieRelations.crew.forEach((member, index) => {
                console.log(`üé¨ Crew member ${index}:`, {
                    personId: member.personId,
                    personIdType: typeof member.personId,
                    roleId: member.roleId,
                    roleIdType: typeof member.roleId,
                    roleFromObject: member.role?.id,
                    alternativeNameId: member.alternativeNameId,  // ‚úÖ AGREGADO LOG
                    notes: member.notes,                          // ‚úÖ AGREGADO LOG
                    fullMember: member
                })
            })

            // Construir el objeto completo de datos
            const movieData: any = {
                ...preparedData,
                ...releaseDateData,
                ...filmingStartDateData,
                ...filmingEndDateData,
                // AGREGAR: Convertir 0 a null para duraci√≥n
                duration: preparedData.duration === 0 ? null : preparedData.duration,
                durationSeconds: preparedData.durationSeconds === 0 ? null : preparedData.durationSeconds,
                stage: data.stage || 'COMPLETA',
                ratingId: preparedData.ratingId === '' || preparedData.ratingId === undefined ? null : preparedData.ratingId,
                metaKeywords: preparedData.metaKeywords
                    ? Array.isArray(preparedData.metaKeywords)
                        ? preparedData.metaKeywords
                        : preparedData.metaKeywords.split(',').map((k: string) => k.trim()).filter((k: string) => k)
                    : [],

                // IMPORTANTE: Usar las relaciones del estado, no del data del formulario
                genres: movieRelations.genres.filter(g => g != null && g !== 0 && !isNaN(g)),

                // ‚úÖ PROCESAMIENTO MEJORADO DEL CAST - CON alternativeNameId
                cast: movieRelations.cast
                    .map(member => {
                        // Intentar obtener personId de diferentes fuentes
                        let personId = member.personId

                        // Si no hay personId directo, intentar obtenerlo del objeto person
                        if (!personId && member.person) {
                            personId = member.person.id || member.person.personId
                        }

                        console.log(`üìç Procesando cast member:`, {
                            original: member,
                            extractedPersonId: personId,
                            alternativeNameId: member.alternativeNameId,  // ‚úÖ AGREGADO LOG
                            willInclude: personId && personId > 0
                        })

                        // Solo incluir si hay un personId v√°lido
                        if (!personId || personId <= 0) {
                            return null
                        }

                        return {
                            personId: personId,
                            characterName: member.characterName || '',
                            billingOrder: member.billingOrder ?? 0,
                            isPrincipal: member.isPrincipal ?? false,
                            isActor: member.isActor ?? true,
                            alternativeNameId: member.alternativeNameId || null  // ‚úÖ AGREGADO
                        }
                    })
                    .filter(member => member !== null), // Filtrar los nulls

                // ‚úÖ PROCESAMIENTO MEJORADO DEL CREW - CON alternativeNameId y notes
                crew: movieRelations.crew
                    .map(member => {
                        let personId = member.personId
                        if (!personId && member.person) {
                            personId = member.person.id || member.person.personId
                        }

                        let roleId = member.roleId
                        if (!roleId && member.role && typeof member.role === 'object') {
                            roleId = member.role.id
                        }

                        console.log(`üìç Procesando crew member:`, {
                            original: member,
                            extractedPersonId: personId,
                            extractedRoleId: roleId,
                            alternativeNameId: member.alternativeNameId,  // ‚úÖ AGREGADO LOG
                            notes: member.notes,                          // ‚úÖ AGREGADO LOG
                            willInclude: personId && personId > 0 && roleId && roleId > 0
                        })

                        if (!personId || personId <= 0 || !roleId || roleId <= 0) {
                            return null
                        }

                        return {
                            personId: personId,
                            roleId: roleId,
                            billingOrder: member.billingOrder ?? 0,
                            notes: member.notes || null,                    // ‚úÖ AGREGADO
                            alternativeNameId: member.alternativeNameId || null  // ‚úÖ AGREGADO
                        }
                    })
                    .filter(member => member !== null),

                countries: movieRelations.countries,
                productionCompanies: movieRelations.productionCompanies,
                distributionCompanies: movieRelations.distributionCompanies,
                themes: movieRelations.themes,

                // Screening venues con procesamiento especial
                screeningVenues: movieRelations.screeningVenues.map((venueId, index) => ({
                    venueId,
                    screeningDate: data.releaseDate || new Date().toISOString().split('T')[0],
                    isPremiere: true,
                    isExclusive: movieRelations.screeningVenues.length === 1
                })),

                // Otros campos manejados por estado
                alternativeTitles,
                links: movieLinks
            }

            // Log final antes de enviar
            console.log('üì§ FINAL movieData to send:', {
                cast: movieData.cast,
                crew: movieData.crew
            })

            // Asegurarse de nuevo de que no se env√≠en campos de fecha incorrectos
            delete movieData.releaseDate;
            delete movieData.filmingStartDate;
            delete movieData.filmingEndDate;

            // üî• ASEGURAR QUE NO HAY ID PARA CREACI√ìN
            if (!editingMovie) {
                delete movieData.id;
            }

            // Usar el servicio para crear o actualizar
            let result: Movie;
            if (editingMovie) {
                result = await moviesService.update(editingMovie.id, movieData)
            } else {
                result = await moviesService.create(movieData)
            }

            // Limpiar formulario
            reset()

            // Ejecutar callback de √©xito con la pel√≠cula creada/actualizada
            if (onSuccess) {
                onSuccess(result)
            }

        } catch (error) {
            console.error('‚ùå Error in onSubmit:', error)
            const errorMessage = error instanceof Error ? error.message : 'Error al guardar la pel√≠cula'
            toast.error(errorMessage)

            // Ejecutar callback de error
            if (onError) {
                onError(error instanceof Error ? error : new Error(errorMessage))
            }
        } finally {
            setIsSubmitting(false)
        }
    }

    // Reset para nueva pel√≠cula
    const resetForNewMovie = useCallback(() => {
        reset({
            stage: 'COMPLETA',
            dataCompleteness: 'BASIC_PRESS_KIT',
            synopsisLocked: false,
            metaDescription: '',
            metaKeywords: []
        })
        setIsPartialDate(false)
        setPartialReleaseDate({ year: null, month: null, day: null })
        setIsPartialFilmingStartDate(false)
        setPartialFilmingStartDate({ year: null, month: null, day: null })
        setIsPartialFilmingEndDate(false)
        setPartialFilmingEndDate({ year: null, month: null, day: null })
        setMovieRelations({
            genres: [],
            cast: [],
            crew: [],
            countries: [],
            productionCompanies: [],
            distributionCompanies: [],
            themes: [],
            screeningVenues: []
        })
        setMovieLinks([])
        setAlternativeTitles([])
        setTipoDuracionDisabled(false)
        setActiveTab('basic')
        setMovieFormInitialData(null)
        setIsSubmitting(false)
    }, [reset])

    return {
        onSubmit,

        // Estados de UI
        activeTab,
        setActiveTab,
        isSubmitting,

        // Estados de fechas parciales
        isPartialDate,
        setIsPartialDate,
        partialReleaseDate,
        setPartialReleaseDate,

        // Estados de fechas de rodaje
        isPartialFilmingStartDate,
        setIsPartialFilmingStartDate,
        partialFilmingStartDate,
        setPartialFilmingStartDate,
        isPartialFilmingEndDate,
        setIsPartialFilmingEndDate,
        partialFilmingEndDate,
        setPartialFilmingEndDate,

        // Estados espec√≠ficos de UI
        tipoDuracionDisabled,
        movieFormInitialData,
        alternativeTitles,
        setAlternativeTitles,
        movieLinks,

        // Metadata
        availableRatings,
        availableColorTypes,

        // Callbacks para relaciones
        handleGenresChange,
        handleLinksChange,
        handleCastChange,
        handleCrewChange,
        handleCountriesChange,
        handleProductionCompaniesChange,
        handleDistributionCompaniesChange,
        handleThemesChange,
        handleScreeningVenuesChange,

        // Funciones principales
        loadMovieData,
        resetForNewMovie,

        // Form methods expl√≠citos (todos como any para evitar problemas de tipos)
        register: form.register,
        handleSubmit: form.handleSubmit,
        watch: form.watch,
        setValue: form.setValue,
        reset: form.reset,
        formState: form.formState,
        control: form.control,
        getValues: form.getValues,
        trigger: form.trigger,
        clearErrors: form.clearErrors,
        setError: form.setError,
        setFocus: form.setFocus,
        getFieldState: form.getFieldState,
        resetField: form.resetField,
        unregister: form.unregister
    } as const
}

// ==================================================
// src/hooks/usePageView.ts
// ==================================================
// src/hooks/usePageView.ts
'use client';

import { useEffect, useRef } from 'react';

// Tipos de p√°gina disponibles
export type PageType = 
  | 'HOME'
  | 'MOVIE'
  | 'PERSON'
  | 'EPHEMERIS'
  | 'PERSON_LIST'
  | 'RELEASES'
  | 'OBITUARIES';

interface PageViewOptions {
  pageType: PageType;
  movieId?: number;
  personId?: number;
  extraData?: Record<string, any>;
}

// Generar o recuperar sessionId
function getSessionId(): string {
  if (typeof window === 'undefined') return '';
  
  const SESSION_KEY = 'cn_session_id';
  let sessionId = sessionStorage.getItem(SESSION_KEY);
  
  if (!sessionId) {
    // Generar UUID v4
    sessionId = crypto.randomUUID();
    sessionStorage.setItem(SESSION_KEY, sessionId);
  }
  
  return sessionId;
}

// Funci√≥n para enviar el pageview
async function trackPageView(options: PageViewOptions): Promise<void> {
  try {
    const sessionId = getSessionId();
    
    const payload = {
      ...options,
      sessionId,
    };
    
    // Usar sendBeacon si est√° disponible (no bloquea navegaci√≥n)
    if (navigator.sendBeacon) {
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      navigator.sendBeacon('/api/analytics/pageview', blob);
    } else {
      // Fallback a fetch
      await fetch('/api/analytics/pageview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        keepalive: true, // Permite que la request contin√∫e incluso si el usuario navega
      });
    }
  } catch (error) {
    // Silenciar errores de analytics - no afectar UX
    console.warn('Error tracking pageview:', error);
  }
}

/**
 * Hook para trackear vistas de p√°gina
 * 
 * @example
 * // En p√°gina de pel√≠cula
 * usePageView({ pageType: 'MOVIE', movieId: movie.id });
 * 
 * // En p√°gina de persona
 * usePageView({ pageType: 'PERSON', personId: person.id });
 * 
 * // En home
 * usePageView({ pageType: 'HOME' });
 * 
 * // En listado con filtros
 * usePageView({ 
 *   pageType: 'PERSON_LIST', 
 *   extraData: { filters: { gender: 'FEMALE', decade: '1990' } } 
 * });
 * 
 * // En efem√©rides
 * usePageView({ 
 *   pageType: 'EPHEMERIS', 
 *   extraData: { date: '12-25' } 
 * });
 * 
 * // En estrenos
 * usePageView({ 
 *   pageType: 'RELEASES', 
 *   extraData: { year: 2024 } 
 * });
 */
export function usePageView(options: PageViewOptions): void {
  const hasTracked = useRef(false);
  
  useEffect(() => {
    // Evitar doble tracking en StrictMode o re-renders
    if (hasTracked.current) return;
    
    // No trackear en desarrollo si se prefiere
    // if (process.env.NODE_ENV === 'development') return;
    
    hasTracked.current = true;
    trackPageView(options);
    
    // Cleanup: si el componente se desmonta antes de trackear, permitir re-track
    return () => {
      // No reseteamos hasTracked para evitar double-tracking
    };
  }, [options.pageType, options.movieId, options.personId]);
}

/**
 * Funci√≥n utilitaria para trackear manualmente (sin hook)
 * √ötil para eventos espec√≠ficos o tracking condicional
 */
export { trackPageView };

// ==================================================
// src/hooks/usePeople.ts
// ==================================================
// src/hooks/usePeople.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import { useDebounce } from '@/hooks/useDebounce';
import { peopleService } from '@/services/people.service';
import { 
  PersonWithRelations,
  PersonFilters,
  PaginatedPeopleResponse 
} from '@/lib/people/peopleTypes';
import { PEOPLE_PAGINATION } from '@/lib/people/peopleConstants';
import { toast } from 'react-hot-toast';

interface UsePeopleOptions {
  autoLoad?: boolean;
  initialFilters?: PersonFilters;
}

export function usePeople(options: UsePeopleOptions = {}) {
  const { autoLoad = true, initialFilters = {} } = options;
  
  // Estado
  const [people, setPeople] = useState<PersonWithRelations[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [totalCount, setTotalCount] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  
  // Referencia para el AbortController
  const abortControllerRef = useRef<AbortController | null>(null);
  
  // Filtros
  const [filters, setFilters] = useState<PersonFilters>({
    page: PEOPLE_PAGINATION.DEFAULT_PAGE,
    limit: PEOPLE_PAGINATION.DEFAULT_LIMIT,
    sortBy: 'updatedAt',
    sortOrder: 'desc',
    ...initialFilters,
  });
  
  // Debounce para b√∫squeda - aumentamos a 400ms para dar m√°s tiempo cuando se escribe r√°pido
  const debouncedSearch = useDebounce(filters.search || '', 400);

  // Cargar personas con cancelaci√≥n de requests anteriores
  const loadPeople = useCallback(async () => {
    try {
      // Cancelar request anterior si existe
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      
      // Crear nuevo AbortController
      abortControllerRef.current = new AbortController();
      
      setLoading(true);
      setError(null);
      
      const response = await peopleService.getAll({
        ...filters,
        search: debouncedSearch,
      }, abortControllerRef.current.signal); // Pasar el signal al servicio
      
      // Solo actualizar el estado si no fue cancelado
      if (!abortControllerRef.current.signal.aborted) {
        setPeople(response.data);
        setTotalCount(response.totalCount);
        setTotalPages(response.totalPages);
        setHasMore(response.hasMore);
      }
    } catch (err: any) {
      // Ignorar errores de cancelaci√≥n
      if (err?.name === 'AbortError') {
        console.log('Request cancelado');
        return;
      }
      
      console.error('Error loading people:', err);
      setError(err as Error);
      
      // Solo mostrar toast si no es un error de cancelaci√≥n
      if (!abortControllerRef.current?.signal.aborted) {
        toast.error('No se pudieron cargar las personas');
      }
    } finally {
      // Solo quitar loading si no fue cancelado
      if (!abortControllerRef.current?.signal.aborted) {
        setLoading(false);
      }
    }
  }, [filters, debouncedSearch]);

  // Cleanup al desmontar el componente
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Efecto para cargar personas
  useEffect(() => {
    if (autoLoad) {
      loadPeople();
    }
    
    // Cleanup al cambiar los filtros
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [loadPeople, autoLoad]);

  // Actualizar un filtro espec√≠fico
  const updateFilter = useCallback(<K extends keyof PersonFilters>(
    key: K,
    value: PersonFilters[K]
  ) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      // Resetear a p√°gina 1 cuando cambian otros filtros
      ...(key !== 'page' && { page: 1 }),
    }));
  }, []);

  // Resto del c√≥digo permanece igual...
  const updateFilters = useCallback((newFilters: Partial<PersonFilters>) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters,
      ...(!newFilters.page && { page: 1 }),
    }));
  }, []);

  const resetFilters = useCallback(() => {
    setFilters({
      page: PEOPLE_PAGINATION.DEFAULT_PAGE,
      limit: PEOPLE_PAGINATION.DEFAULT_LIMIT,
    });
  }, []);

  const goToPage = useCallback((page: number) => {
    updateFilter('page', page);
  }, [updateFilter]);

  const deletePerson = useCallback(async (id: number) => {
    try {
      await peopleService.delete(id);
      toast.success('Persona eliminada correctamente');
      await loadPeople();
    } catch (err) {
      console.error('Error deleting person:', err);
      const errorMessage = err instanceof Error 
        ? err.message 
        : 'Error al eliminar persona';
      toast.error(errorMessage);
      throw err;
    }
  }, [loadPeople]);

  const exportToCSV = useCallback(async () => {
    try {
      const blob = await peopleService.exportToCSV(filters);
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `personas-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      toast.success('Archivo CSV descargado correctamente');
    } catch (err) {
      console.error('Error exporting to CSV:', err);
      toast.error('No se pudo exportar a CSV');
    }
  }, [filters]);

  return {
    people,
    totalCount,
    totalPages,
    hasMore,
    currentPage: filters.page || 1,
    pageSize: filters.limit || PEOPLE_PAGINATION.DEFAULT_LIMIT,
    loading,
    error,
    filters,
    loadPeople,
    updateFilter,
    updateFilters,
    resetFilters,
    goToPage,
    deletePerson,
    exportToCSV,
    goToNextPage: () => goToPage((filters.page || 1) + 1),
    goToPreviousPage: () => goToPage(Math.max(1, (filters.page || 1) - 1)),
    canGoNext: hasMore,
    canGoPrevious: (filters.page || 1) > 1,
  };
}

// Los otros hooks (usePeopleSearch y usePerson) permanecen igual...

// Hook para b√∫squeda simple (autocomplete)
export function usePeopleSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<Array<{ id: number; name: string; slug?: string }>>([]);
  const [loading, setLoading] = useState(false);

  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    const searchPeople = async () => {
      if (debouncedQuery.length < 2) {
        setResults([]);
        return;
      }

      try {
        setLoading(true);
        const data = await peopleService.search(debouncedQuery);
        setResults(data);
      } catch (error) {
        console.error('Error searching people:', error);
        setResults([]);
      } finally {
        setLoading(false);
      }
    };

    searchPeople();
  }, [debouncedQuery]);

  return {
    query,
    setQuery,
    results,
    loading,
    clearResults: () => setResults([]),
  };
}

// Hook para una persona individual
export function usePerson(id: number | string | null) {
  const [person, setPerson] = useState<PersonWithRelations | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchPerson = async () => {
      if (!id || id === 'new') {
        setPerson(null);
        return;
      }

      try {
        setLoading(true);
        setError(null);
        const personId = typeof id === 'string' ? parseInt(id) : id;
        const data = await peopleService.getById(personId);
        setPerson(data);
      } catch (err) {
        console.error('Error loading person:', err);
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchPerson();
  }, [id]);

  const reload = useCallback(async () => {
    if (!id || id === 'new') return;

    try {
      setLoading(true);
      const personId = typeof id === 'string' ? parseInt(id) : id;
      const data = await peopleService.getById(personId);
      setPerson(data);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [id]);

  return { person, loading, error, reload };
}

// ==================================================
// src/hooks/usePeopleForm.ts
// ==================================================
// src/hooks/usePeopleForm.ts

import { useState, useCallback, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { peopleService } from '@/services/people.service';
import {
    PersonFormData,
    PersonWithRelations,
    PersonLink
} from '@/lib/people/peopleTypes';
import {
    DEFAULT_PERSON_FORM_VALUES,
    PERSON_ERROR_MESSAGES,
    PERSON_SUCCESS_MESSAGES
} from '@/lib/people/peopleConstants';
import {
    formatPersonDataForForm,
    validatePersonForm,
    addNewPersonLink,
    updatePersonLink,
    removePersonLink
} from '@/lib/people/peopleUtils';
import { toast } from 'react-hot-toast';

interface UsePeopleFormProps {
    personId?: number;
    onSuccess?: (person: PersonWithRelations) => void;
}

export function usePeopleForm({ personId, onSuccess }: UsePeopleFormProps = {}) {
    const router = useRouter();
    const [loading, setLoading] = useState(false);
    const [saving, setSaving] = useState(false);
    const [formData, setFormData] = useState<PersonFormData>(DEFAULT_PERSON_FORM_VALUES);
    const [errors, setErrors] = useState<string[]>([]);
    const [isDirty, setIsDirty] = useState(false);

    // Cargar datos de la persona si es edici√≥n
    useEffect(() => {
        if (personId) {
            loadPerson();
        }
    }, [personId]);

    // Cargar persona existente
    const loadPerson = async () => {
        if (!personId) return;

        try {
            setLoading(true);
            const person = await peopleService.getById(personId);
            console.log('usePeopleForm - Raw person from getById:', person);
            const formattedData = formatPersonDataForForm(person);

            // NUEVO: Agregar el ID al formData para saber que es edici√≥n
            formattedData.id = personId;

            // NUEVO: Preservar el photoPublicId si existe
            if (person.photoPublicId) {
                formattedData.photoPublicId = person.photoPublicId;
            }

            // Si la persona tiene links, cargarlos tambi√©n
            if (person.links) {
                formattedData.links = person.links;
            }

            // Si la persona tiene nombres alternativos, cargarlos tambi√©n
            if (person.alternativeNames) {
                formattedData.alternativeNames = person.alternativeNames;
            }

            // Si la persona tiene nacionalidades, cargarlas como array de IDs
            if (person.nationalities && Array.isArray(person.nationalities)) {
                formattedData.nationalities = person.nationalities.map((n: any) => {
                    if (typeof n === 'number') {
                        return n;
                    }
                    if (typeof n === 'object' && n !== null) {
                        const id = n.locationId || n;
                        return id;
                    }
                    return n;
                });
            } else {
                formattedData.nationalities = [];
            }

            setFormData(formattedData);
        } catch (error) {
            console.error('Error loading person:', error);
            toast.error('No se pudo cargar la informaci√≥n de la persona');
        } finally {
            setLoading(false);
        }
    };

    // Actualizar campo del formulario
    const updateField = useCallback(<K extends keyof PersonFormData>(
        field: K,
        value: PersonFormData[K]
    ) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        setIsDirty(true);
        setErrors([]); // Limpiar errores al modificar
    }, []);

    // Actualizar m√∫ltiples campos
    const updateFields = useCallback((updates: Partial<PersonFormData>) => {
        setFormData(prev => ({ ...prev, ...updates }));
        setIsDirty(true);
        setErrors([]);
    }, []);

    // Manejo de links
    const addLink = useCallback(() => {
        setFormData(prev => ({
            ...prev,
            links: addNewPersonLink(prev.links)
        }));
        setIsDirty(true);
    }, []);

    const updateLink = useCallback((index: number, updates: Partial<PersonLink>) => {
        setFormData(prev => ({
            ...prev,
            links: updatePersonLink(prev.links, index, updates)
        }));
        setIsDirty(true);
    }, []);

    const removeLink = useCallback((index: number) => {
        setFormData(prev => ({
            ...prev,
            links: removePersonLink(prev.links, index)
        }));
        setIsDirty(true);
    }, []);

    // Manejo de nacionalidades
    const updateNationalities = useCallback((nationalities: number[]) => {
        setFormData(prev => ({
            ...prev,
            nationalities
        }));
        setIsDirty(true);
        setErrors([]);
    }, []);

    // Validar formulario
    const validate = useCallback((): boolean => {
        const validationErrors = validatePersonForm(formData);
        setErrors(validationErrors);
        return validationErrors.length === 0;
    }, [formData]);

    // Guardar persona
    const save = useCallback(async () => {
        console.log('FormData before save:', formData);
        console.log('Birth Location ID:', formData.birthLocationId);
        console.log('Death Location ID:', formData.deathLocationId);
        console.log('Nationalities:', formData.nationalities); // Log de nacionalidades

        if (!validate()) {
            toast.error('Por favor corrige los errores en el formulario');
            return false;
        }

        try {
            setSaving(true);
            let savedPerson: PersonWithRelations;

            // Preparar datos para enviar
            const dataToSave = {
                ...formData,
                nationalities: formData.nationalities || []
            };

            if (personId) {
                savedPerson = await peopleService.update(personId, dataToSave);
                toast.success(PERSON_SUCCESS_MESSAGES.UPDATED);
            } else {
                savedPerson = await peopleService.create(dataToSave);
                toast.success(PERSON_SUCCESS_MESSAGES.CREATED);
            }

            setIsDirty(false);

            if (onSuccess) {
                onSuccess(savedPerson);
            } else {
                router.push('/admin/people');
            }

            return true;
        } catch (error) {
            console.error('Error saving person:', error);

            const errorMessage = error instanceof Error
                ? error.message
                : personId ? PERSON_ERROR_MESSAGES.UPDATE_ERROR : PERSON_ERROR_MESSAGES.CREATE_ERROR;

            toast.error(errorMessage);

            return false;
        } finally {
            setSaving(false);
        }
    }, [formData, personId, validate, router, onSuccess]);

    // Resetear formulario
    const reset = useCallback(() => {
        setFormData(DEFAULT_PERSON_FORM_VALUES);
        setErrors([]);
        setIsDirty(false);
    }, []);

    // Cancelar y volver
    const cancel = useCallback(() => {
        if (isDirty) {
            const confirmed = window.confirm('¬øEst√°s seguro? Se perder√°n los cambios no guardados.');
            if (!confirmed) return;
        }
        router.push('/admin/people');
    }, [isDirty, router]);

    return {
        // Estado
        formData,
        loading,
        saving,
        errors,
        isDirty,
        isEdit: !!personId,

        // Acciones
        updateField,
        updateFields,
        updateNationalities, // Nueva funci√≥n para actualizar nacionalidades
        addLink,
        updateLink,
        removeLink,
        save,
        reset,
        cancel,
        reload: loadPerson,
    };
}

// ==================================================
// src/hooks/useRoles.ts
// ==================================================
// src/hooks/useRoles.ts

import { useState, useEffect, useCallback } from 'react';
import { rolesService } from '@/services/roles.service';
import type { 
  Role, 
  RoleFilters, 
  PaginatedRolesResponse,
  Department 
} from '@/lib/roles/rolesTypes';
import { useDebounce } from './useDebounce';

interface UseRolesReturn {
  // Datos
  roles: Role[];
  totalCount: number;
  totalPages: number;
  hasMore: boolean;
  currentPage: number;
  pageSize: number;
  
  // Estado
  loading: boolean;
  error: Error | null;
  filters: RoleFilters;
  
  // Acciones principales
  loadRoles: () => Promise<void>;
  deleteRole: (id: number) => Promise<void>;
  exportToCSV: () => Promise<void>;
  seedDefault: () => Promise<{ created: number; skipped: number }>;
  
  // Gesti√≥n de filtros
  updateFilter: <K extends keyof RoleFilters>(key: K, value: RoleFilters[K]) => void;
  updateFilters: (filters: Partial<RoleFilters>) => void;
  resetFilters: () => void;
  
  // Navegaci√≥n
  goToPage: (page: number) => void;
  goToNextPage: () => void;
  goToPreviousPage: () => void;
  canGoNext: boolean;
  canGoPrevious: boolean;
}

const defaultFilters: RoleFilters = {
  search: '',
  department: '',
  isActive: '',
  isMainRole: '',
  page: 1,
  limit: 20
};

export function useRoles(): UseRolesReturn {
  const [roles, setRoles] = useState<Role[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [filters, setFilters] = useState<RoleFilters>(defaultFilters);

  // Debounce search para evitar requests excesivos
  const debouncedSearch = useDebounce(filters.search || '', 300);

  const loadRoles = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const filtersToSend = {
        ...filters,
        search: debouncedSearch
      };
      
      const response: PaginatedRolesResponse = await rolesService.getAll(filtersToSend);
      
      setRoles(response.data);
      setTotalCount(response.totalCount);
      setTotalPages(response.totalPages);
      setHasMore(response.hasMore);
      
    } catch (err) {
      console.error('Error loading roles:', err);
      setError(err instanceof Error ? err : new Error('Error desconocido'));
      setRoles([]);
      setTotalCount(0);
      setTotalPages(0);
      setHasMore(false);
    } finally {
      setLoading(false);
    }
  }, [filters, debouncedSearch]);

  // Cargar roles cuando cambien los filtros
  useEffect(() => {
    loadRoles();
  }, [loadRoles]);

  // Reset a p√°gina 1 cuando cambien filtros (excepto page)
  useEffect(() => {
    if (filters.page !== 1) {
      setFilters(prev => ({ ...prev, page: 1 }));
    }
  }, [debouncedSearch, filters.department, filters.isActive, filters.isMainRole]);

  const deleteRole = useCallback(async (id: number) => {
    await rolesService.delete(id);
    await loadRoles(); // Recargar lista
  }, [loadRoles]);

  const exportToCSV = useCallback(async () => {
    const blob = await rolesService.exportToCSV(filters);
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `roles_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }, [filters]);

  const seedDefault = useCallback(async () => {
    const result = await rolesService.seedDefault();
    await loadRoles(); // Recargar lista
    return result;
  }, [loadRoles]);

  const updateFilter = useCallback(<K extends keyof RoleFilters>(
    key: K, 
    value: RoleFilters[K]
  ) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      // Reset page cuando no sea un cambio de p√°gina
      ...(key !== 'page' ? { page: 1 } : {})
    }));
  }, []);

  const updateFilters = useCallback((newFilters: Partial<RoleFilters>) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters,
      page: 1 // Reset page en cambios m√∫ltiples
    }));
  }, []);

  const resetFilters = useCallback(() => {
    setFilters(defaultFilters);
  }, []);

  const goToPage = useCallback((page: number) => {
    if (page >= 1 && page <= totalPages) {
      updateFilter('page', page);
    }
  }, [totalPages, updateFilter]);

  const goToNextPage = useCallback(() => {
    if (hasMore) {
      goToPage((filters.page || 1) + 1);
    }
  }, [hasMore, filters.page, goToPage]);

  const goToPreviousPage = useCallback(() => {
    if ((filters.page || 1) > 1) {
      goToPage((filters.page || 1) - 1);
    }
  }, [filters.page, goToPage]);

  const canGoNext = hasMore;
  const canGoPrevious = (filters.page || 1) > 1;
  const currentPage = filters.page || 1;
  const pageSize = filters.limit || 20;

  return {
    // Datos
    roles,
    totalCount,
    totalPages,
    hasMore,
    currentPage,
    pageSize,
    
    // Estado
    loading,
    error,
    filters,
    
    // Acciones principales
    loadRoles,
    deleteRole,
    exportToCSV,
    seedDefault,
    
    // Gesti√≥n de filtros
    updateFilter,
    updateFilters,
    resetFilters,
    
    // Navegaci√≥n
    goToPage,
    goToNextPage,
    goToPreviousPage,
    canGoNext,
    canGoPrevious
  };
}

// ==================================================
// src/lib/estrenos/estrenosTypes.ts
// ==================================================
// src/lib/estrenos/estrenosTypes.ts

export type DecadePeriod = 'all' | 'upcoming' | string; // '2020s', '2010s', etc.

export interface EstrenosFilters {
  period: DecadePeriod;
  year: number | null;
  page: number;
  limit: number;
}

export interface Decade {
  id: string;
  label: string;
  startYear: number;
  endYear: number;
  years: number[];
}

export interface EstrenosResponse {
  movies: any[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  filters: {
    period: DecadePeriod;
    year: number | null;
  };
}

// ==================================================
// src/lib/estrenos/estrenosUtils.ts
// ==================================================
// src/lib/estrenos/estrenosUtils.ts

import { Decade, DecadePeriod } from './estrenosTypes';

/**
 * Genera la lista de d√©cadas desde 1890 hasta la d√©cada actual
 */
export function generateDecades(): Decade[] {
  const currentYear = new Date().getFullYear();
  const currentDecadeStart = Math.floor(currentYear / 10) * 10;
  
  const decades: Decade[] = [];
  
  // Desde 1890 hasta la d√©cada actual
  for (let decadeStart = 1890; decadeStart <= currentDecadeStart; decadeStart += 10) {
    const decadeEnd = decadeStart + 9;
    const years = Array.from({ length: 10 }, (_, i) => decadeStart + i);
    
    decades.push({
      id: `${decadeStart}s`,
      label: `${decadeStart}s`,
      startYear: decadeStart,
      endYear: decadeEnd,
      years
    });
  }
  
  // Ordenar de m√°s reciente a m√°s antigua
  return decades.reverse();
}

/**
 * Obtiene la d√©cada actual
 */
export function getCurrentDecade(): Decade {
  const currentYear = new Date().getFullYear();
  const decadeStart = Math.floor(currentYear / 10) * 10;
  const decadeEnd = decadeStart + 9;
  const years = Array.from({ length: 10 }, (_, i) => decadeStart + i);
  
  return {
    id: `${decadeStart}s`,
    label: `${decadeStart}s`,
    startYear: decadeStart,
    endYear: decadeEnd,
    years
  };
}

/**
 * Encuentra una d√©cada por su ID
 */
export function getDecadeById(decadeId: string): Decade | null {
  if (decadeId === 'all' || decadeId === 'upcoming') {
    return null;
  }
  
  const decades = generateDecades();
  return decades.find(d => d.id === decadeId) || null;
}

/**
 * Obtiene el a√±o actual
 */
export function getCurrentYear(): number {
  return new Date().getFullYear();
}

/**
 * Verifica si un a√±o est√° en el futuro
 */
export function isFutureYear(year: number): boolean {
  return year > getCurrentYear();
}

/**
 * Formatea el per√≠odo para mostrar en la UI
 */
export function formatPeriodLabel(period: DecadePeriod, year: number | null): string {
  if (period === 'all') {
    return 'Todos los estrenos de la historia';
  }
  
  if (period === 'upcoming') {
    return 'Pr√≥ximos estrenos';
  }
  
  if (year) {
    return `Estrenos de ${year}`;
  }
  
  // Si es una d√©cada sin a√±o espec√≠fico
  const decade = getDecadeById(period);
  if (decade) {
    return `Estrenos de los ${decade.label}`;
  }
  
  return 'Estrenos';
}

/**
 * Convierte el per√≠odo a filtros de API
 */
export function periodToApiFilters(period: DecadePeriod, year: number | null): {
  year?: string;
  yearFrom?: string;
  yearTo?: string;
  upcoming?: string;
} {
  if (period === 'upcoming') {
    return { upcoming: 'true' };
  }
  
  if (year) {
    return { year: year.toString() };
  }
  
  if (period !== 'all') {
    const decade = getDecadeById(period);
    if (decade) {
      return {
        yearFrom: decade.startYear.toString(),
        yearTo: decade.endYear.toString()
      };
    }
  }
  
  return {};
}

// ==================================================
// src/lib/images/imageTypes.ts
// ==================================================
// src/lib/images/imageTypes.ts
import { z } from 'zod'

// Enum que coincide con Prisma
export const ImageType = {
  STILL: 'STILL',
  BEHIND_THE_SCENES: 'BEHIND_THE_SCENES',
  PUBLICITY: 'PUBLICITY',
  EVENT: 'EVENT',
  PREMIERE: 'PREMIERE'
} as const

export type ImageType = typeof ImageType[keyof typeof ImageType]

// Labels para mostrar en UI
export const IMAGE_TYPE_LABELS: Record<ImageType, string> = {
  STILL: 'Fotograma',
  BEHIND_THE_SCENES: 'Detr√°s de escena',
  PUBLICITY: 'Foto promocional',
  EVENT: 'Evento',
  PREMIERE: 'Estreno'
}

// Tipos disponibles desde ABM de pel√≠culas (sin EVENT que no tiene pel√≠cula asociada)
export const MOVIE_IMAGE_TYPES: ImageType[] = [
  'STILL',
  'BEHIND_THE_SCENES', 
  'PUBLICITY',
  'PREMIERE'
]

// Persona en una imagen
export interface ImagePerson {
  id?: number
  personId: number
  position: number
  person?: {
    id: number
    firstName?: string | null
    lastName?: string | null
  }
}

// Imagen completa con relaciones
export interface ImageWithRelations {
  id: number
  cloudinaryPublicId: string
  type: ImageType
  photoDate?: string | null
  photographerCredit?: string | null
  eventName?: string | null
  movieId?: number | null
  movie?: {
    id: number
    title: string
    releaseYear?: number | null
  } | null
  people: ImagePerson[]
  createdAt: string
  updatedAt: string
}

// Para crear/editar imagen
export interface ImageFormData {
  cloudinaryPublicId: string
  type: ImageType
  photoDate?: string | null
  photographerCredit?: string | null
  eventName?: string | null
  movieId?: number | null
  people?: Array<{
    personId: number
    position: number
  }>
}

// Schema de validaci√≥n
export const imageFormSchema = z.object({
  cloudinaryPublicId: z.string().min(1, 'La imagen es requerida'),
  type: z.enum(['STILL', 'BEHIND_THE_SCENES', 'PUBLICITY', 'EVENT', 'PREMIERE']),
  photoDate: z.string().nullable().optional(),
  photographerCredit: z.string().nullable().optional(),
  eventName: z.string().nullable().optional(),
  movieId: z.number().nullable().optional(),
  people: z.array(z.object({
    personId: z.number(),
    position: z.number()
  })).optional()
})

// Respuesta paginada
export interface PaginatedImagesResponse {
  data: ImageWithRelations[]
  totalCount: number
  page: number
  totalPages: number
  hasMore: boolean
}

// ==================================================
// src/lib/images/imageUtils.ts
// ==================================================
// src/lib/images/imageUtils.ts
import { ImageWithRelations, IMAGE_TYPE_LABELS } from './imageTypes'

const CLOUDINARY_CLOUD_NAME = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME

/**
 * Genera el caption autom√°tico para una imagen
 */
export function generateImageCaption(image: ImageWithRelations): string {
  const parts: string[] = []
  
  // 1. Personas ordenadas por posici√≥n
  if (image.people && image.people.length > 0) {
    const sortedPeople = [...image.people].sort((a, b) => a.position - b.position)
    const names = sortedPeople
      .map(ip => {
        if (!ip.person) return null
        const { firstName, lastName } = ip.person
        return [firstName, lastName].filter(Boolean).join(' ')
      })
      .filter(Boolean) as string[]
    
    if (names.length === 1) {
      parts.push(names[0])
    } else if (names.length === 2) {
      parts.push(`${names[0]} y ${names[1]}`)
    } else if (names.length > 2) {
      const lastPerson = names.pop()
      parts.push(`${names.join(', ')} y ${lastPerson}`)
    }
  }
  
  // 2. Contexto seg√∫n tipo y pel√≠cula
  const movieYear = image.movie?.releaseYear
  const movieRef = image.movie 
    ? `${image.movie.title}${movieYear ? ` (${movieYear})` : ''}`
    : null
  
  const hasNames = parts.length > 0
  
  switch (image.type) {
    case 'STILL':
      if (movieRef) {
        parts.push(hasNames ? `en ${movieRef}` : `Fotograma de ${movieRef}`)
      }
      break
      
    case 'BEHIND_THE_SCENES':
      if (movieRef) {
        parts.push(hasNames ? `en el rodaje de ${movieRef}` : `Detr√°s de escena de ${movieRef}`)
      }
      break
      
    case 'PUBLICITY':
      if (movieRef) {
        parts.push(hasNames ? `en foto promocional de ${movieRef}` : `Foto promocional de ${movieRef}`)
      }
      break
      
    case 'PREMIERE':
      if (movieRef) {
        parts.push(hasNames ? `en el estreno de ${movieRef}` : `Estreno de ${movieRef}`)
      }
      if (image.eventName) {
        parts.push(`(${image.eventName})`)
      }
      break
      
    case 'EVENT':
      if (image.eventName) {
        parts.push(hasNames ? `en ${image.eventName}` : image.eventName)
      }
      break
  }
  
  return parts.join(' ') || 'Sin descripci√≥n'
}

/**
 * Genera URL de Cloudinary con transformaciones
 */
interface CloudinaryTransformOptions {
  width?: number
  height?: number
  crop?: 'fill' | 'fit' | 'scale' | 'thumb' | 'limit'
  quality?: number | 'auto'
  format?: 'auto' | 'webp' | 'jpg' | 'png'
  gravity?: 'auto' | 'face' | 'center'
}

export function getCloudinaryUrl(
  publicId: string, 
  options: CloudinaryTransformOptions = {}
): string {
  const {
    width,
    height,
    crop = 'fill',
    quality = 'auto',
    format = 'auto',
    gravity = 'auto'
  } = options
  
  const transforms: string[] = []
  
  if (width) transforms.push(`w_${width}`)
  if (height) transforms.push(`h_${height}`)
  if (width || height) {
    transforms.push(`c_${crop}`)
    transforms.push(`g_${gravity}`)
  }
  transforms.push(`q_${quality}`)
  transforms.push(`f_${format}`)
  
  const transformString = transforms.join(',')
  
  return `https://res.cloudinary.com/${CLOUDINARY_CLOUD_NAME}/image/upload/${transformString}/${publicId}`
}

// Presets comunes para im√°genes de pel√≠culas
export const imagePresets = {
  thumbnail: (publicId: string) => 
    getCloudinaryUrl(publicId, { width: 150, height: 100, crop: 'fill' }),
  
  card: (publicId: string) => 
    getCloudinaryUrl(publicId, { width: 400, height: 267, crop: 'fill' }),
  
  gallery: (publicId: string) => 
    getCloudinaryUrl(publicId, { width: 800, height: 533, crop: 'fill' }),
  
  full: (publicId: string) => 
    getCloudinaryUrl(publicId, { width: 1200, crop: 'limit' }),
}

/**
 * Obtiene el label del tipo de imagen
 */
export function getImageTypeLabel(type: string): string {
  return IMAGE_TYPE_LABELS[type as keyof typeof IMAGE_TYPE_LABELS] || type
}

// ==================================================
// src/lib/movies/movieConstants.ts
// ==================================================
// src/lib/movies/movieConstants.ts

export { MONTHS } from '@/lib/shared/dateUtils';

/**
 * Estados posibles de producci√≥n de una pel√≠cula
 * @constant
 * @type {Array<{value: string, label: string}>}
 */
export const MOVIE_STAGES = [
  { value: 'COMPLETA', label: 'Completa', description: 'Pel√≠cula terminada y estrenada' },
  { value: 'EN_DESARROLLO', label: 'En desarrollo', description: 'En etapa de desarrollo del proyecto' },
  { value: 'EN_POSTPRODUCCION', label: 'En postproducci√≥n', description: 'En proceso de edici√≥n y postproducci√≥n' },
  { value: 'EN_PREPRODUCCION', label: 'En preproducci√≥n', description: 'En preparaci√≥n para el rodaje' },
  { value: 'EN_RODAJE', label: 'En rodaje', description: 'Actualmente filmando' },
  { value: 'INCONCLUSA', label: 'Inconclusa', description: 'Proyecto abandonado o sin terminar' },
  { value: 'INEDITA', label: 'In√©dita', description: 'Completa pero sin estrenar' }
] as const

export const POSTER_PLACEHOLDER = {
  default: 'poster-placeholder-dark.jpg',
  cloudinaryUrl: '/images/poster-placeholder-dark.jpg'  // ‚Üê Ruta local desde public
} as const;

export const BACKGROUND_PLACEHOLDER = {
  url: '/images/background-placeholder.jpg'  // ‚Üê Agregar esta nueva constante
} as const;

export const POSTER_ASPECT_RATIO = 2/3;
export const POSTER_SIZES = {
  thumbnail: { width: 200, height: 300 },
  card: { width: 342, height: 513 },
  full: { width: 500, height: 750 }
} as const;

/**
 * TIPOS_DURACION
 * @TODO Add documentation
 */
export const TIPOS_DURACION = [
  { value: 'largometraje', label: 'Largometraje' },
  { value: 'mediometraje', label: 'Mediometraje' },
  { value: 'cortometraje', label: 'Cortometraje' }
] as const

/**
 * DATA_COMPLETENESS_LEVELS
 * @TODO Add documentation
 */
export const DATA_COMPLETENESS_LEVELS = [
  { value: 'BASIC_PRESS_KIT', label: 'Gacetilla b√°sica', icon: 'üìÑ' },
  { value: 'FULL_PRESS_KIT', label: 'Gacetilla completa', icon: 'üìã' },
  { value: 'MAIN_CAST', label: 'Int√©rpretes principales', icon: 'üë•' },
  { value: 'MAIN_CREW', label: 'T√©cnicos principales', icon: 'üîß' },
  { value: 'FULL_CAST', label: 'Todos los int√©rpretes', icon: 'üé≠' },
  { value: 'FULL_CREW', label: 'Todos los t√©cnicos', icon: 'üé¨' }
] as const

/**
 * SOUND_TYPES
 * @TODO Add documentation
 */
export const SOUND_TYPES = [
  { value: 'Sonora', label: 'Sonora' },
  { value: 'Muda', label: 'Muda' },
  { value: 'n/d', label: 'No disponible' }
] as const

// Duraciones en minutos
/**
 * DURATION_THRESHOLDS
 * @TODO Add documentation
 */
export const DURATION_THRESHOLDS = {
  LARGOMETRAJE: 60,
  MEDIOMETRAJE: 30
} as const

// Colores para los badges
/**
 * STAGE_COLORS
 * @TODO Add documentation
 */
export const STAGE_COLORS = {
  COMPLETA: 'bg-green-100 text-green-800',
  EN_DESARROLLO: 'bg-blue-100 text-blue-800',
  EN_POSTPRODUCCION: 'bg-purple-100 text-purple-800',
  EN_PREPRODUCCION: 'bg-yellow-100 text-yellow-800',
  EN_RODAJE: 'bg-orange-100 text-orange-800',
  INCONCLUSA: 'bg-red-100 text-red-800',
  INEDITA: 'bg-gray-100 text-gray-800'
} as const

/**
 * COMPLETENESS_COLORS
 * @TODO Add documentation
 */
export const COMPLETENESS_COLORS = {
  BASIC_PRESS_KIT: 'bg-red-100 text-red-800',
  FULL_PRESS_KIT: 'bg-orange-100 text-orange-800',
  MAIN_CAST: 'bg-yellow-100 text-yellow-800',
  MAIN_CREW: 'bg-green-100 text-green-800',
  FULL_CAST: 'bg-green-100 text-green-800',
  FULL_CREW: 'bg-blue-100 text-blue-800'
} as const

// ==================================================
// src/lib/movies/movieTypes.ts
// ==================================================
// src/lib/movies/movieTypes.ts

import { z } from 'zod'
import { PartialDate } from '@/lib/shared/dateUtils'

// ============================================================================
// TIPOS REUTILIZABLES
// ============================================================================

// Usar el tipo compartido de PartialDate
export type PartialReleaseDate = PartialDate
export type PartialFilmingDate = PartialDate

// ============================================================================
// SCHEMAS DE VALIDACI√ìN
// ============================================================================

// Schema para campos del formulario (solo campos que se manejan con register)
export const movieFormFieldsSchema = z.object({
  // Campos requeridos
  title: z.string().min(1, 'El t√≠tulo es requerido'),

  // Informaci√≥n b√°sica
  originalTitle: z.string().optional(),
  synopsis: z.string().optional(),
  synopsisLocked: z.boolean().optional().default(false),
  notes: z.string().optional(),
  tagline: z.string().optional(),
  imdbId: z.string().optional(),
  aspectRatio: z.string().optional(),
  soundType: z.string().optional(),
  filmFormat: z.string().optional(),
  certificateNumber: z.string().optional(),
  tipoDuracion: z.string().optional(),

  // Campos num√©ricos
  year: z.number().nullable().optional(),
  duration: z.preprocess(
    (val) => {
      if (val === '' || val === null || val === undefined || val === 0|| isNaN(Number(val))) {
        return null;
      }
      return Number(val);
    },
    z.number().positive().nullable().optional()
  ),
  durationSeconds: z.preprocess(
    (val) => {
      if (val === '' || val === null || val === undefined || val === 0 || isNaN(Number(val))) {
        return null;
      }
      const num = Number(val);
      return num ===0 || num < 0 || num > 59 ? num : null;
    },
    z.number().min(1).max(59).nullable().optional()
  ),
  colorTypeId: z.number().nullable().optional(),
  ratingId: z.union([
    z.number().positive(),
    z.null(),
    z.literal(0).transform(() => null)
  ]).optional(),

  // Campos de fecha
  releaseDate: z.string().optional(),
  filmingStartDate: z.string().optional(),
  filmingEndDate: z.string().optional(),

  // Producci√≥n
  countries: z.array(z.string()).optional(),
  is_coproduction: z.boolean().optional(),
  production_type: z.string().optional(),

  // URLs
  posterUrl: z.string().optional(),
  posterPublicId: z.string().optional(),
  backdropUrl: z.string().optional(),
  backdropPublicId: z.string().optional(),
  trailerUrl: z.string().optional(),

  // Metadata - con transformaciones para evitar null
  metaDescription: z.union([
    z.string(),
    z.null(),
    z.undefined()
  ]).transform(val => val ?? '').optional(),

  metaKeywords: z.union([
    z.string(),
    z.array(z.string()),
    z.null(),
    z.undefined()
  ]).transform(val => val ?? []).optional(),

  // Enums
  dataCompleteness: z.enum([
    'BASIC_PRESS_KIT',
    'FULL_PRESS_KIT',
    'MAIN_CAST',
    'MAIN_CREW',
    'FULL_CAST',
    'FULL_CREW'
  ]).optional(),

  stage: z.enum([
    'COMPLETA',
    'EN_DESARROLLO',
    'EN_POSTPRODUCCION',
    'EN_PREPRODUCCION',
    'EN_RODAJE',
    'INCONCLUSA',
    'INEDITA'
  ]).optional(),
})

// Schema para fechas parciales (estado interno del formulario)
export const moviePartialDatesSchema = z.object({
  isPartialReleaseDate: z.boolean().optional(),
  partialReleaseDate: z.object({
    year: z.number().nullable(),
    month: z.number().nullable(),
    day: z.number().nullable()
  }).optional(),

  isPartialFilmingStartDate: z.boolean().optional(),
  partialFilmingStartDate: z.object({
    year: z.number().nullable(),
    month: z.number().nullable(),
    day: z.number().nullable()
  }).optional(),

  isPartialFilmingEndDate: z.boolean().optional(),
  partialFilmingEndDate: z.object({
    year: z.number().nullable(),
    month: z.number().nullable(),
    day: z.number().nullable()
  }).optional(),
})

// Schema para relaciones (manejadas por callbacks, no validadas por React Hook Form)
export const movieRelationsSchema = z.object({
  genres: z.array(z.number()).optional(),
  cast: z.array(z.object({
    personId: z.number(),
    characterName: z.string().optional(),
    billingOrder: z.number().optional(),
    isPrincipal: z.boolean().optional(),
    notes: z.string().optional(),
  })).optional(),
  crew: z.array(z.object({
    personId: z.number(),
    role: z.string(),
    department: z.string().optional(),
    billingOrder: z.number().optional()
  })).optional(),
  productionCompanies: z.array(z.number()).optional(),
  distributionCompanies: z.array(z.number()).optional(),
  themes: z.array(z.number()).optional(),
  movieCountries: z.array(z.number()).optional(),
  links: z.array(z.object({
    type: z.string(),
    url: z.string(),
    title: z.string().optional(),
    isActive: z.boolean().optional()
  })).optional(),
  screeningVenues: z.array(z.union([
    z.number(),
    z.object({
      venueId: z.number(),
      screeningDate: z.string().optional(),
      isPremiere: z.boolean().optional(),
      isExclusive: z.boolean().optional()
    })
  ])).optional(),
  alternativeTitles: z.array(z.object({
    title: z.string(),
    description: z.string().optional()
  })).optional()
})

// Schema principal para React Hook Form (solo valida campos del formulario)
export const movieFormSchema = movieFormFieldsSchema.merge(moviePartialDatesSchema)

// Schema completo para la API (incluye todo)
export const movieCompleteSchema = movieFormFieldsSchema
  .merge(moviePartialDatesSchema)
  .merge(movieRelationsSchema)

// ============================================================================
// TIPOS TYPESCRIPT
// ============================================================================

// Tipo para React Hook Form (solo campos del formulario + fechas parciales)
export type MovieFormData = z.infer<typeof movieFormSchema>

// Tipo completo con relaciones (para enviar a la API)
export type MovieCompleteData = z.infer<typeof movieCompleteSchema>

// Tipos parciales para mejor organizaci√≥n
export type MovieFormFields = z.infer<typeof movieFormFieldsSchema>
export type MovieRelations = z.infer<typeof movieRelationsSchema>
export type MoviePartialDates = z.infer<typeof moviePartialDatesSchema>

// ============================================================================
// INTERFACES
// ============================================================================

export interface Movie {
  id: number
  slug: string
  title: string
  originalTitle?: string
  year: number
  releaseDate?: string
  duration?: number
  rating?: number
  posterUrl?: string
  status: string
  stage?: string
  filmingStartDate: string
  filmingEndDate: string
  dataCompleteness?: string
  genres: Array<{ id: number; name: string }>
  directors: Array<{ id: number; name: string }>
  mainCast: Array<{
    person: { id: number; name: string }
    character?: string
  }>
  country: string
}

export interface MovieLink {
  id?: number
  type: string
  url: string
  description?: string
}

export interface AlternativeTitle {
  id?: number
  title: string
  type?: string
  language?: string
}

export interface Rating {
  id: number
  name: string
  abbreviation?: string
  description?: string
}

export interface ColorType {
  id: number
  name: string
}

// ============================================================================
// TIPOS DE CONSTANTES
// ============================================================================

export type MovieStage =
  | 'COMPLETA'
  | 'EN_DESARROLLO'
  | 'EN_POSTPRODUCCION'
  | 'EN_PREPRODUCCION'
  | 'EN_RODAJE'
  | 'INCONCLUSA'
  | 'INEDITA'

export type DataCompleteness =
  | 'BASIC_PRESS_KIT'
  | 'FULL_PRESS_KIT'
  | 'MAIN_CAST'
  | 'MAIN_CREW'
  | 'FULL_CAST'
  | 'FULL_CREW'

export type DurationType = 'largometraje' | 'mediometraje' | 'cortometraje'

// ==================================================
// src/lib/movies/movieUtils.ts
// ==================================================
// src/lib/movies/movieUtils.ts

import { DURATION_THRESHOLDS, MOVIE_STAGES, COMPLETENESS_COLORS, STAGE_COLORS, DATA_COMPLETENESS_LEVELS } from './movieConstants'
import type { MovieFormData } from './movieTypes'

/**
 * Calcula el tipo de duraci√≥n basado en minutos y segundos
 */
export const calcularTipoDuracion = (
  minutos: number | null | undefined, 
  segundos: number | null | undefined = 0
): string => {
  // Convertir todo a minutos totales
  const minutosReales = minutos || 0
  const segundosReales = segundos || 0
  const duracionTotalMinutos = minutosReales + (segundosReales / 60)

  // Si no hay duraci√≥n total, retornar vac√≠o
  if (duracionTotalMinutos === 0) return ''

  if (duracionTotalMinutos >= DURATION_THRESHOLDS.LARGOMETRAJE) return 'largometraje'
  if (duracionTotalMinutos >= DURATION_THRESHOLDS.MEDIOMETRAJE) return 'mediometraje'
  return 'cortometraje'
}

/**
 * Limpia y prepara los datos del formulario para enviar al backend
 */
export const prepareMovieData = (data: MovieFormData) => {
  const prepared: any = {}

  Object.entries(data).forEach(([key, value]) => {
    // Si es string vac√≠o, null o undefined, lo dejamos como undefined
    if (value === '' || value === null || value === undefined) {
      prepared[key] = undefined
    }
    // Si es un campo num√©rico y tiene valor
    else if (['year', 'duration', 'durationSeconds', 'rating', 'colorTypeId', 'ratingId'].includes(key) && value !== '') {
      const num = Number(value)
      prepared[key] = isNaN(num) ? undefined : num
    }
    // Si es URL y tiene valor, validamos que sea URL v√°lida
    else if (['posterUrl', 'backdropUrl', 'trailerUrl'].includes(key) && value !== '') {
      try {
        new URL(value as string)
        prepared[key] = value
      } catch {
        prepared[key] = undefined
      }
    }
    // Para el resto de campos
    else {
      prepared[key] = value
    }
  })

  // Valores por defecto
  prepared.dataCompleteness = prepared.dataCompleteness || 'BASIC_PRESS_KIT'

  return prepared
}

/**
 * Obtiene el label de completitud de datos
 */
export const getCompletenessLabel = (completeness: string): string => {
  const level = DATA_COMPLETENESS_LEVELS.find(l => l.value === completeness)
  return level ? level.label : completeness
}

/**
 * Obtiene el color CSS para el nivel de completitud
 */
export const getCompletenessColor = (completeness: string): string => {
  return COMPLETENESS_COLORS[completeness as keyof typeof COMPLETENESS_COLORS] || 'bg-gray-100 text-gray-800'
}

/**
 * Obtiene el color CSS para la etapa de la pel√≠cula
 */
export const getStageColor = (stage?: string): string => {
  if (!stage) return 'bg-gray-100 text-gray-800'
  return STAGE_COLORS[stage as keyof typeof STAGE_COLORS] || 'bg-gray-100 text-gray-800'
}

/**
 * Obtiene el nombre de la etapa
 */
export const getStageName = (stage?: string): string => {
  if (!stage) return '-'
  const stageInfo = MOVIE_STAGES.find(s => s.value === stage)
  return stageInfo ? stageInfo.label : stage
}

/**
 * Obtiene un mensaje de error legible
 */
export const getErrorMessage = (error: any): string => {
  if (!error) return ''
  if (typeof error === 'string') return error
  if (error?.message) return error.message
  return 'Este campo tiene un error'
}

/**
 * Formatea keywords para enviar al backend
 */
export const formatKeywords = (keywords: string): string[] => {
  if (!keywords) return []
  return keywords.split(',').map(k => k.trim()).filter(Boolean)
}

/**
 * Construye los datos de fecha de estreno seg√∫n el tipo (parcial o completa)
 */
export const buildReleaseDateData = (
  isPartialDate: boolean,
  releaseDate?: string,
  partialReleaseDate?: { year: number | null; month: number | null }
) => {
  if (isPartialDate && partialReleaseDate) {
    // Fecha parcial - enviar campos separados
    return {
      releaseYear: partialReleaseDate.year,
      releaseMonth: partialReleaseDate.month,
      releaseDay: null
    }
  } else if (releaseDate) {
    // Fecha completa - convertir a campos separados
    const [year, month, day] = releaseDate.split('-').map(Number)
    return {
      releaseYear: year,
      releaseMonth: month,
      releaseDay: day
    }
  } else {
    // Sin fecha
    return {
      releaseYear: null,
      releaseMonth: null,
      releaseDay: null
    }
  }
}

/**
 * Determina si el campo de tipo de duraci√≥n debe estar deshabilitado
 */
export const shouldDisableDurationType = (
  minutos: number | undefined | null,
  segundos: number | undefined | null
): boolean => {
  return (minutos && minutos > 0) || (segundos && segundos > 0) ? true : false
}

// ==================================================
// src/lib/obituarios/obituariosTypes.ts
// ==================================================
// src/lib/obituarios/obituariosTypes.ts

export interface PersonWithDeath {
  id: number;
  slug: string;
  firstName: string | null;
  lastName: string | null;
  photoUrl: string | null;
  birthYear: number | null;
  birthMonth: number | null;
  birthDay: number | null;
  deathYear: number;
  deathMonth: number | null;
  deathDay: number | null;
}

export interface ObituariosFilters {
  year?: number;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface ObituariosPagination {
  page: number;
  totalPages: number;
  total: number;
}

// ==================================================
// src/lib/obituarios/obituariosUtils.ts
// ==================================================
// src/lib/obituarios/obituariosUtils.ts

import { PersonWithDeath } from './obituariosTypes';

/**
 * Nombres de los meses en espa√±ol
 */
const MONTH_NAMES = [
  'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
  'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
];

/**
 * Obtiene el a√±o actual
 */
export function getCurrentYear(): number {
  return new Date().getFullYear();
}

/**
 * Genera array de a√±os desde el primer a√±o con defunciones hasta el actual
 */
export async function getAvailableYears(): Promise<number[]> {
  try {
    const response = await fetch('/api/people/death-years');
    if (!response.ok) {
      throw new Error('Error al obtener a√±os');
    }
    
    const data = await response.json();
    return data.years || [];
  } catch (error) {
    console.error('Error loading death years:', error);
    return [];
  }
}

/**
 * Calcula la edad de una persona
 */
export function calculateAge(
  birthYear: number | null,
  birthMonth: number | null,
  birthDay: number | null,
  deathYear: number,
  deathMonth: number | null,
  deathDay: number | null
): number | null {
  if (!birthYear) return null;

  let age = deathYear - birthYear;

  // Ajustar si no ha llegado el cumplea√±os
  if (birthMonth && deathMonth) {
    if (deathMonth < birthMonth) {
      age--;
    } else if (deathMonth === birthMonth && birthDay && deathDay) {
      if (deathDay < birthDay) {
        age--;
      }
    }
  }

  return age;
}

/**
 * Formatea el nombre completo de una persona
 */
export function formatPersonName(person: PersonWithDeath): string {
  const parts = [];
  if (person.firstName) parts.push(person.firstName);
  if (person.lastName) parts.push(person.lastName);
  return parts.join(' ') || 'Sin nombre';
}

/**
 * Formatea la fecha de muerte sin el a√±o
 * Ejemplo: "2 de octubre" o "febrero" si solo hay mes
 */
export function formatDeathDate(
  deathMonth: number | null,
  deathDay: number | null
): string | null {
  if (!deathMonth) return null;
  
  const monthName = MONTH_NAMES[deathMonth - 1];
  
  if (deathDay) {
    return `${deathDay} de ${monthName}`;
  }
  
  return monthName;
}

/**
 * Formatea las fechas de vida "n. 1950 - f. 2024 (74 a√±os)"
 */
export function formatLifeDates(person: PersonWithDeath): string {
  const parts = [];
  
  // Fecha de nacimiento
  if (person.birthYear) {
    parts.push(`n. ${person.birthYear}`);
  }
  
  // Fecha de muerte
  if (person.deathYear) {
    parts.push(`f. ${person.deathYear}`);
  }
  
  const result = parts.join(' - ');
  
  // Agregar edad si es posible calcularla
  const age = calculateAge(
    person.birthYear,
    person.birthMonth,
    person.birthDay,
    person.deathYear,
    person.deathMonth,
    person.deathDay
  );
  
  if (age !== null) {
    return `${result} (${age} a√±os)`;
  }
  
  return result;
}

/**
 * Convierte filtros a query params para la API
 */
export function filtersToApiParams(year?: number, page = 1, limit = 90): Record<string, string> {
  const params: Record<string, string> = {
    page: page.toString(),
    limit: limit.toString(),
    sortBy: 'deathYear',
    sortOrder: 'desc',
    hasDeathDate: 'true' // Solo personas fallecidas
  };
  
  if (year) {
    params.deathYear = year.toString();
  }
  
  return params;
}

// ==================================================
// src/lib/people/nameUtils.ts
// ==================================================
/**
 * Utilidades para separaci√≥n inteligente de nombres
 * 
 * Usa la tabla FirstNameGender para identificar qu√© palabras son nombres de pila.
 * 
 * Reglas (en orden de prioridad):
 * 1. Una sola palabra va a apellido (para ordenamiento alfab√©tico)
 * 2. Si hay apodos entre comillas ‚Üí van con el nombre, resto es apellido
 * 3. Si hay iniciales (A., J., O.) ‚Üí van con el nombre, resto es apellido
 * 4. Sin nombres conocidos, apodos ni iniciales ‚Üí todo va a apellido
 * 5. Preposiciones (de, del, la, los, las, el) van con la palabra siguiente
 * 6. La primera palabra desconocida (no en FirstNameGender) inicia el apellido
 * 7. Si todas las palabras son nombres conocidos, la √∫ltima es el apellido
 */

import { PrismaClient } from '@prisma/client';

// Preposiciones comunes en nombres hispanos
const PREPOSITIONS = new Set(['de', 'del', 'la', 'las', 'los', 'el']);

// Cache de nombres conocidos (se carga una vez por instancia)
let knownNamesCache: Set<string> | null = null;
let cacheTimestamp: number = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutos

/**
 * Verifica si una palabra es una preposici√≥n
 */
function isPreposition(word: string): boolean {
  return PREPOSITIONS.has(word.toLowerCase());
}

/**
 * Verifica si una palabra est√° en la tabla de nombres conocidos
 */
function isKnownName(word: string, knownNames: Set<string>): boolean {
  return knownNames.has(word.toLowerCase());
}

/**
 * Detecta si una palabra es un apodo (est√° entre comillas)
 * Soporta: "Apodo", 'Apodo', ¬´Apodo¬ª, "Apodo"
 */
function isNickname(word: string): boolean {
  if (!word || word.length < 3) return false;
  
  const first = word[0];
  const last = word[word.length - 1];
  
  // Comillas dobles ASCII
  if (first === '"' && last === '"') return true;
  // Comillas simples
  if (first === "'" && last === "'") return true;
  // Comillas latinas
  if (first === '¬´' && last === '¬ª') return true;
  // Comillas tipogr√°ficas
  if ((first === '"' || first === '"') && (last === '"' || last === '"')) return true;
  
  return false;
}

/**
 * Detecta si una palabra es una inicial (letra may√∫scula + punto)
 * Ejemplos: "A.", "J.", "O.", "M."
 */
function isInitial(word: string): boolean {
  if (!word || word.length < 2 || word.length > 3) return false;
  
  // Patr√≥n: una o dos letras may√∫sculas seguidas de punto
  // Ejemplos v√°lidos: "A.", "J.", "O.", "JR." (aunque este √∫ltimo es raro)
  const pattern = /^[A-Z√Å√â√ç√ì√ö√ë√ú]{1,2}\.$/;
  return pattern.test(word);
}

/**
 * Tokeniza el nombre manejando apodos entre comillas como unidades
 * IMPORTANTE: Solo trata como apodo si hay espacio antes de la comilla
 * Esto evita romper apellidos como D'Angelo, O'Brien, etc.
 * 
 * Ejemplo: 'Ricardo "Bocha" Bochini' ‚Üí ['Ricardo', '"Bocha"', 'Bochini']
 * Ejemplo: 'Juan "El Loco" P√©rez' ‚Üí ['Juan', '"El Loco"', 'P√©rez']
 * Ejemplo: "Diego D'Angelo" ‚Üí ['Diego', "D'Angelo"] (NO rompe el apellido)
 */
function tokenizeName(fullName: string): string[] {
  const tokens: string[] = [];
  let current = '';
  let inQuotes = false;
  let quoteChar = '';
  
  for (let i = 0; i < fullName.length; i++) {
    const char = fullName[i];
    const prevChar = i > 0 ? fullName[i - 1] : ' ';
    
    // Solo iniciar apodo si hay espacio antes (o es el inicio) Y es una comilla
    // Esto evita romper D'Angelo, O'Brien, etc.
    const isQuoteStart = !inQuotes && 
      (char === '"' || char === "'" || char === '¬´' || char === '"') &&
      (prevChar === ' ' || i === 0);
    
    if (isQuoteStart) {
      if (current.trim()) {
        // Agregar palabras anteriores
        current.trim().split(/\s+/).forEach(w => {
          if (w) tokens.push(w);
        });
        current = '';
      }
      inQuotes = true;
      quoteChar = char === '¬´' ? '¬ª' : (char === '"' ? '"' : char);
      current = char;
    }
    // Detectar fin de comillas
    else if (inQuotes && (char === quoteChar || char === '"' || char === '"' || char === '¬ª')) {
      current += char;
      tokens.push(current.trim());
      current = '';
      inQuotes = false;
      quoteChar = '';
    }
    // Dentro de comillas, agregar todo
    else if (inQuotes) {
      current += char;
    }
    // Espacio fuera de comillas
    else if (char === ' ') {
      if (current.trim()) {
        tokens.push(current.trim());
        current = '';
      }
    }
    // Car√°cter normal
    else {
      current += char;
    }
  }
  
  // Agregar lo que quede
  if (current.trim()) {
    if (inQuotes) {
      // Comilla sin cerrar, tratar como texto normal
      current.trim().split(/\s+/).forEach(w => {
        if (w) tokens.push(w);
      });
    } else {
      tokens.push(current.trim());
    }
  }
  
  return tokens;
}

/**
 * Carga los nombres conocidos desde la base de datos (con cache)
 */
async function loadKnownNames(prisma: PrismaClient): Promise<Set<string>> {
  const now = Date.now();
  
  // Usar cache si es v√°lido
  if (knownNamesCache && (now - cacheTimestamp) < CACHE_TTL) {
    return knownNamesCache;
  }
  
  // Cargar desde BD
  const names = await prisma.firstNameGender.findMany({
    select: { name: true },
  });
  
  knownNamesCache = new Set(names.map(n => n.name.toLowerCase()));
  cacheTimestamp = now;
  
  return knownNamesCache;
}

/**
 * Verifica si una palabra debe tratarse como parte del nombre
 * (es nombre conocido, apodo, inicial, o preposici√≥n seguida de nombre)
 */
function isFirstNamePart(word: string, knownNames: Set<string>): boolean {
  return isKnownName(word, knownNames) || isNickname(word) || isInitial(word);
}

/**
 * Encuentra el √≠ndice donde empieza el apellido
 * Apodos e iniciales se tratan como parte del nombre
 */
function findLastNameStartIndex(words: string[], knownNames: Set<string>): number {
  if (words.length === 0) return 0;
  if (words.length === 1) return 0; // Una sola palabra ‚Üí va a apellido
  
  // Filtrar preposiciones, apodos e iniciales para el an√°lisis
  const significantWords = words.filter(w => !isPreposition(w) && !isNickname(w) && !isInitial(w));
  
  // Verificar si todas las palabras significativas son nombres conocidos
  const allAreKnownNames = significantWords.every(w => isKnownName(w, knownNames));
  
  if (allAreKnownNames) {
    // Todas son nombres conocidos: la √∫ltima palabra significativa es apellido
    let lastNameStart = words.length - 1;
    
    // Solo retroceder si hay preposiciones antes del apellido
    // Las iniciales ANTES del apellido van con el nombre, NO con el apellido
    while (lastNameStart > 0 && isPreposition(words[lastNameStart - 1])) {
      lastNameStart--;
    }
    
    // No dejar firstName vac√≠o
    if (lastNameStart === 0) {
      lastNameStart = words.length - 1;
    }
    
    return lastNameStart;
  }
  
  // Buscar la primera palabra desconocida (que no sea apodo, inicial ni preposici√≥n)
  let i = 0;
  while (i < words.length) {
    const word = words[i];
    
    // Apodos e iniciales siempre van con el nombre
    if (isNickname(word) || isInitial(word)) {
      i++;
      continue;
    }
    
    if (isPreposition(word)) {
      // Buscar siguiente palabra no-preposici√≥n
      let nextNonPrepIndex = i + 1;
      while (nextNonPrepIndex < words.length && isPreposition(words[nextNonPrepIndex])) {
        nextNonPrepIndex++;
      }
      
      if (nextNonPrepIndex >= words.length) {
        return i;
      }
      
      const nextWord = words[nextNonPrepIndex];
      
      // Si lo siguiente es apodo o inicial, continuar
      if (isNickname(nextWord) || isInitial(nextWord)) {
        i = nextNonPrepIndex + 1;
      }
      // Si es nombre conocido, la preposici√≥n va con el nombre
      else if (isKnownName(nextWord, knownNames)) {
        i = nextNonPrepIndex + 1;
      }
      // Si no es conocido, la preposici√≥n inicia el apellido
      else {
        return i;
      }
    } else if (isKnownName(word, knownNames)) {
      i++;
    } else {
      // Palabra desconocida: aqu√≠ empieza el apellido
      return i;
    }
  }
  
  return words.length;
}

/**
 * Separa un nombre completo en firstName y lastName usando FirstNameGender
 * 
 * @param fullName - Nombre completo a separar
 * @param prisma - Cliente Prisma para acceder a la BD
 * @returns Objeto con firstName y lastName
 * 
 * @example
 * // Sin nombres conocidos (banda, instituci√≥n) ‚Üí todo a apellido
 * splitFullName("El Mat√≥ a un Polic√≠a Motorizado", prisma) 
 * // { firstName: null, lastName: "El Mat√≥ a un Polic√≠a Motorizado" }
 * 
 * // Una sola palabra (va a apellido)
 * splitFullName("Shakira", prisma) // { firstName: null, lastName: "Shakira" }
 * 
 * // Caso normal
 * splitFullName("Pedro Garc√≠a", prisma) // { firstName: "Pedro", lastName: "Garc√≠a" }
 * 
 * // Nombres compuestos
 * splitFullName("Mar√≠a Luisa Gonz√°lez", prisma) // { firstName: "Mar√≠a Luisa", lastName: "Gonz√°lez" }
 * 
 * // Con apodo
 * splitFullName('Ricardo "Bocha" Bochini', prisma) // { firstName: 'Ricardo "Bocha"', lastName: "Bochini" }
 * 
 * // Con iniciales al inicio
 * splitFullName("A. J. Bogani", prisma) // { firstName: "A. J.", lastName: "Bogani" }
 * 
 * // Con inicial en el medio
 * splitFullName("Abelardo O. Mart√≠nez", prisma) // { firstName: "Abelardo O.", lastName: "Mart√≠nez" }
 * 
 * // Con inicial al final (va con apellido)
 * splitFullName("Ricardo Mart√≠nez C.", prisma) // { firstName: "Ricardo", lastName: "Mart√≠nez C." }
 * 
 * // Con preposiciones
 * splitFullName("Mar√≠a del Carmen Rodr√≠guez", prisma) // { firstName: "Mar√≠a del Carmen", lastName: "Rodr√≠guez" }
 */
export async function splitFullName(
  fullName: string,
  prisma: PrismaClient
): Promise<{ firstName: string | null; lastName: string | null }> {
  const trimmed = fullName.trim();
  
  if (!trimmed) {
    return { firstName: null, lastName: null };
  }
  
  // Cargar nombres conocidos
  const knownNames = await loadKnownNames(prisma);
  
  // Tokenizar respetando apodos entre comillas
  const words = tokenizeName(trimmed);
  
  // REGLA: Una sola palabra va a apellido (para ordenamiento)
  if (words.length === 1) {
    return { firstName: null, lastName: words[0] };
  }
  
  // Verificar si hay apodos o iniciales
  const hasNicknameOrInitial = words.some(w => isNickname(w) || isInitial(w));
  
  // Si hay apodos o iniciales, darles prioridad
  if (hasNicknameOrInitial) {
    // Encontrar d√≥nde terminan los apodos/iniciales/nombres conocidos
    let firstNameEnd = 0;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      if (isNickname(word) || isInitial(word) || isKnownName(word, knownNames)) {
        firstNameEnd = i + 1;
      } 
      else if (isPreposition(word)) {
        // Preposici√≥n: ver qu√© sigue
        let nextNonPrep = i + 1;
        while (nextNonPrep < words.length && isPreposition(words[nextNonPrep])) {
          nextNonPrep++;
        }
        
        if (nextNonPrep >= words.length) {
          break;
        }
        
        const nextWord = words[nextNonPrep];
        if (isNickname(nextWord) || isInitial(nextWord) || isKnownName(nextWord, knownNames)) {
          firstNameEnd = nextNonPrep + 1;
          i = nextNonPrep;
        } else {
          break;
        }
      }
      else {
        break;
      }
    }
    
    if (firstNameEnd >= words.length) {
      return {
        firstName: words.slice(0, -1).join(' ') || null,
        lastName: words[words.length - 1]
      };
    }
    
    return {
      firstName: words.slice(0, firstNameEnd).join(' ') || null,
      lastName: words.slice(firstNameEnd).join(' ') || null
    };
  }
  
  // Verificar si hay AL MENOS UN nombre conocido (ignorando preposiciones)
  const hasAnyKnownName = words.some(w => 
    !isPreposition(w) && isKnownName(w, knownNames)
  );
  
  // Si NO hay ning√∫n nombre conocido, apodo ni inicial ‚Üí todo va a apellido
  // Esto maneja casos como "El Mat√≥ a un Polic√≠a Motorizado" o "Escuela de Educaci√≥n..."
  if (!hasAnyKnownName) {
    return { firstName: null, lastName: trimmed };
  }
  
  const lastNameStartIndex = findLastNameStartIndex(words, knownNames);
  
  // Si el √≠ndice es 0, la primera palabra es desconocida
  if (lastNameStartIndex === 0) {
    // Sin apodos ni iniciales: primera palabra a nombre, resto a apellido
    return {
      firstName: words[0],
      lastName: words.slice(1).join(' ') || null,
    };
  }
  
  // Si todo es nombre (√≠ndice >= longitud)
  if (lastNameStartIndex >= words.length) {
    // Poner la √∫ltima palabra como apellido
    return {
      firstName: words.slice(0, -1).join(' ') || null,
      lastName: words[words.length - 1],
    };
  }
  
  const firstName = words.slice(0, lastNameStartIndex).join(' ');
  const lastName = words.slice(lastNameStartIndex).join(' ');
  
  return {
    firstName: firstName || null,
    lastName: lastName || null,
  };
}

/**
 * Versi√≥n sincr√≥nica para uso en batch (cuando ya ten√©s los nombres cargados)
 */
export function splitFullNameSync(
  fullName: string,
  knownNames: Set<string>
): { firstName: string | null; lastName: string | null } {
  const trimmed = fullName.trim();
  
  if (!trimmed) {
    return { firstName: null, lastName: null };
  }
  
  // Tokenizar respetando apodos entre comillas
  const words = tokenizeName(trimmed);
  
  // REGLA: Una sola palabra va a apellido
  if (words.length === 1) {
    return { firstName: null, lastName: words[0] };
  }
  
  // Verificar si hay apodos o iniciales
  const hasNicknameOrInitial = words.some(w => isNickname(w) || isInitial(w));
  
  // Si hay apodos o iniciales, darles prioridad
  if (hasNicknameOrInitial) {
    let firstNameEnd = 0;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      if (isNickname(word) || isInitial(word) || isKnownName(word, knownNames)) {
        firstNameEnd = i + 1;
      } 
      else if (isPreposition(word)) {
        let nextNonPrep = i + 1;
        while (nextNonPrep < words.length && isPreposition(words[nextNonPrep])) {
          nextNonPrep++;
        }
        
        if (nextNonPrep >= words.length) {
          break;
        }
        
        const nextWord = words[nextNonPrep];
        if (isNickname(nextWord) || isInitial(nextWord) || isKnownName(nextWord, knownNames)) {
          firstNameEnd = nextNonPrep + 1;
          i = nextNonPrep;
        } else {
          break;
        }
      }
      else {
        break;
      }
    }
    
    if (firstNameEnd >= words.length) {
      return {
        firstName: words.slice(0, -1).join(' ') || null,
        lastName: words[words.length - 1]
      };
    }
    
    return {
      firstName: words.slice(0, firstNameEnd).join(' ') || null,
      lastName: words.slice(firstNameEnd).join(' ') || null
    };
  }
  
  // Verificar si hay AL MENOS UN nombre conocido
  const hasAnyKnownName = words.some(w => 
    !isPreposition(w) && isKnownName(w, knownNames)
  );
  
  // Si NO hay ning√∫n nombre conocido ‚Üí todo va a apellido
  if (!hasAnyKnownName) {
    return { firstName: null, lastName: trimmed };
  }
  
  const lastNameStartIndex = findLastNameStartIndex(words, knownNames);
  
  if (lastNameStartIndex === 0) {
    return {
      firstName: words[0],
      lastName: words.slice(1).join(' ') || null,
    };
  }
  
  if (lastNameStartIndex >= words.length) {
    return {
      firstName: words.slice(0, -1).join(' ') || null,
      lastName: words[words.length - 1],
    };
  }
  
  const firstName = words.slice(0, lastNameStartIndex).join(' ');
  const lastName = words.slice(lastNameStartIndex).join(' ');
  
  return {
    firstName: firstName || null,
    lastName: lastName || null,
  };
}

/**
 * Normaliza un nombre (capitaliza palabras, mantiene preposiciones en min√∫scula)
 */
export function normalizeName(name: string): string {
  return name
    .trim()
    .split(/\s+/)
    .map(word => {
      // Mantener apodos como est√°n
      if (isNickname(word)) return word;
      
      // Mantener iniciales como est√°n
      if (isInitial(word)) return word.toUpperCase();
      
      // Preposiciones en min√∫scula
      if (isPreposition(word)) return word.toLowerCase();
      
      // Capitalizar primera letra
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

/**
 * Invalida el cache de nombres (√∫til despu√©s de agregar nuevos nombres)
 */
export function invalidateNameCache(): void {
  knownNamesCache = null;
  cacheTimestamp = 0;
}

// ==================================================
// src/lib/people/peopleConstants.ts
// ==================================================
// src/lib/people/peopleConstants.ts

import { Gender, PersonLinkType, PersonFormData } from './peopleTypes';

// Opciones de g√©nero
/**
 * Opciones de g√©nero disponibles para personas
 * @constant
 * @type {Array<{value: string, label: string}>}
 */
export const GENDER_OPTIONS = [
  { value: 'MALE' as Gender, label: 'Masculino' },
  { value: 'FEMALE' as Gender, label: 'Femenino' },
  { value: 'OTHER' as Gender, label: 'Otro' },
] as const;

// Tipos de links con sus etiquetas
/**
 * Tipos de enlaces externos para personas (IMDB, Wikipedia, etc.)
 * @constant
 * @type {Array<{value: string, label: string}>}
 */
export const PERSON_LINK_TYPES: Record<PersonLinkType, string> = {
  IMDB: 'IMDb',
  TMDB: 'TMDb',
  CINENACIONAL: 'cinenacional.com',
  WIKIPEDIA: 'Wikipedia',
  OFFICIAL_WEBSITE: 'Sitio Web Oficial',
  PORTFOLIO: 'Portfolio',
  BLOG: 'Blog',
  INSTAGRAM: 'Instagram',
  TWITTER: 'Twitter',
  FACEBOOK: 'Facebook',
  YOUTUBE: 'YouTube',
  TIKTOK: 'TikTok',
  LINKEDIN: 'LinkedIn',
  VIMEO: 'Vimeo',
  LETTERBOXD: 'Letterboxd',
  SPOTIFY: 'Spotify',
  PODCAST: 'Podcast',
  INTERVIEW: 'Entrevista',
  ARTICLE: 'Art√≠culo',
  OTHER: 'Otro',
} as const;

// Array de opciones para selects
/**
 * PERSON_LINK_TYPE_OPTIONS
 * @TODO Add documentation
 */
export const PERSON_LINK_TYPE_OPTIONS = Object.entries(PERSON_LINK_TYPES).map(
  ([value, label]) => ({ value, label })
);

// Categor√≠as de links para organizaci√≥n en UI
/**
 * LINK_CATEGORIES
 * @TODO Add documentation
 */
export const LINK_CATEGORIES = {
  databases: {
    label: 'Bases de datos',
    types: ['IMDB', 'TMDB', 'CINENACIONAL'] as PersonLinkType[],
  },
  encyclopedias: {
    label: 'Enciclopedias',
    types: ['WIKIPEDIA'] as PersonLinkType[],
  },
  websites: {
    label: 'Sitios web',
    types: ['OFFICIAL_WEBSITE', 'PORTFOLIO', 'BLOG'] as PersonLinkType[],
  },
  social: {
    label: 'Redes sociales',
    types: ['INSTAGRAM', 'TWITTER', 'FACEBOOK', 'YOUTUBE', 'TIKTOK', 'LINKEDIN'] as PersonLinkType[],
  },
  content: {
    label: 'Plataformas de contenido',
    types: ['VIMEO', 'LETTERBOXD', 'SPOTIFY', 'PODCAST'] as PersonLinkType[],
  },
  other: {
    label: 'Otros',
    types: ['INTERVIEW', 'ARTICLE', 'OTHER'] as PersonLinkType[],
  },
} as const;

// Valores por defecto para formularios
/**
 * DEFAULT_PERSON_FORM_VALUES
 * @TODO Add documentation
 */
export const DEFAULT_PERSON_FORM_VALUES: PersonFormData = {
  firstName: '',
  lastName: '',
  realName: '',
  birthDate: '',
  deathDate: '',
  birthLocationId: null,    // <-- Agregar
  deathLocationId: null,    // <-- Agregar
  birthLocation: '',        // <-- Agregar
  deathLocation: '',        // <-- Agregar
  biography: '',
  photoUrl: '',
  gender: '',
  hideAge: false,
  isActive: true,
  links: [],
  alternativeNames: [],
  nationalities: []
};

// Valores por defecto para un nuevo link
/**
 * DEFAULT_PERSON_LINK
 * @TODO Add documentation
 */
export const DEFAULT_PERSON_LINK = {
  type: 'OTHER' as PersonLinkType,
  url: '',
  title: '',
  displayOrder: 0,
  isVerified: false,
  isActive: true,
} as const;

// Configuraci√≥n de paginaci√≥n
/**
 * PEOPLE_PAGINATION
 * @TODO Add documentation
 */
export const PEOPLE_PAGINATION = {
  DEFAULT_PAGE: 1,
  DEFAULT_LIMIT: 20,
  LIMITS: [10, 20, 50, 100],
} as const;

// Mensajes de error comunes
/**
 * PERSON_ERROR_MESSAGES
 * @TODO Add documentation
 */
export const PERSON_ERROR_MESSAGES = {
  FETCH_ERROR: 'Error al cargar las personas',
  CREATE_ERROR: 'Error al crear la persona',
  UPDATE_ERROR: 'Error al actualizar la persona',
  DELETE_ERROR: 'Error al eliminar la persona',
  DELETE_WITH_MOVIES: 'No se puede eliminar esta persona porque est√° asociada a pel√≠culas',
  REQUIRED_NAME: 'Debe ingresar al menos el nombre o el apellido',
  INVALID_DATES: 'La fecha de fallecimiento debe ser posterior a la fecha de nacimiento',
  DUPLICATE_SLUG: 'Ya existe una persona con ese nombre',
} as const;

// Mensajes de √©xito
/**
 * PERSON_SUCCESS_MESSAGES
 * @TODO Add documentation
 */
export const PERSON_SUCCESS_MESSAGES = {
  CREATED: 'Persona creada exitosamente',
  UPDATED: 'Persona actualizada exitosamente',
  DELETED: 'Persona eliminada exitosamente',
} as const;

// Constante para los meses (igual que en movies)
/**
 * MONTHS
 * @TODO Add documentation
 */
export const MONTHS = [
  { value: 1, label: 'Enero' },
  { value: 2, label: 'Febrero' },
  { value: 3, label: 'Marzo' },
  { value: 4, label: 'Abril' },
  { value: 5, label: 'Mayo' },
  { value: 6, label: 'Junio' },
  { value: 7, label: 'Julio' },
  { value: 8, label: 'Agosto' },
  { value: 9, label: 'Septiembre' },
  { value: 10, label: 'Octubre' },
  { value: 11, label: 'Noviembre' },
  { value: 12, label: 'Diciembre' }
];

// ==================================================
// src/lib/people/peopleTypes.ts
// ==================================================
// src/lib/people/peopleTypes.ts

import { PartialDate } from '@/lib/shared/dateUtils';

// Tipos base de la base de datos
export interface Person {
  id: number;
  slug: string;
  firstName?: string | null;
  lastName?: string | null;
  realName?: string | null;
  birthDate?: string | null;
  deathDate?: string | null;
  birthYear?: number | null;
  birthMonth?: number | null;
  birthDay?: number | null;
  deathYear?: number | null;
  deathMonth?: number | null;
  deathDay?: number | null;
  birthLocationId?: number | null;
  deathLocationId?: number | null;
  biography?: string | null;
  photoUrl?: string | null;
  photoPublicId?: string;
  gender?: Gender | null;
  hideAge: boolean;
  hasLinks: boolean;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

// Tipo de g√©nero
export type Gender = 'MALE' | 'FEMALE' | 'OTHER';

// Tipo para links de persona
export interface PersonLink {
  id?: number;
  personId?: number;
  type: PersonLinkType;
  url: string;
  title?: string | null;
  displayOrder: number;
  isVerified: boolean;
  isActive: boolean;
  lastChecked?: string | null;
  createdAt?: string;
  updatedAt?: string;
}

// Tipo para nombres alternativos
export interface PersonAlternativeName {
  id?: number;
  personId?: number;
  fullName: string;
  createdAt?: string;
  updatedAt?: string;
}

// Tipos de links disponibles
export type PersonLinkType = 
  | 'IMDB'
  | 'TMDB'
  | 'CINENACIONAL'
  | 'WIKIPEDIA'
  | 'OFFICIAL_WEBSITE'
  | 'PORTFOLIO'
  | 'BLOG'
  | 'INSTAGRAM'
  | 'TWITTER'
  | 'FACEBOOK'
  | 'YOUTUBE'
  | 'TIKTOK'
  | 'LINKEDIN'
  | 'VIMEO'
  | 'LETTERBOXD'
  | 'SPOTIFY'
  | 'PODCAST'
  | 'INTERVIEW'
  | 'ARTICLE'
  | 'OTHER';

// Tipo para ubicaci√≥n
export interface Location {
  id: number;
  name: string;
  slug?: string | null;
  type: string;
  parentId?: number | null;
  countryId: number;
  latitude?: number | null;
  longitude?: number | null;
  createdAt: string;
  updatedAt: string;
}

// Tipo extendido con relaciones
export interface PersonWithRelations extends Person {
  links?: PersonLink[];
  alternativeNames?: PersonAlternativeName[];
  nationalities?: Array<{
    personId?: number;
    locationId: number;
    isPrimary?: boolean;
    location?: Location;
  }>;
  birthLocation?: Location | null;
  deathLocation?: Location | null;
  _count?: {
    links: number;
    castRoles: number;
    crewRoles: number;
    awards: number;
  };
  // Campos de b√∫squeda: indican si el match fue en un nombre alternativo
  matchedAlternativeName?: string | null;
  matchedAlternativeNameId?: number | null;
}

// Tipo para el formulario
export interface PersonFormData {
  id?: number;
  firstName: string;
  lastName: string;
  realName?: string;
  // Fechas completas para el input type="date"
  birthDate: string;
  deathDate: string;
  
  // Fechas parciales
  partialBirthDate?: PartialDate;
  partialDeathDate?: PartialDate;
  
  // Flags para indicar si usar fecha parcial
  isPartialBirthDate?: boolean;
  isPartialDeathDate?: boolean;
  birthLocationId?: number | null;
  deathLocationId?: number | null;
  birthLocation?: string;
  deathLocation?: string;
  biography?: string;
  photoUrl?: string;
  photoPublicId?: string;
  gender?: string;
  hideAge?: boolean;
  isActive?: boolean;
  links: PersonLink[];
  alternativeNames?: PersonAlternativeName[];
  nationalities?: number[];
}

// Tipo para filtros de b√∫squeda
export interface PersonFilters {
  search?: string;
  gender?: Gender | '';
  hasLinks?: boolean | '';
  isActive?: boolean | '';
  page?: number;
  limit?: number;
  sortBy?: 'name' | 'createdAt' | 'updatedAt' | 'birthDate' | 'deathDate' | 'last_name';
  sortOrder?: 'asc' | 'desc';
}

// Tipo para respuesta paginada
export interface PaginatedPeopleResponse {
  data: PersonWithRelations[];
  totalCount: number;
  page: number;
  totalPages: number;
  hasMore: boolean;
}

// Tipo para resultado de b√∫squeda con info de nombre alternativo
export interface PersonSearchResult {
  id: number;
  firstName?: string | null;
  lastName?: string | null;
  slug: string;
  name?: string;
  alternativeNames?: PersonAlternativeName[];
  // Si el match fue en un nombre alternativo
  matchedAlternativeName?: string | null;
  matchedAlternativeNameId?: number | null;
}

// Tipo para selecci√≥n de persona (incluye alternativeNameId opcional)
export interface PersonSelection {
  personId: number;
  personName: string;
  alternativeNameId?: number | null;
  alternativeName?: string | null;
}

// ==================================================
// src/lib/people/peopleUtils.ts
// ==================================================
// src/lib/people/peopleUtils.ts

import { Person, PersonWithRelations, PersonFormData, PersonLink, Gender } from './peopleTypes';
import { DEFAULT_PERSON_FORM_VALUES, DEFAULT_PERSON_LINK } from './peopleConstants';
import { PartialDate, partialFieldsToDate } from '@/lib/shared/dateUtils';

/**
* Genera un slug √∫nico para una persona basado en nombre y apellido
*/
export function generatePersonSlug(firstName?: string, lastName?: string): string {
   const parts = [firstName, lastName].filter(Boolean);
   if (parts.length === 0) return '';

   return parts
       .join(' ')
       .toLowerCase()
       .normalize('NFD')
       .replace(/[\u0300-\u036f]/g, '') // Remover diacr√≠ticos
       .replace(/[^\w\s-]/g, '') // Remover caracteres especiales
       .trim()
       .replace(/\s+/g, '-') // Reemplazar espacios con guiones
       .replace(/-+/g, '-') // Reemplazar m√∫ltiples guiones con uno
       .replace(/^-+|-+$/g, ''); // Remover guiones al inicio y final
}

/**
* Formatea el nombre completo de una persona
*/
export function formatPersonName(person: Partial<Person>): string {
   const parts = [person.firstName, person.lastName].filter(Boolean);
   return parts.join(' ') || 'Sin nombre';
}

/**
* Formatea el g√©nero para mostrar
*/
export function formatGender(gender?: Gender | null): string {
   if (!gender) return '-';

   const genderMap: Record<Gender, string> = {
       MALE: 'Masculino',
       FEMALE: 'Femenino',
       OTHER: 'Otro',
   };

   return genderMap[gender] || '-';
}

/**
* Convierte los datos del formulario para enviar a la API
* NOTA: Esta funci√≥n ya no se usa, se usa formatPersonDataForAPI en people.service.ts
*/
export function formatPersonFormDataForAPI(data: PersonFormData) {
   return {
       firstName: data.firstName || null,
       lastName: data.lastName || null,
       realName: data.realName || null,
       birthDate: data.birthDate || null,
       deathDate: data.deathDate || null,
       birthLocationId: data.birthLocationId || null,
       deathLocationId: data.deathLocationId || null,
       biography: data.biography || null,
       photoUrl: data.photoUrl || null,
       gender: data.gender || null,
       hideAge: data.hideAge,
       isActive: data.isActive,
       links: data.links.map((link, index) => ({
           ...link,
           displayOrder: index,
           title: link.title || null,
       })),
   };
}

// Funci√≥n auxiliar para formatear el path de la ubicaci√≥n (recursiva para cualquier profundidad)
function formatLocationPath(location: any): string {
   // Si la ubicaci√≥n ya tiene un path, usarlo
   if (location.path) return location.path;

   // Construir el path de forma recursiva
   const parts: string[] = [];
   let current = location;
   
   while (current) {
       parts.push(current.name);
       current = current.parent;
   }
   
   return parts.join(', ');
}

/**
* Convierte los datos de la API al formato del formulario
* Maneja tanto fechas completas como parciales
*/
export function formatPersonDataForForm(person?: PersonWithRelations | null): PersonFormData {
   if (!person) return DEFAULT_PERSON_FORM_VALUES;

   const formData: PersonFormData = {
       firstName: person.firstName || '',
       lastName: person.lastName || '',
       realName: person.realName || '',
       birthDate: '',
       deathDate: '',
       birthLocationId: person.birthLocationId || null,
       deathLocationId: person.deathLocationId || null,
       birthLocation: person.birthLocation ? formatLocationPath(person.birthLocation) : '',
       deathLocation: person.deathLocation ? formatLocationPath(person.deathLocation) : '',
       biography: person.biography || '',
       photoUrl: person.photoUrl || '',
       gender: person.gender || '',
       hideAge: person.hideAge || false,
       isActive: person.isActive ?? true,
       links: person.links || [], // Cargar los links directamente si vienen
       nationalities: []
   };

   // Procesar fecha de nacimiento
   if ('birthYear' in person && person.birthYear) {
       const birthPartial: PartialDate = {
           year: person.birthYear,
           month: person.birthMonth ?? null,  // Usar ?? para convertir undefined a null
           day: person.birthDay ?? null       // Usar ?? para convertir undefined a null
       };

       // Si la fecha est√° completa (a√±o, mes y d√≠a), convertirla a formato ISO
       if (person.birthYear && person.birthMonth && person.birthDay) {
           const isoDate = partialFieldsToDate(birthPartial);
           if (isoDate) {
               formData.birthDate = isoDate;
               formData.isPartialBirthDate = false;
           }
       } else {
           // Es una fecha parcial
           formData.partialBirthDate = birthPartial;
           formData.isPartialBirthDate = true;
           formData.birthDate = '';
       }
   } else if (person.birthDate) {
       // Fallback para formato antiguo con birthDate como string
       formData.birthDate = person.birthDate.split('T')[0];
       formData.isPartialBirthDate = false;
   }

   // Procesar fecha de fallecimiento
   if ('deathYear' in person && person.deathYear) {
       const deathPartial: PartialDate = {
           year: person.deathYear,
           month: person.deathMonth ?? null,  // Usar ?? para convertir undefined a null
           day: person.deathDay ?? null       // Usar ?? para convertir undefined a null
       };

       // Si la fecha est√° completa (a√±o, mes y d√≠a), convertirla a formato ISO
       if (person.deathYear && person.deathMonth && person.deathDay) {
           const isoDate = partialFieldsToDate(deathPartial);
           if (isoDate) {
               formData.deathDate = isoDate;
               formData.isPartialDeathDate = false;
           }
       } else {
           // Es una fecha parcial
           formData.partialDeathDate = deathPartial;
           formData.isPartialDeathDate = true;
           formData.deathDate = '';
       }
   } else if (person.deathDate) {
       // Fallback para formato antiguo con deathDate como string
       formData.deathDate = person.deathDate.split('T')[0];
       formData.isPartialDeathDate = false;
   }

   // Procesar nacionalidades si existen
   if (person.nationalities && Array.isArray(person.nationalities)) {
       formData.nationalities = person.nationalities.map((n: any) => {
           // Si es un n√∫mero directo
           if (typeof n === 'number') return n;

           // Si es un objeto
           if (typeof n === 'object' && n !== null) {
               // Intentar extraer el ID de diferentes estructuras posibles
               if (n.locationId) return n.locationId;
               if (n.location && n.location.id) return n.location.id;
               if (n.id) return n.id;
           }

           return null;
       }).filter((id: any) => id !== null);
   }

   return formData;
}

/**
* Valida los datos del formulario de persona
*/
export function validatePersonForm(data: PersonFormData): string[] {
   const errors: string[] = [];

   // Validar que tenga al menos nombre o apellido
   if (!data.firstName && !data.lastName) {
       errors.push('Debe ingresar al menos el nombre o el apellido');
   }

   // Validar fechas si ambas son completas
   if (data.birthDate && data.deathDate) {
       const birthDate = new Date(data.birthDate);
       const deathDate = new Date(data.deathDate);

       if (deathDate < birthDate) {
           errors.push('La fecha de fallecimiento debe ser posterior a la fecha de nacimiento');
       }
   }

   // Validar fechas parciales
   if (data.isPartialBirthDate && data.partialBirthDate &&
       data.isPartialDeathDate && data.partialDeathDate) {
       const birthYear = data.partialBirthDate.year;
       const deathYear = data.partialDeathDate.year;

       if (birthYear && deathYear && deathYear < birthYear) {
           errors.push('El a√±o de fallecimiento debe ser posterior al a√±o de nacimiento');
       }
   }

   // Validar links
   data.links.forEach((link, index) => {
       if (!link.url) {
           errors.push(`El link #${index + 1} debe tener una URL`);
       } else if (!isValidUrl(link.url)) {
           errors.push(`La URL del link #${index + 1} no es v√°lida`);
       }
   });

   return errors;
}

/**
* Valida si una cadena es una URL v√°lida
*/
export function isValidUrl(url: string): boolean {
   try {
       new URL(url);
       return true;
   } catch {
       return false;
   }
}

/**
* Ordena los links por displayOrder
*/
export function sortPersonLinks(links: PersonLink[]): PersonLink[] {
   return [...links].sort((a, b) => a.displayOrder - b.displayOrder);
}

/**
* Agrega un nuevo link con valores por defecto
*/
export function addNewPersonLink(currentLinks: PersonLink[]): PersonLink[] {
   return [
       ...currentLinks,
       {
           ...DEFAULT_PERSON_LINK,
           displayOrder: currentLinks.length,
       },
   ];
}

/**
* Actualiza un link espec√≠fico
*/
export function updatePersonLink(
   links: PersonLink[],
   index: number,
   updates: Partial<PersonLink>
): PersonLink[] {
   const newLinks = [...links];
   newLinks[index] = { ...newLinks[index], ...updates };
   return newLinks;
}

/**
* Elimina un link y reordena los displayOrder
*/
export function removePersonLink(links: PersonLink[], index: number): PersonLink[] {
   return links
       .filter((_, i) => i !== index)
       .map((link, i) => ({ ...link, displayOrder: i }));
}

/**
* Genera el texto para mostrar la edad o fecha de nacimiento
* Actualizada para manejar fechas parciales
*/
export function formatBirthInfo(person: any): string {
   // Si hay campos de fecha parcial
   if ('birthYear' in person && person.birthYear) {
       if (person.hideAge) return 'Fecha oculta';

       let dateStr = '';
       if (person.birthDay && person.birthMonth) {
           // Fecha completa
           const date = new Date(person.birthYear, person.birthMonth - 1, person.birthDay);
           dateStr = date.toLocaleDateString('es-AR', {
               day: '2-digit',
               month: '2-digit',
               year: 'numeric',
           });

           // Calcular edad si no hay fecha de muerte
           if (!person.deathYear) {
               const age = calculateAge(date);
               return `${dateStr} (${age} a√±os)`;
           }
       } else if (person.birthMonth) {
           // Solo a√±o y mes
           const months = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
               'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
           dateStr = `${months[person.birthMonth - 1]} ${person.birthYear}`;
       } else {
           // Solo a√±o
           dateStr = String(person.birthYear);
       }

       return dateStr;
   }

   // Fallback al formato antiguo
   if (!person.birthDate) return '-';
   if (person.hideAge) return 'Fecha oculta';

   const birthDate = new Date(person.birthDate);
   const formattedDate = birthDate.toLocaleDateString('es-AR', {
       day: '2-digit',
       month: '2-digit',
       year: 'numeric',
   });

   if (!person.deathDate) {
       const age = calculateAge(birthDate);
       return `${formattedDate} (${age} a√±os)`;
   }

   return formattedDate;
}

/**
* Calcula la edad a partir de una fecha de nacimiento
*/
export function calculateAge(birthDate: Date, deathDate?: Date): number {
   const endDate = deathDate || new Date();
   let age = endDate.getFullYear() - birthDate.getFullYear();
   const monthDiff = endDate.getMonth() - birthDate.getMonth();

   if (monthDiff < 0 || (monthDiff === 0 && endDate.getDate() < birthDate.getDate())) {
       age--;
   }

   return age;
}

/**
* Genera un resumen de la persona para mostrar en listas
* Actualizada para manejar fechas parciales
*/
export function getPersonSummary(person: any): string {
   const parts = [];

   // Manejar fecha de nacimiento
   if ('birthYear' in person && person.birthYear && !person.hideAge) {
       parts.push(`n. ${person.birthYear}`);
   } else if (person.birthDate && !person.hideAge) {
       const year = new Date(person.birthDate).getFullYear();
       parts.push(`n. ${year}`);
   }

   // Manejar fecha de fallecimiento
   if ('deathYear' in person && person.deathYear) {
       parts.push(`f. ${person.deathYear}`);
   } else if (person.deathDate) {
       const year = new Date(person.deathDate).getFullYear();
       parts.push(`f. ${year}`);
   }

   return parts.join(' - ');
}

// ==================================================
// src/lib/people/personListTypes.ts
// ==================================================
// src/lib/people/personListTypes.ts

import { PersonWithRelations } from './peopleTypes';

// Filtros disponibles para el listado
export interface PersonListFilters {
  search?: string;
  gender?: 'MALE' | 'FEMALE' | 'OTHER' | '';
  birthLocationId?: number | '';
  deathLocationId?: number | '';
  nationalityId?: number | '';
  roleId?: number | 'ACTOR' | 'SELF' | '';  // 'ACTOR' para actuaciones, 'SELF' para apariciones como s√≠ mismo
  birthYearFrom?: number | '';
  birthYearTo?: number | '';
  deathYearFrom?: number | '';
  deathYearTo?: number | '';
  sortBy?: 'id' | 'lastName' | 'birthDate' | 'deathDate' | 'movieCount';
  sortOrder?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

// Valores por defecto de los filtros
export const DEFAULT_PERSON_FILTERS: PersonListFilters = {
  search: '',
  gender: '',
  birthLocationId: '',
  deathLocationId: '',
  nationalityId: '',
  roleId: '',
  birthYearFrom: '',
  birthYearTo: '',
  deathYearFrom: '',
  deathYearTo: '',
  sortBy: 'id',
  sortOrder: 'desc',
  page: 1,
  limit: 60
};

// Persona extendida con pel√≠cula destacada
export interface PersonWithMovie extends PersonWithRelations {
  featuredMovie?: {
    id: number;
    slug: string;
    title: string;
    year: number | null;
    role?: string;  // "Actor" o el nombre del rol t√©cnico
  } | null;
  movieCount?: number;
}

// Opciones para los dropdowns de filtros
export interface FilterOption {
  id: number;
  name: string;
  count?: number;  // Cantidad de personas con este valor
}

// Opciones de ubicaci√≥n (con jerarqu√≠a)
export interface LocationFilterOption extends FilterOption {
  parentName?: string;  // Ej: "Argentina" para "Buenos Aires"
  fullPath?: string;    // Ej: "Buenos Aires, Argentina"
}

// Opciones de rol
export interface RoleFilterOption extends FilterOption {
  department?: string;
  isActor?: boolean;  // true para el rol especial "Actor/Actriz"
}

// Respuesta de la API de filtros
export interface FiltersDataResponse {
  birthLocations: LocationFilterOption[];
  deathLocations: LocationFilterOption[];
  nationalities: LocationFilterOption[];
  roles: RoleFilterOption[];
  years: {
    birthYearMin: number | null;
    birthYearMax: number | null;
    deathYearMin: number | null;
    deathYearMax: number | null;
  };
}

// Respuesta paginada del listado
export interface PaginatedPersonListResponse {
  data: PersonWithMovie[];
  totalCount: number;
  page: number;
  totalPages: number;
  hasMore: boolean;
}

// Tipo de vista
export type ViewMode = 'compact' | 'detailed';

// Opciones de ordenamiento para el UI (simplificadas)
export const SORT_OPTIONS = [
  { value: 'id', label: 'Ingreso a la base de datos' },
  { value: 'lastName', label: 'Alfab√©ticamente' },
  { value: 'birthDate', label: 'Fecha de nacimiento' },
  { value: 'deathDate', label: 'Fecha de muerte' },
  { value: 'movieCount', label: 'Cantidad de pel√≠culas' },
] as const;

// Opciones de g√©nero para el UI
export const GENDER_OPTIONS = [
  { value: '', label: 'Todos los g√©neros' },
  { value: 'FEMALE', label: 'Femenino' },
  { value: 'MALE', label: 'Masculino' },
  { value: 'OTHER', label: 'Otro' },
] as const;

// ==================================================
// src/lib/people/personListUtils.ts
// ==================================================
// src/lib/people/personListUtils.ts

import { PersonListFilters, DEFAULT_PERSON_FILTERS, PersonWithMovie, LocationFilterOption } from './personListTypes';

/**
 * Convierte los filtros del estado a par√°metros de URL
 */
export function filtersToSearchParams(filters: PersonListFilters): URLSearchParams {
  const params = new URLSearchParams();
  
  // Solo agregar par√°metros que no sean el valor por defecto
  if (filters.search) params.set('search', filters.search);
  if (filters.gender) params.set('gender', filters.gender);
  if (filters.birthLocationId) params.set('birthLocationId', String(filters.birthLocationId));
  if (filters.deathLocationId) params.set('deathLocationId', String(filters.deathLocationId));
  if (filters.nationalityId) params.set('nationalityId', String(filters.nationalityId));
  if (filters.roleId) params.set('roleId', String(filters.roleId));
  if (filters.birthYearFrom) params.set('birthYearFrom', String(filters.birthYearFrom));
  if (filters.birthYearTo) params.set('birthYearTo', String(filters.birthYearTo));
  if (filters.deathYearFrom) params.set('deathYearFrom', String(filters.deathYearFrom));
  if (filters.deathYearTo) params.set('deathYearTo', String(filters.deathYearTo));
  if (filters.sortBy && filters.sortBy !== DEFAULT_PERSON_FILTERS.sortBy) {
    params.set('sortBy', filters.sortBy);
  }
  if (filters.sortOrder && filters.sortOrder !== DEFAULT_PERSON_FILTERS.sortOrder) {
    params.set('sortOrder', filters.sortOrder);
  }
  if (filters.page && filters.page !== 1) params.set('page', String(filters.page));
  
  return params;
}

/**
 * Convierte par√°metros de URL a filtros
 */
export function searchParamsToFilters(searchParams: URLSearchParams): PersonListFilters {
  const filters: PersonListFilters = { ...DEFAULT_PERSON_FILTERS };
  
  const search = searchParams.get('search');
  if (search) filters.search = search;
  
  const gender = searchParams.get('gender');
  if (gender === 'MALE' || gender === 'FEMALE' || gender === 'OTHER') {
    filters.gender = gender;
  }
  
  const birthLocationId = searchParams.get('birthLocationId');
  if (birthLocationId) filters.birthLocationId = parseInt(birthLocationId);
  
  const deathLocationId = searchParams.get('deathLocationId');
  if (deathLocationId) filters.deathLocationId = parseInt(deathLocationId);
  
  const nationalityId = searchParams.get('nationalityId');
  if (nationalityId) filters.nationalityId = parseInt(nationalityId);
  
  const roleId = searchParams.get('roleId');
  if (roleId) {
    filters.roleId = roleId === 'ACTOR' ? 'ACTOR' : parseInt(roleId);
  }
  
  const birthYearFrom = searchParams.get('birthYearFrom');
  if (birthYearFrom) filters.birthYearFrom = parseInt(birthYearFrom);
  
  const birthYearTo = searchParams.get('birthYearTo');
  if (birthYearTo) filters.birthYearTo = parseInt(birthYearTo);
  
  const deathYearFrom = searchParams.get('deathYearFrom');
  if (deathYearFrom) filters.deathYearFrom = parseInt(deathYearFrom);
  
  const deathYearTo = searchParams.get('deathYearTo');
  if (deathYearTo) filters.deathYearTo = parseInt(deathYearTo);
  
  const sortBy = searchParams.get('sortBy');
  if (sortBy === 'id' || sortBy === 'lastName' || sortBy === 'birthDate' || sortBy === 'deathDate' || sortBy === 'movieCount') {
    filters.sortBy = sortBy;
  }
  
  const sortOrder = searchParams.get('sortOrder');
  if (sortOrder === 'asc' || sortOrder === 'desc') {
    filters.sortOrder = sortOrder;
  }
  
  const page = searchParams.get('page');
  if (page) filters.page = parseInt(page);
  
  return filters;
}

/**
 * Convierte filtros a par√°metros de API
 */
export function filtersToApiParams(filters: PersonListFilters): Record<string, string> {
  const params: Record<string, string> = {};
  
  if (filters.search) params.search = filters.search;
  if (filters.gender) params.gender = filters.gender;
  if (filters.birthLocationId) params.birthLocationId = String(filters.birthLocationId);
  if (filters.deathLocationId) params.deathLocationId = String(filters.deathLocationId);
  if (filters.nationalityId) params.nationalityId = String(filters.nationalityId);
  if (filters.roleId) params.roleId = String(filters.roleId);
  if (filters.birthYearFrom) params.birthYearFrom = String(filters.birthYearFrom);
  if (filters.birthYearTo) params.birthYearTo = String(filters.birthYearTo);
  if (filters.deathYearFrom) params.deathYearFrom = String(filters.deathYearFrom);
  if (filters.deathYearTo) params.deathYearTo = String(filters.deathYearTo);
  if (filters.sortBy) params.sortBy = filters.sortBy;
  if (filters.sortOrder) params.sortOrder = filters.sortOrder;
  if (filters.page) params.page = String(filters.page);
  if (filters.limit) params.limit = String(filters.limit);
  
  return params;
}

/**
 * Formatea el nombre completo de una persona
 */
export function formatPersonName(person: { firstName?: string | null; lastName?: string | null; realName?: string | null }): string {
  const name = [person.firstName, person.lastName].filter(Boolean).join(' ');
  return name || person.realName || 'Sin nombre';
}

/**
 * Formatea la fecha de nacimiento/muerte para mostrar
 */
export function formatPartialDate(
  year?: number | null,
  month?: number | null,
  day?: number | null,
  options?: { includeAge?: boolean; currentYear?: number }
): string {
  if (!year) return '';
  
  const months = [
    'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
    'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
  ];
  
  let dateStr = '';
  
  if (day && month) {
    dateStr = `${day} de ${months[month - 1]} de ${year}`;
  } else if (month) {
    dateStr = `${months[month - 1]} de ${year}`;
  } else {
    dateStr = String(year);
  }
  
  return dateStr;
}

/**
 * Calcula la edad entre dos fechas parciales
 */
export function calculateAge(
  birthYear?: number | null,
  birthMonth?: number | null,
  birthDay?: number | null,
  deathYear?: number | null,
  deathMonth?: number | null,
  deathDay?: number | null
): number | null {
  if (!birthYear) return null;
  
  const endYear = deathYear || new Date().getFullYear();
  const endMonth = deathMonth || new Date().getMonth() + 1;
  const endDay = deathDay || new Date().getDate();
  
  let age = endYear - birthYear;
  
  // Ajustar si a√∫n no lleg√≥ el cumplea√±os
  if (birthMonth && endMonth) {
    if (endMonth < birthMonth) {
      age--;
    } else if (endMonth === birthMonth && birthDay && endDay < birthDay) {
      age--;
    }
  }
  
  return age >= 0 ? age : null;
}

/**
 * Formatea la ubicaci√≥n con su padre
 */
export function formatLocation(location: LocationFilterOption | null | undefined): string {
  if (!location) return '';
  
  if (location.fullPath) return location.fullPath;
  if (location.parentName) return `${location.name}, ${location.parentName}`;
  return location.name;
}

/**
 * Genera un array de a√±os para los selectores
 */
export function generateYearOptions(min: number, max: number): number[] {
  const years: number[] = [];
  for (let year = max; year >= min; year--) {
    years.push(year);
  }
  return years;
}

/**
 * Cuenta cu√°ntos filtros activos hay
 */
export function countActiveFilters(filters: PersonListFilters): number {
  let count = 0;
  
  if (filters.search) count++;
  if (filters.gender) count++;
  if (filters.birthLocationId) count++;
  if (filters.deathLocationId) count++;
  if (filters.nationalityId) count++;
  if (filters.roleId) count++;
  if (filters.birthYearFrom) count++;
  if (filters.birthYearTo) count++;
  if (filters.deathYearFrom) count++;
  if (filters.deathYearTo) count++;
  
  return count;
}

/**
 * Verifica si hay filtros activos (excluyendo ordenamiento y paginaci√≥n)
 */
export function hasActiveFilters(filters: PersonListFilters): boolean {
  return countActiveFilters(filters) > 0;
}

/**
 * Limpia todos los filtros manteniendo ordenamiento
 */
export function clearFilters(filters: PersonListFilters): PersonListFilters {
  return {
    ...DEFAULT_PERSON_FILTERS,
    sortBy: filters.sortBy,
    sortOrder: filters.sortOrder,
    limit: filters.limit
  };
}


// ==================================================
// src/lib/prisma.ts
// ==================================================
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client'

// Configurar serializaci√≥n de BigInt globalmente
(BigInt.prototype as any).toJSON = function() {
  return this.toString()
}

const globalForPrisma = global as unknown as { 
  prisma: ReturnType<typeof createPrismaClient>
  prismaBase: PrismaClient | undefined
}

// Obtener DATABASE_URL
const DATABASE_URL = process.env.DATABASE_URL || ''

// Extraer el connection_limit de la URL si existe
let connectionLimit = 20 // default
try {
  const url = new URL(DATABASE_URL)
  connectionLimit = parseInt(url.searchParams.get('connection_limit') || '20')
  console.log(`Configurando pool con ${connectionLimit} conexiones`)
} catch (e) {
  console.log('No se pudo parsear DATABASE_URL, usando pool default de 20')
}

// Cliente base para NextAuth (sin extensiones)
export const prismaBase = globalForPrisma.prismaBase || new PrismaClient({
  datasources: {
    db: {
      url: DATABASE_URL
    }
  },
  log: process.env.NODE_ENV === 'development' 
    ? ['error', 'warn'] 
    : ['error'],
  errorFormat: 'minimal',
})

// Cliente extendido para la app
const createPrismaClient = () => {
  return prismaBase.$extends({
    query: {
      // Middleware para logging de queries lentas y retry
      $allOperations: async ({ operation, model, args, query }) => {
        const before = Date.now()
        
        // Retry logic integrado
        let retries = 0
        const maxRetries = 3
        let lastError: any
        
        while (retries < maxRetries) {
          try {
            const result = await query(args)
            const after = Date.now()
            const duration = after - before
            
            // Log queries que toman m√°s de 1 segundo
            if (duration > 1000) {
              console.warn(`Slow query (${duration}ms):`, {
                model,
                operation,
                duration: `${duration}ms`
              })
            }
            
            return result
          } catch (error: any) {
            lastError = error
            retries++
            
            // Solo reintentar en errores de conexi√≥n espec√≠ficos
            const isRetryable = error?.code === 'P1001' || // Can't reach database
                              error?.code === 'P1002' || // Database timeout
                              error?.code === 'P2024'    // Pool timeout
            
            if (!isRetryable || retries >= maxRetries) {
              throw error
            }
            
            const delay = Math.min(retries * 100, 1000) // Max 1 segundo de espera
            console.log(`Retrying query (attempt ${retries}/${maxRetries}) after ${delay}ms`)
            await new Promise(resolve => setTimeout(resolve, delay))
          }
        }
        
        throw lastError || new Error('Max retries reached')
      }
    }
  })
}

export const prisma = globalForPrisma.prisma || createPrismaClient()

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
  globalForPrisma.prismaBase = prismaBase
}

// Graceful shutdown
if (process.env.NODE_ENV === 'production') {
  process.on('beforeExit', async () => {
    console.log('Disconnecting Prisma Client...')
    await prisma.$disconnect()
    await prismaBase.$disconnect()
  })
}

// Log inicial en producci√≥n
if (process.env.NODE_ENV === 'production') {
  console.log('Prisma Client inicializado en producci√≥n')
}

// ==================================================
// src/lib/redis.ts
// ==================================================
// src/lib/redis.ts
import { Redis } from 'ioredis';

const getRedisUrl = () => {
  // Si hay una URL expl√≠cita, usarla
  if (process.env.REDIS_URL) {
    return process.env.REDIS_URL;
  }
  
  // En desarrollo local, no intentar conectar a Redis por defecto
  if (process.env.NODE_ENV === 'development') {
    return null;
  }
  
  // En producci√≥n (Docker), usar el hostname del servicio
  return 'redis://redis:6379';
};

class RedisClient {
  private static instance: Redis | null = null;
  private static isRedisEnabled: boolean = true;
  private static connectionAttempted: boolean = false;
  
  static getInstance(): Redis | null {
    // Si ya intentamos y fall√≥, no reintentar
    if (this.connectionAttempted && !this.instance) {
      return null;
    }
    
    if (!this.instance) {
      const redisUrl = getRedisUrl();
      
      // Si no hay URL (desarrollo sin Redis), marcar como deshabilitado
      if (!redisUrl) {
        this.isRedisEnabled = false;
        this.connectionAttempted = true;
        console.log('üìå Redis deshabilitado - usando solo cach√© en memoria');
        return null;
      }
      
      try {
        this.connectionAttempted = true;
        this.instance = new Redis(redisUrl, {
          maxRetriesPerRequest: 1,
          enableOfflineQueue: false,
          retryStrategy: (times) => {
            if (times > 1) {
              this.isRedisEnabled = false;
              console.log('‚ö†Ô∏è Redis no disponible - continuando con cach√© en memoria');
              return null;
            }
            return 500;
          },
          lazyConnect: true,
          connectTimeout: 3000,
        });

        // Solo mostrar errores una vez
        let errorShown = false;
        this.instance.on('error', (err) => {
          if (!errorShown) {
            console.log('‚ö†Ô∏è Redis no disponible - usando cach√© en memoria');
            errorShown = true;
          }
          this.isRedisEnabled = false;
        });

        this.instance.on('connect', () => {
          console.log('‚úÖ Redis conectado exitosamente');
          this.isRedisEnabled = true;
        });

        // Intentar conectar de forma as√≠ncrona
        this.instance.connect().catch(() => {
          this.isRedisEnabled = false;
          this.instance = null;
        });

      } catch (error) {
        this.isRedisEnabled = false;
        this.instance = null;
        console.log('‚ö†Ô∏è Redis no configurado - usando cach√© en memoria');
      }
    }
    
    return this.isRedisEnabled ? this.instance : null;
  }

  static async get(key: string): Promise<string | null> {
    if (!this.isRedisEnabled) return null;
    
    const client = this.getInstance();
    if (!client) return null;
    
    try {
      return await client.get(key);
    } catch (error) {
      return null;
    }
  }

  static async set(
    key: string, 
    value: string, 
    expirationInSeconds?: number
  ): Promise<boolean> {
    if (!this.isRedisEnabled) return false;
    
    const client = this.getInstance();
    if (!client) return false;
    
    try {
      if (expirationInSeconds) {
        await client.setex(key, expirationInSeconds, value);
      } else {
        await client.set(key, value);
      }
      return true;
    } catch (error) {
      return false;
    }
  }

  static async del(key: string): Promise<boolean> {
    if (!this.isRedisEnabled) return false;
    
    const client = this.getInstance();
    if (!client) return false;
    
    try {
      await client.del(key);
      return true;
    } catch (error) {
      return false;
    }
  }

  static async flush(): Promise<boolean> {
    if (!this.isRedisEnabled) return false;
    
    const client = this.getInstance();
    if (!client) return false;
    
    try {
      await client.flushdb();
      return true;
    } catch (error) {
      return false;
    }
  }
}

export default RedisClient;

// ==================================================
// src/lib/roles/rolesTypes.ts
// ==================================================
// src/lib/roles/rolesTypes.ts

import { z } from 'zod';

// Enum de departamentos
export enum Department {
  DIRECCION = 'DIRECCION',
  PRODUCCION = 'PRODUCCION',
  GUION = 'GUION',
  FOTOGRAFIA = 'FOTOGRAFIA',
  ARTE = 'ARTE',
  MONTAJE = 'MONTAJE',
  SONIDO = 'SONIDO',
  MUSICA = 'MUSICA',
  VESTUARIO = 'VESTUARIO',
  MAQUILLAJE = 'MAQUILLAJE',
  EFECTOS = 'EFECTOS',
  ANIMACION = 'ANIMACION',
  POSTPRODUCCION = 'POSTPRODUCCION',
  OTROS = 'OTROS'
}

// Labels para mostrar al usuario
/**
 * DEPARTMENT_LABELS
 * @TODO Add documentation
 */
export const DEPARTMENT_LABELS = {
  [Department.DIRECCION]: 'Direcci√≥n',
  [Department.PRODUCCION]: 'Producci√≥n',
  [Department.GUION]: 'Gui√≥n',
  [Department.FOTOGRAFIA]: 'Direcci√≥n de Fotograf√≠a',
  [Department.ARTE]: 'Direcci√≥n de Arte',
  [Department.MONTAJE]: 'Montaje',
  [Department.SONIDO]: 'Sonido',
  [Department.MUSICA]: 'M√∫sica',
  [Department.VESTUARIO]: 'Vestuario',
  [Department.MAQUILLAJE]: 'Maquillaje',
  [Department.EFECTOS]: 'Efectos',
  [Department.ANIMACION]: 'Animaci√≥n',
  [Department.POSTPRODUCCION]: 'Postproducci√≥n',
  [Department.OTROS]: 'Otros'
} as const;

// Colores para badges
/**
 * DEPARTMENT_COLORS
 * @TODO Add documentation
 */
export const DEPARTMENT_COLORS = {
  [Department.DIRECCION]: '#dc2626',
  [Department.PRODUCCION]: '#059669',
  [Department.GUION]: '#7c3aed',
  [Department.FOTOGRAFIA]: '#2563eb',
  [Department.ARTE]: '#ea580c',
  [Department.MONTAJE]: '#be185d',
  [Department.SONIDO]: '#0891b2',
  [Department.MUSICA]: '#7c2d12',
  [Department.VESTUARIO]: '#9333ea',
  [Department.MAQUILLAJE]: '#c2410c',
  [Department.EFECTOS]: '#0369a1',
  [Department.ANIMACION]: '#ca8a04',
  [Department.POSTPRODUCCION]: '#4f46e5',
  [Department.OTROS]: '#6b7280'
} as const;

// Interfaces principales
export interface Role {
  id: number;
  name: string;
  slug: string;
  department: Department;
  description?: string | null;
  isMainRole: boolean;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  _count?: {
    crewRoles: number;
  };
}

// Formularios
export interface RoleFormData {
  name: string;
  description?: string;
  department: Department;
  isMainRole?: boolean;
  isActive?: boolean;
}

// Filtros
export interface RoleFilters {
  search?: string;
  department?: Department | '';
  isActive?: boolean | '';
  isMainRole?: boolean | '';
  page?: number;
  limit?: number;
}

// Respuestas paginadas
export interface PaginatedRolesResponse {
  data: Role[];
  totalCount: number;
  page: number;
  totalPages: number;
  hasMore: boolean;
}

// Validaci√≥n con Zod
/**
 * roleSchema
 * @TODO Add documentation
 */
export const roleSchema = z.object({
  name: z.string()
    .min(1, 'El nombre es requerido')
    .max(100, 'M√°ximo 100 caracteres')
    .trim(),
  description: z.string()
    .max(500, 'M√°ximo 500 caracteres')
    .optional()
    .or(z.literal('')),
  department: z.nativeEnum(Department, {
    errorMap: () => ({ message: 'Debe seleccionar un departamento' })
  }),
  isMainRole: z.boolean().optional(),
  isActive: z.boolean().optional()
});

export type RoleFormSchema = z.infer<typeof roleSchema>;

// Utilidades
/**
 * getDepartmentLabel
 * @TODO Add documentation
 */
export const getDepartmentLabel = (department: Department): string => {
  return DEPARTMENT_LABELS[department] || department;
};

/**
 * getDepartmentColor
 * @TODO Add documentation
 */
export const getDepartmentColor = (department: Department): string => {
  return DEPARTMENT_COLORS[department] || '#6b7280';
};

/**
 * getDepartmentOptions
 * @TODO Add documentation
 */
export const getDepartmentOptions = () => {
  return Object.values(Department).map(dept => ({
    value: dept,
    label: getDepartmentLabel(dept),
    color: getDepartmentColor(dept)
  }));
};

// ==================================================
// src/lib/roles/roleUtils.ts
// ==================================================
// src/lib/roles/roleUtils.ts
import { 
  Department, 
  DEPARTMENT_LABELS, 
  DEPARTMENT_COLORS,
  getDepartmentLabel as getLabel,
  getDepartmentColor as getColor,
  getDepartmentOptions as getOptions
} from './rolesTypes';

// Re-exportar el enum para mantener compatibilidad con imports existentes
/**
 * DEPARTMENTS
 * @TODO Add documentation
 */
export const DEPARTMENTS = Department;

// Re-exportar funciones desde rolesTypes
/**
 * getDepartmentLabel
 * @TODO Add documentation
 */
export const getDepartmentLabel = getLabel;
/**
 * getDepartmentColor
 * @TODO Add documentation
 */
export const getDepartmentColor = getColor;
/**
 * getDepartmentOptions
 * @TODO Add documentation
 */
export const getDepartmentOptions = getOptions;

/**
 * sortRolesByDepartment
 * @TODO Add documentation
 */
export function sortRolesByDepartment(roles: any[]): any[] {
  return [...roles].sort((a, b) => {
    // Roles principales primero
    if (a.isMainRole && !b.isMainRole) return -1;
    if (!a.isMainRole && b.isMainRole) return 1;
    
    // Por orden de departamento
    const deptOrder = Object.keys(DEPARTMENTS);
    const aIndex = deptOrder.indexOf(a.department);
    const bIndex = deptOrder.indexOf(b.department);
    
    if (aIndex !== bIndex) {
      return aIndex - bIndex;
    }
    
    // Alfab√©tico por nombre
    return a.name.localeCompare(b.name, 'es');
  });
}

/**
 * validateRole
 * @TODO Add documentation
 */
export function validateRole(name: string, department: Department): string | null {
  if (!name || name.trim().length === 0) {
    return 'El nombre del rol es requerido';
  }
  
  if (name.trim().length < 2) {
    return 'El nombre del rol debe tener al menos 2 caracteres';
  }
  
  if (name.trim().length > 100) {
    return 'El nombre del rol no puede exceder 100 caracteres';
  }
  
  if (!Object.values(Department).includes(department as Department)) {
    return 'Departamento inv√°lido';
  }
  
  return null;
}

// ==================================================
// src/lib/schemas.ts
// ==================================================
// src/lib/schemas.ts
import { z } from 'zod'

export const movieSchema = z.object({
  // Informaci√≥n b√°sica
  title: z.string().min(1, 'El t√≠tulo es requerido'),
  originalTitle: z.string().optional(),
  year: z.number().optional(),

  // Fechas como campos separados Y fechas completas para el formulario
  releaseDate: z.string().optional(),
  releaseYear: z.number().nullable().optional(),
  releaseMonth: z.number().nullable().optional(),
  releaseDay: z.number().nullable().optional(),

  filmingStartDate: z.string().optional(),
  filmingStartYear: z.number().nullable().optional(),
  filmingStartMonth: z.number().nullable().optional(),
  filmingStartDay: z.number().nullable().optional(),

  filmingEndDate: z.string().optional(),
  filmingEndYear: z.number().nullable().optional(),
  filmingEndMonth: z.number().nullable().optional(),
  filmingEndDay: z.number().nullable().optional(),

  // Duraci√≥n
  duration: z.number().optional().transform(val => val === 0 ? null : val),
  durationSeconds: z.number().optional().transform(val => val === 0 ? null : val),
  tipoDuracion: z.string().optional(),

  // Contenido
  synopsis: z.string().optional(),
  synopsisLocked: z.boolean().optional(),
  notes: z.string().optional(),
  tagline: z.string().optional(),

  // Media
  posterUrl: z.string().optional(),
  posterPublicId: z.string().optional(),
  backdropUrl: z.string().optional(),
  backdropPublicId: z.string().optional(),
  trailerUrl: z.string().optional(),

  // IDs externos
  imdbId: z.string().optional(),

  // Informaci√≥n t√©cnica
  aspectRatio: z.string().optional(),
  colorTypeId: z.number().optional(),
  soundType: z.string().optional(),
  filmFormat: z.string().optional(),

  // AGREGAR ESTOS CAMPOS DE METADATA
  metaDescription: z.string().optional(),
  metaKeywords: z.union([
    z.string(),
    z.array(z.string())
  ]).optional(),

  // Clasificaci√≥n
  ratingId: z.union([
    z.number().positive(),  // Solo n√∫meros positivos
    z.null(),               // O null
    z.literal(0).transform(() => null)  // Transforma 0 a null
  ]).optional(),
  certificateNumber: z.string().optional(),

  // Estado
  stage: z.enum([
    'COMPLETA',
    'EN_DESARROLLO',
    'EN_POSTPRODUCCION',
    'EN_PREPRODUCCION',
    'EN_RODAJE',
    'INCONCLUSA',
    'INEDITA'
  ]).optional(),
  dataCompleteness: z.enum([
    'BASIC_PRESS_KIT',
    'FULL_PRESS_KIT',
    'MAIN_CAST',
    'MAIN_CREW',
    'FULL_CAST',
    'FULL_CREW'
  ]).optional(),

  // Pa√≠s y coproducci√≥n
  countries: z.array(z.number()).optional(),
  is_coproduction: z.boolean().optional(),
  production_type: z.string().optional(),

  // Relaciones (arrays de IDs)
  genres: z.array(z.number().positive())
    .optional()
    .default([])
    .transform(val => val.filter(v => v > 0 && !isNaN(v))),
  cast: z.array(z.any()).optional(),
  crew: z.array(z.any()).optional(),
  productionCompanies: z.array(z.number()).optional(),
  distributionCompanies: z.array(z.number()).optional(),
  themes: z.array(z.number()).optional(),
  alternativeTitles: z.array(z.any()).optional(),
  links: z.array(z.any()).optional(),
  screeningVenues: z.array(z.object({
    venueId: z.number(),
    screeningDate: z.string().optional().nullable(),
    isPremiere: z.boolean().optional(),
    isExclusive: z.boolean().optional()
  })).optional()
})

export type MovieFormData = z.infer<typeof movieSchema>

// ==================================================
// src/lib/shared/dateUtils.ts
// ==================================================
// src/lib/shared/dateUtils.ts

/**
 * Tipo compartido para fechas parciales
 */
export interface PartialDate {
  year: number | null;
  month: number | null;
  day: number | null;
}

/**
 * Meses en espa√±ol para los selectores
 */
export const MONTHS = [
  { value: 1, label: 'Enero' },
  { value: 2, label: 'Febrero' },
  { value: 3, label: 'Marzo' },
  { value: 4, label: 'Abril' },
  { value: 5, label: 'Mayo' },
  { value: 6, label: 'Junio' },
  { value: 7, label: 'Julio' },
  { value: 8, label: 'Agosto' },
  { value: 9, label: 'Septiembre' },
  { value: 10, label: 'Octubre' },
  { value: 11, label: 'Noviembre' },
  { value: 12, label: 'Diciembre' }
];

/**
 * Convierte una fecha completa (string ISO) a campos parciales
 * IMPORTANTE: Maneja correctamente las zonas horarias para evitar el problema del d√≠a anterior
 */
export function dateToPartialFields(dateString: string | null | undefined): PartialDate {
  if (!dateString) {
    return { year: null, month: null, day: null };
  }
  
  // Si el string viene en formato ISO (YYYY-MM-DD), parsearlo directamente
  // sin crear un objeto Date para evitar problemas de timezone
  if (dateString.match(/^\d{4}-\d{2}-\d{2}/)) {
    const [yearStr, monthStr, dayStr] = dateString.split('-');
    return {
      year: parseInt(yearStr, 10),
      month: parseInt(monthStr, 10),
      day: parseInt(dayStr, 10)
    };
  }
  
  // Si viene con tiempo (formato ISO completo con T), usar Date pero ajustar
  const date = new Date(dateString);
  
  // Si la fecha incluye 'T', ya est√° en formato ISO completo
  if (dateString.includes('T')) {
    return {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      day: date.getDate()
    };
  }
  
  // Para otros formatos, intentar parsear con Date
  // pero usar getUTC* para evitar ajustes de timezone
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate()
  };
}

/**
 * Convierte campos parciales a una fecha completa si es posible
 * Retorna en formato YYYY-MM-DD sin informaci√≥n de hora para evitar problemas de timezone
 */
export function partialFieldsToDate(partial: PartialDate): string | null {
  if (!partial.year || !partial.month || !partial.day) {
    return null;
  }
  
  // Formato ISO: YYYY-MM-DD
  const year = partial.year.toString().padStart(4, '0');
  const month = partial.month.toString().padStart(2, '0');
  const day = partial.day.toString().padStart(2, '0');
  
  return `${year}-${month}-${day}`;
}

/**
 * Formatea una fecha parcial para mostrar
 * @param partial - La fecha parcial
 * @param options - Opciones de formato
 */
export function formatPartialDate(
  partial: PartialDate,
  options: {
    monthFormat?: 'short' | 'long';
    includeDay?: boolean;
    fallback?: string;
  } = {}
): string {
  const {
    monthFormat = 'long',
    includeDay = true,
    fallback = 'Fecha desconocida'
  } = options;

  if (!partial.year) {
    return fallback;
  }
  
  const monthNames = {
    short: [
      'Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun',
      'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'
    ],
    long: [
      'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
      'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
    ]
  };
  
  // Solo a√±o
  if (!partial.month) {
    return partial.year.toString();
  }
  
  const monthName = monthNames[monthFormat][partial.month - 1];
  
  // A√±o y mes
  if (!partial.day || !includeDay) {
    return monthFormat === 'long' 
      ? `${monthName} de ${partial.year}`
      : `${monthName} ${partial.year}`;
  }
  
  // Fecha completa
  return monthFormat === 'long'
    ? `${partial.day} de ${monthName} de ${partial.year}`
    : `${partial.day} ${monthName} ${partial.year}`;
}

/**
 * Calcula la edad o a√±os transcurridos entre dos fechas parciales
 * @param startDate - Fecha de inicio (nacimiento, estreno, etc.)
 * @param endDate - Fecha de fin (muerte, fecha actual, etc.). Si no se proporciona, usa la fecha actual
 */
export function calculateYearsBetween(
  startDate: PartialDate,
  endDate?: PartialDate
): number | null {
  if (!startDate.year) {
    return null;
  }
  
  const currentDate = new Date();
  const referenceYear = endDate?.year || currentDate.getFullYear();
  const referenceMonth = endDate?.month || (currentDate.getMonth() + 1);
  const referenceDay = endDate?.day || currentDate.getDate();
  
  let years = referenceYear - startDate.year;
  
  // Ajustar si no ha llegado el aniversario
  if (startDate.month && referenceMonth) {
    if (referenceMonth < startDate.month) {
      years--;
    } else if (referenceMonth === startDate.month && startDate.day && referenceDay) {
      if (referenceDay < startDate.day) {
        years--;
      }
    }
  }
  
  return years;
}

/**
 * Valida que una fecha parcial sea v√°lida
 * @param partial - La fecha parcial a validar
 * @param options - Opciones de validaci√≥n
 */
export function validatePartialDate(
  partial: PartialDate,
  options: {
    minYear?: number;
    maxYear?: number;
    allowFuture?: boolean;
    fieldName?: string;
  } = {}
): string | null {
  const {
    minYear = 1800,
    maxYear = new Date().getFullYear() + 1,
    allowFuture = false,
    fieldName = 'fecha'
  } = options;
  
  // Si no hay a√±o, es v√°lido (fecha vac√≠a)
  if (!partial.year) {
    if (partial.month || partial.day) {
      return `Si ingresa mes o d√≠a, debe ingresar tambi√©n el a√±o`;
    }
    return null;
  }
  
  // Validar a√±o
  const currentYear = new Date().getFullYear();
  const effectiveMaxYear = allowFuture ? maxYear : Math.min(maxYear, currentYear);
  
  if (partial.year < minYear || partial.year > effectiveMaxYear) {
    return `El a√±o de ${fieldName} debe estar entre ${minYear} y ${effectiveMaxYear}`;
  }
  
  // Si hay mes, validarlo
  if (partial.month) {
    if (partial.month < 1 || partial.month > 12) {
      return `El mes debe estar entre 1 y 12`;
    }
    
    // Si hay d√≠a, validarlo seg√∫n el mes
    if (partial.day) {
      const daysInMonth = new Date(partial.year, partial.month, 0).getDate();
      if (partial.day < 1 || partial.day > daysInMonth) {
        return `El d√≠a debe estar entre 1 y ${daysInMonth} para el mes seleccionado`;
      }
    }
  } else if (partial.day) {
    return `Si ingresa d√≠a, debe ingresar tambi√©n el mes`;
  }
  
  return null;
}

/**
 * Compara dos fechas parciales
 * @returns -1 si date1 < date2, 0 si son iguales, 1 si date1 > date2, null si no se pueden comparar
 */
export function comparePartialDates(date1: PartialDate, date2: PartialDate): number | null {
  // Si alguna no tiene a√±o, no se pueden comparar
  if (!date1.year || !date2.year) {
    return null;
  }
  
  // Comparar a√±os
  if (date1.year !== date2.year) {
    return date1.year < date2.year ? -1 : 1;
  }
  
  // Si ambas tienen mes, comparar
  if (date1.month && date2.month) {
    if (date1.month !== date2.month) {
      return date1.month < date2.month ? -1 : 1;
    }
    
    // Si ambas tienen d√≠a, comparar
    if (date1.day && date2.day) {
      if (date1.day !== date2.day) {
        return date1.day < date2.day ? -1 : 1;
      }
      return 0; // Son iguales
    }
  }
  
  // Si una tiene m√°s precisi√≥n que la otra, considerarlas iguales en el nivel comparable
  return 0;
}

/**
 * Valida un rango de fechas parciales
 */
export function validateDateRange(
  startDate: PartialDate,
  endDate: PartialDate,
  startFieldName: string = 'inicio',
  endFieldName: string = 'fin'
): string | null {
  // Primero validar cada fecha individualmente
  const startError = validatePartialDate(startDate, { fieldName: startFieldName });
  if (startError) return startError;
  
  const endError = validatePartialDate(endDate, { fieldName: endFieldName });
  if (endError) return endError;
  
  // Si ambas tienen a√±o, verificar que el rango sea v√°lido
  if (startDate.year && endDate.year) {
    const comparison = comparePartialDates(startDate, endDate);
    if (comparison === 1) {
      return `La fecha de ${startFieldName} no puede ser posterior a la fecha de ${endFieldName}`;
    }
  }
  
  return null;
}

/**
 * Crea una fecha parcial desde valores de formulario
 */
export function createPartialDate(
  year: string | number | null | undefined,
  month: string | number | null | undefined,
  day: string | number | null | undefined
): PartialDate {
  return {
    year: year ? (typeof year === 'string' ? parseInt(year) : year) : null,
    month: month ? (typeof month === 'string' ? parseInt(month) : month) : null,
    day: day ? (typeof day === 'string' ? parseInt(day) : day) : null
  };
}

/**
 * Verifica si una fecha parcial est√° completa
 */
export function isCompleteDate(partial: PartialDate): boolean {
  return !!(partial.year && partial.month && partial.day);
}

/**
 * Verifica si una fecha parcial est√° vac√≠a
 */
export function isEmptyDate(partial: PartialDate): boolean {
  return !partial.year && !partial.month && !partial.day;
}

// ==================================================
// src/lib/utils/efemerides.ts
// ==================================================
// src/lib/utils/efemerides.ts - ACTUALIZADO CON SOPORTE PARA M√öLTIPLES DIRECTORES

import { Efemeride, DirectorInfo } from '@/types/home.types';

export interface EfemerideData {
  tipo: 'pelicula' | 'persona';
  fecha: Date;
  a√±o: number;
  mes: number;
  dia: number;
  titulo?: string;
  nombre?: string;
  tipoEvento: 'estreno' | 'inicio_rodaje' | 'fin_rodaje' | 'nacimiento' | 'muerte';
  slug?: string;
  posterUrl?: string;
  photoUrl?: string;
  director?: string; // Mantiene compatibilidad - nombre concatenado
  directorSlug?: string; // Mantiene compatibilidad - slug del primero
  directors?: DirectorInfo[]; // Nuevo: array de directores
}

export function calcularAniosDesde(a√±o: number, mes: number, dia: number): number | null {
  const hoy = new Date();
  const a√±osTranscurridos = hoy.getFullYear() - a√±o;
  
  if (a√±osTranscurridos < 0) {
    return null;
  }
  
  return a√±osTranscurridos;
}

/**
 * Formatea los nombres de directores para mostrar en texto
 * Ej: "Fabi√°n Bielinsky" o "Juan P√©rez y Mar√≠a Garc√≠a" o "A, B y C"
 */
function formatDirectorNames(directors: DirectorInfo[]): string {
  if (!directors || directors.length === 0) return '';
  
  if (directors.length === 1) {
    return directors[0].name;
  }
  
  if (directors.length === 2) {
    return `${directors[0].name} y ${directors[1].name}`;
  }
  
  // 3 o m√°s: "A, B y C"
  const allButLast = directors.slice(0, -1).map(d => d.name).join(', ');
  const last = directors[directors.length - 1].name;
  return `${allButLast} y ${last}`;
}

export function formatearEfemeride(data: EfemerideData): Efemeride | null {
  const a√±osDesde = calcularAniosDesde(data.a√±o, data.mes, data.dia);
  
  // ‚úÖ CORRECCI√ìN: <= 0 para excluir a√±o actual
  if (a√±osDesde === null || a√±osDesde <= 0) return null;
  
  // Determinar el texto de directores
  const directorText = data.directors && data.directors.length > 0
    ? formatDirectorNames(data.directors)
    : data.director || '';
  
  let evento = '';
  
  if (data.tipo === 'pelicula') {
    switch (data.tipoEvento) {
      case 'estreno':
        evento = `se estrenaba "${data.titulo}"${directorText ? `, de ${directorText}` : ''}`;
        break;
      case 'inicio_rodaje':
        evento = `empezaba el rodaje de "${data.titulo}"${directorText ? `, de ${directorText}` : ''}`;
        break;
      case 'fin_rodaje':
        evento = `terminaba el rodaje de "${data.titulo}"${directorText ? `, de ${directorText}` : ''}`;
        break;
    }
  } else if (data.tipo === 'persona') {
    switch (data.tipoEvento) {
      case 'nacimiento':
        evento = `nac√≠a ${data.nombre}`;
        break;
      case 'muerte':
        evento = `mor√≠a ${data.nombre}`;
        break;
    }
  }
  
  return {
    id: `${data.tipo}-${data.tipoEvento}-${data.slug || data.a√±o}`,
    tipo: data.tipo,
    hace: `Hace ${a√±osDesde} ${a√±osDesde === 1 ? 'a√±o' : 'a√±os'}`,
    evento,
    fecha: new Date(data.a√±o, data.mes - 1, data.dia),
    slug: data.slug,
    posterUrl: data.posterUrl,
    photoUrl: data.photoUrl,
    titulo: data.tipo === 'pelicula' ? data.titulo : data.nombre,
    director: directorText, // Texto concatenado para compatibilidad
    directorSlug: data.directorSlug || (data.directors?.[0]?.slug), // Slug del primero
    directors: data.directors, // Array completo
    tipoEvento: data.tipoEvento
  };
}

// ==================================================
// src/lib/utils/slugs.ts
// ==================================================
// src/lib/utils/slugs.ts

import { PrismaClient } from '@prisma/client'

/**
 * Genera un hash simple a partir de un string
 * Usado como fallback cuando el t√≠tulo no tiene caracteres alfanum√©ricos
 */
function generateHash(text: string): string {
  let hash = 0
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash // Convert to 32bit integer
  }
  return Math.abs(hash).toString(36)
}

/**
 * Genera un slug a partir de un texto
 * Si el texto no contiene caracteres alfanum√©ricos, genera un slug basado en hash
 */
export function generateSlug(text: string): string {
  

  // Intentar generar slug normal
  const normalSlug = text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Elimina acentos
    .replace(/[^a-z0-9]+/g, '-') // Reemplaza caracteres especiales por guiones
    .replace(/^-+|-+$/g, '') // Elimina guiones al inicio y final
    .replace(/-+/g, '-') // Reemplaza m√∫ltiples guiones por uno solo

  

  // Si el slug resultante est√° vac√≠o o tiene menos de 2 caracteres
  // (caso de t√≠tulos como ")(", "!!", etc.)
  if (!normalSlug || normalSlug.length < 2) {
    // Generar un hash √∫nico basado en el t√≠tulo original
    const hash = generateHash(text)
    const result = `title-${hash}`

    return result
  }


  return normalSlug
}

/**
 * Genera un slug √∫nico verificando contra la base de datos
 */
export async function generateUniqueSlug(
  text: string,
  model: 'location' | 'movie' | 'person' | 'genre' | 'productionCompany' | 'distributionCompany',
  prisma: any,
  excludeId?: number
): Promise<string> {
  

  const baseSlug = generateSlug(text)

  

  // Si generateSlug() retorn√≥ un slug vac√≠o o muy corto,
  // significa que ya aplic√≥ el hash. No intentar agregar contadores
  // a un string vac√≠o (eso causar√≠a "-1" como slug)
  if (!baseSlug || baseSlug.length === 0) {
    console.warn(`generateSlug retorn√≥ string vac√≠o para: "${text}". Esto no deber√≠a ocurrir.`)
    // Generar hash directamente como fallback de seguridad
    const hash = generateHash(text)
    return `title-${hash}`
  }

  let slug = baseSlug
  let counter = 1

  while (true) {
    let exists = false

    switch (model) {
      case 'location':
        const locationQuery: any = { slug }
        if (excludeId) locationQuery.NOT = { id: excludeId }
        exists = await prisma.location.findFirst({ where: locationQuery }) !== null
        break
      case 'movie':
        const movieQuery: any = { slug }
        if (excludeId) movieQuery.NOT = { id: excludeId }
        exists = await prisma.movie.findFirst({ where: movieQuery }) !== null
        break
      case 'person':
        const personQuery: any = { slug }
        if (excludeId) personQuery.NOT = { id: excludeId }
        exists = await prisma.person.findFirst({ where: personQuery }) !== null
        break
      case 'genre':
        const genreQuery: any = { slug }
        if (excludeId) genreQuery.NOT = { id: excludeId }
        exists = await prisma.genre.findFirst({ where: genreQuery }) !== null
        break
      case 'productionCompany':
        const prodQuery: any = { slug }
        if (excludeId) prodQuery.NOT = { id: excludeId }
        exists = await prisma.productionCompany.findFirst({ where: prodQuery }) !== null
        break
      case 'distributionCompany':
        const distQuery: any = { slug }
        if (excludeId) distQuery.NOT = { id: excludeId }
        exists = await prisma.distributionCompany.findFirst({ where: distQuery }) !== null
        break
    }

    

    if (!exists) {
    
      return slug
    }

    // Si existe, agregar un n√∫mero al final
    slug = `${baseSlug}-${counter}`
    counter++
  }
}

// ==================================================
// src/lib/utils.ts
// ==================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

/**
 * Combina clases de Tailwind CSS de forma segura
 * @param {...ClassValue} inputs - Clases CSS a combinar
 * @returns {string} Clases combinadas y optimizadas
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * createSlug
 * @TODO Add documentation
 */
export function createSlug(text: string): string {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Eliminar acentos
    .replace(/[^a-z0-9]+/g, '-') // Reemplazar caracteres especiales con guiones
    .replace(/^-+|-+$/g, '') // Eliminar guiones al inicio y final
    .replace(/-+/g, '-') // Reemplazar m√∫ltiples guiones con uno solo
}

/**
 * formatDate
 * @TODO Add documentation
 */
export function formatDate(date: Date | string | null): string {
  if (!date) return ''
  const d = new Date(date)
  return d.toLocaleDateString('es-AR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
}

/**
 * formatDuration
 * @TODO Add documentation
 */
export function formatDuration(minutes: number | null): string {
  if (!minutes) return ''
  const hours = Math.floor(minutes / 60)
  const mins = minutes % 60
  return `${hours}h ${mins}min`
}

// ==================================================
// src/middleware.ts
// ==================================================
// src/middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'

// Rate limiting con memoria (el middleware no soporta Redis)
const requestCounts = new Map<string, { count: number; resetTime: number }>()

// L√çMITES ACTUALIZADOS PARA PRODUCCI√ìN
const RATE_LIMITS = {
  api: { requests: 1000, window: 60000 },      // 1000 req/min
  static: { requests: 2000, window: 60000 },   // 2000 req/min  
  auth: { requests: 10, window: 300000 },      // 10 req/5min
  search: { requests: 500, window: 60000 }     // 500 req/min para b√∫squedas
}

function getRateLimitKey(req: NextRequest): string {
  const forwarded = req.headers.get('x-forwarded-for')
  const ip = forwarded ? forwarded.split(',')[0] : req.ip || 'unknown'
  return ip
}

function checkRateLimit(key: string, limit: typeof RATE_LIMITS.api): boolean {
  const now = Date.now()
  const record = requestCounts.get(key)
  
  if (!record || record.resetTime < now) {
    requestCounts.set(key, { count: 1, resetTime: now + limit.window })
    return true
  }
  
  if (record.count >= limit.requests) {
    return false
  }
  
  record.count++
  return true
}

// Limpiar registros viejos cada 5 minutos
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    const now = Date.now()
    for (const [key, value] of requestCounts.entries()) {
      if (value.resetTime < now) {
        requestCounts.delete(key)
      }
    }
  }, 300000)
}

export async function middleware(request: NextRequest) {
  const response = NextResponse.next()
  const path = request.nextUrl.pathname
  
  // ============ PROTECCI√ìN DE ADMIN ============
  if (path.startsWith('/admin')) {
    if (path === '/admin/login') {
      return response
    }
    
    try {
      const token = await getToken({ 
        req: request, 
        secret: process.env.NEXTAUTH_SECRET 
      })
      
      if (!token) {
        const loginUrl = new URL('/admin/login', request.url)
        loginUrl.searchParams.set('callbackUrl', path)
        return NextResponse.redirect(loginUrl)
      }
      
      const hasAdminAccess = 
        token.role === 'ADMIN' || 
        token.role === 'EDITOR' ||
        token.isAdmin === true
      
      if (!hasAdminAccess) {
        return NextResponse.redirect(new URL('/unauthorized', request.url))
      }
    } catch (error) {
      console.error('Auth middleware error:', error)
      return NextResponse.redirect(new URL('/admin/login', request.url))
    }
  }
  
  // ============ HEADERS DE SEGURIDAD ============
  response.headers.set('X-DNS-Prefetch-Control', 'on')
  response.headers.set('X-Frame-Options', 'SAMEORIGIN')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('X-XSS-Protection', '1; mode=block')
  
  // CSP actualizado con Google Analytics, Cloudinary, AdSense y YouTube
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://www.google-analytics.com https://res.cloudinary.com https://upload-widget.cloudinary.com https://pagead2.googlesyndication.com https://adservice.google.com https://*.googlesyndication.com https://*.google; " +
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " +
    "img-src 'self' blob: data: https://res.cloudinary.com https://*.cloudinary.com https://images.unsplash.com https://img.youtube.com https://i.ytimg.com https://www.googletagmanager.com https://www.google-analytics.com https://pagead2.googlesyndication.com https://*.googlesyndication.com https://googleads.g.doubleclick.net https://tpc.googlesyndication.com https://*.google.com https://*.google; " +
    "font-src 'self' data: https://fonts.gstatic.com; " +
    "connect-src 'self' https://res.cloudinary.com https://api.cloudinary.com https://*.cloudinary.com https://www.google-analytics.com https://analytics.google.com https://stats.g.doubleclick.net https://www.googletagmanager.com https://region1.google-analytics.com https://*.google-analytics.com https://*.analytics.google.com https://*.googletagmanager.com https://pagead2.googlesyndication.com https://*.googlesyndication.com https://*.google.com https://*.google https://*.doubleclick.net; " +
    "frame-src 'self' https://www.youtube.com https://youtube.com https://www.youtube-nocookie.com https://upload-widget.cloudinary.com https://*.cloudinary.com https://googleads.g.doubleclick.net https://tpc.googlesyndication.com https://*.googlesyndication.com https://*.google.com https://*.google; " +
    "media-src 'self' https://res.cloudinary.com; " +
    "object-src 'none'; " +
    "base-uri 'self'; " +
    "form-action 'self'; " +
    "frame-ancestors 'none';"
  )
  
  // ============ RATE LIMITING ============
  // Excluir assets est√°ticos del rate limiting
  if (path.match(/\.(jpg|jpeg|png|gif|webp|svg|ico|css|js|woff|woff2|ttf)$/)) {
    return response
  }
  
  const clientKey = getRateLimitKey(request)
  
  // Determinar l√≠mite seg√∫n el tipo de ruta
  let rateLimit = RATE_LIMITS.static
  if (path.startsWith('/api/')) {
    // L√≠mite especial para b√∫squedas
    if (path.includes('/search') || path.includes('/autocomplete')) {
      rateLimit = RATE_LIMITS.search
    } else {
      rateLimit = RATE_LIMITS.api
    }
  } else if (path.startsWith('/api/auth/') || path === '/admin/login') {
    rateLimit = RATE_LIMITS.auth
  }
  
  // Verificar rate limit
  if (!checkRateLimit(clientKey, rateLimit)) {
    console.log(`Rate limit exceeded for IP: ${clientKey} on path: ${path}`)
    
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'Retry-After': '60',
        'X-RateLimit-Limit': rateLimit.requests.toString(),
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': new Date(Date.now() + rateLimit.window).toISOString(),
      },
    })
  }
  
  // ============ CORS PARA API ============
  if (path.startsWith('/api/')) {
    const allowedOrigins = process.env.NODE_ENV === 'production' 
      ? ['https://cinenacional.com', 'https://www.cinenacional.com', 'https://5.161.58.106:3000']
      : ['http://localhost:3000', 'http://5.161.58.106:3000']
    
    const origin = request.headers.get('origin')
    if (origin && allowedOrigins.includes(origin)) {
      response.headers.set('Access-Control-Allow-Origin', origin)
    }
    
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    response.headers.set('Access-Control-Max-Age', '86400')
    
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, { status: 200, headers: response.headers })
    }
  }
  
  // ============ PROTECCI√ìN CONTRA BOTS ============
  const userAgent = request.headers.get('user-agent') || ''
  const blockedBots = ['bot', 'crawler', 'spider', 'scraper']
  const allowedBots = ['googlebot', 'bingbot', 'facebookexternalhit', 'twitterbot']
  
  const isBlockedBot = blockedBots.some(bot => 
    userAgent.toLowerCase().includes(bot) && 
    !allowedBots.some(allowed => userAgent.toLowerCase().includes(allowed))
  )
  
  if (isBlockedBot && path.startsWith('/api/')) {
    return new NextResponse('Forbidden', { status: 403 })
  }
  
  return response
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}

// ==================================================
// src/services/api-client.ts
// ==================================================
// src/services/api-client.ts

interface RequestOptions extends RequestInit {
  params?: Record<string, string>
}

class ApiClient {
  private baseUrl: string

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl
  }

  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      let errorMessage = `Error: ${response.status} ${response.statusText}`
      
      try {
        const errorData = await response.json()
        errorMessage = errorData.error || errorData.message || errorMessage
      } catch {
        // Si no se puede parsear el error, usar el mensaje por defecto
      }
      
      throw new Error(errorMessage)
    }

    // Si la respuesta es 204 No Content, retornar null
    if (response.status === 204) {
      return null as T
    }

    return response.json()
  }

  private buildUrl(endpoint: string, params?: Record<string, string>): string {
    const url = new URL(`${this.baseUrl}${endpoint}`, window.location.origin)
    
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== '' && value !== undefined && value !== null) {
          url.searchParams.append(key, value)
        }
      })
    }
    
    return url.toString()
  }

  async get<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    const { params, ...fetchOptions } = options || {}
    const url = this.buildUrl(endpoint, params)
    
    const response = await fetch(url, {
      ...fetchOptions,
      method: 'GET'
    })
    
    return this.handleResponse<T>(response)
  }

  async post<T>(endpoint: string, data?: any, options?: RequestOptions): Promise<T> {
    const { params, ...fetchOptions } = options || {}
    const url = this.buildUrl(endpoint, params)
    
    const response = await fetch(url, {
      ...fetchOptions,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...fetchOptions.headers
      },
      body: data ? JSON.stringify(data) : undefined
    })
    
    return this.handleResponse<T>(response)
  }

  async put<T>(endpoint: string, data?: any, options?: RequestOptions): Promise<T> {
    const { params, ...fetchOptions } = options || {}
    const url = this.buildUrl(endpoint, params)
    
    const response = await fetch(url, {
      ...fetchOptions,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...fetchOptions.headers
      },
      body: data ? JSON.stringify(data) : undefined
    })
    
    return this.handleResponse<T>(response)
  }

  async patch<T>(endpoint: string, data?: any, options?: RequestOptions): Promise<T> {
    const { params, ...fetchOptions } = options || {}
    const url = this.buildUrl(endpoint, params)
    
    const response = await fetch(url, {
      ...fetchOptions,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        ...fetchOptions.headers
      },
      body: data ? JSON.stringify(data) : undefined
    })
    
    return this.handleResponse<T>(response)
  }

  async delete<T = void>(endpoint: string, options?: RequestOptions): Promise<T> {
    const { params, ...fetchOptions } = options || {}
    const url = this.buildUrl(endpoint, params)
    
    const response = await fetch(url, {
      ...fetchOptions,
      method: 'DELETE'
    })
    
    return this.handleResponse<T>(response)
  }
}

// Instancia por defecto para usar en toda la aplicaci√≥n
export const apiClient = new ApiClient('/api')

// Exportar la clase por si se necesita crear instancias personalizadas
export default ApiClient

// ==================================================
// src/services/images.service.ts
// ==================================================
// src/services/images.service.ts
import { apiClient } from './api-client'
import { 
  ImageWithRelations, 
  ImageFormData, 
  PaginatedImagesResponse,
  ImageType
} from '@/lib/images/imageTypes'

export const imagesService = {
  // Obtener im√°genes de una pel√≠cula
  async getByMovieId(movieId: number): Promise<ImageWithRelations[]> {
    const response = await apiClient.get<PaginatedImagesResponse>(
      `/images?movieId=${movieId}&limit=100`
    )
    return response.data
  },

  // Obtener imagen por ID
  async getById(id: number): Promise<ImageWithRelations> {
    return apiClient.get<ImageWithRelations>(`/images/${id}`)
  },

  // Crear una imagen
  async create(data: ImageFormData): Promise<ImageWithRelations> {
    return apiClient.post<ImageWithRelations>('/images', data)
  },

  // Crear m√∫ltiples im√°genes (para subida masiva)
  async createBulk(
    movieId: number, 
    cloudinaryPublicIds: string[],
    type: ImageType = 'STILL'
  ): Promise<ImageWithRelations[]> {
    const promises = cloudinaryPublicIds.map(publicId => 
      this.create({
        cloudinaryPublicId: publicId,
        movieId,
        type
      })
    )
    return Promise.all(promises)
  },

  // Actualizar imagen
  async update(id: number, data: ImageFormData): Promise<ImageWithRelations> {
    return apiClient.put<ImageWithRelations>(`/images/${id}`, data)
  },

  // Eliminar imagen
  async delete(id: number): Promise<void> {
    return apiClient.delete(`/images/${id}`)
  },

  // Eliminar m√∫ltiples im√°genes
  async deleteBulk(ids: number[]): Promise<void> {
    await Promise.all(ids.map(id => this.delete(id)))
  }
}

// ==================================================
// src/services/index.ts
// ==================================================
// src/services/index.ts

export { apiClient } from './api-client'
export { moviesService } from './movies.service'
export { metadataService } from './metadata.service'
export { peopleService } from './people.service'

// Re-exportar tipos √∫tiles
export type { default as ApiClient } from './api-client'

// ==================================================
// src/services/metadata.service.ts
// ==================================================
// src/services/metadata.service.ts

interface Rating {
  id: number
  name: string
  abbreviation?: string
  description?: string
}

interface ColorType {
  id: number
  name: string
}

interface Genre {
  id: number
  name: string
  slug: string
}

interface Country {
  id: number
  name: string
  code: string
}

interface Company {
  id: number
  name: string
  type: 'PRODUCTION' | 'DISTRIBUTION'
}

interface Theme {
  id: number
  name: string
  slug: string
}

export const metadataService = {
  /**
   * Obtiene las calificaciones disponibles
   */
  async getRatings(): Promise<Rating[]> {
    try {
      const response = await fetch('/api/calificaciones')
      if (!response.ok) throw new Error('Error loading ratings')
      return response.json()
    } catch (error) {
      console.error('Error loading ratings:', error)
      return []
    }
  },

  /**
   * Obtiene los tipos de color disponibles
   */
  async getColorTypes(): Promise<ColorType[]> {
    try {
      const response = await fetch('/api/color-types')
      if (!response.ok) throw new Error('Error loading color types')
      return response.json()
    } catch (error) {
      console.error('Error loading color types:', error)
      return []
    }
  },

  /**
   * Obtiene todos los g√©neros
   */
  async getGenres(): Promise<Genre[]> {
    try {
      const response = await fetch('/api/genres')
      if (!response.ok) throw new Error('Error loading genres')
      return response.json()
    } catch (error) {
      console.error('Error loading genres:', error)
      return []
    }
  },

  /**
   * Obtiene todos los pa√≠ses
   */
  async getCountries(): Promise<Country[]> {
    try {
      const response = await fetch('/api/countries')
      if (!response.ok) throw new Error('Error loading countries')
      return response.json()
    } catch (error) {
      console.error('Error loading countries:', error)
      return []
    }
  },

   /**
   * Obtiene las productoras
   */
  async getProductionCompanies(): Promise<Company[]> {
    try {
      const response = await fetch('/api/companies/production')
      if (!response.ok) throw new Error('Error loading production companies')
      return response.json()
    } catch (error) {
      console.error('Error loading production companies:', error)
      return []
    }
  },

  /**
   * Obtiene las distribuidoras
   */
  async getDistributionCompanies(): Promise<Company[]> {
    try {
      const response = await fetch('/api/companies/distribution')
      if (!response.ok) throw new Error('Error loading distribution companies')
      return response.json()
    } catch (error) {
      console.error('Error loading distribution companies:', error)
      return []
    }
  },

  /**
   * Obtiene los temas/keywords
   */
  async getThemes(): Promise<Theme[]> {
    try {
      const response = await fetch('/api/themes')
      if (!response.ok) throw new Error('Error loading themes')
      return response.json()
    } catch (error) {
      console.error('Error loading themes:', error)
      return []
    }
  },

  /**
   * Carga todos los metadatos necesarios para el formulario
   */
  async loadAllFormMetadata() {
    try {
      const [
        genres,
        countries,
        prodCompanies,
        distCompanies,
        themes,
        ratings,
        colorTypes
      ] = await Promise.all([
        this.getGenres(),
        this.getCountries(),
        this.getProductionCompanies(),
        this.getDistributionCompanies(),
        this.getThemes(),
        this.getRatings(),
        this.getColorTypes()
      ])

      return {
        genres: Array.isArray(genres) ? genres : [],
        countries: Array.isArray(countries) ? countries : [],
        productionCompanies: Array.isArray(prodCompanies) ? prodCompanies : [],
        distributionCompanies: Array.isArray(distCompanies) ? distCompanies : [],
        themes: Array.isArray(themes) ? themes : [],
        ratings: Array.isArray(ratings) ? ratings : [],
        colorTypes: Array.isArray(colorTypes) ? colorTypes : []
      }
    } catch (error) {
      console.error('Error loading form metadata:', error)
      // Retornar objetos vac√≠os en caso de error
      return {
        genres: [],
        countries: [],
        productionCompanies: [],
        distributionCompanies: [],
        themes: [],
        ratings: [],
        colorTypes: []
      }
    }
  }
}

// ==================================================
// src/services/movies.service.ts
// ==================================================
// src/services/movies.service.ts
import { MovieFilters } from '@/components/admin/movies/MoviesFilters'
import { MovieCompleteData } from '@/lib/movies/movieTypes'
import { dateToPartialFields, partialFieldsToDate, PartialDate } from '@/lib/shared/dateUtils'

interface MoviesResponse {
  movies: any[]
  pagination: {
    totalPages: number
    currentPage: number
    totalItems: number
  }
}

/**
 * Formatea los datos del formulario de pel√≠cula para enviar a la API
 * Convierte las fechas completas o parciales al formato esperado por el backend
 */
function formatMovieDataForAPI(data: MovieCompleteData): any {
  const apiData: any = {
    title: data.title,
    year: data.year,
    duration: data.duration,
    durationSeconds: data.durationSeconds,
    tipoDuracion: data.tipoDuracion,
    synopsis: data.synopsis,
    synopsisLocked: data.synopsisLocked ?? false,
    notes: data.notes,
    tagline: data.tagline,
    posterUrl: data.posterUrl,
    trailerUrl: data.trailerUrl,
    imdbId: data.imdbId,
    stage: data.stage,
    colorTypeId: data.colorTypeId,
    soundType: data.soundType,
    ratingId: data.ratingId,
    countries: data.countries,
    is_coproduction: data.is_coproduction,
    production_type: data.production_type,
    dataCompleteness: data.dataCompleteness,
    metaDescription: data.metaDescription,
    metaKeywords: data.metaKeywords,
    genres: data.genres,
    cast: data.cast,
    crew: data.crew,
    productionCompanies: data.productionCompanies,
    distributionCompanies: data.distributionCompanies,
    themes: data.themes,
    movieCountries: data.movieCountries,
    links: data.links,
    screeningVenues: data.screeningVenues
  }

  // Procesar fecha de estreno
  if (data.isPartialReleaseDate && data.partialReleaseDate) {
    // Fecha parcial de estreno
    apiData.releaseYear = data.partialReleaseDate.year
    apiData.releaseMonth = data.partialReleaseDate.month
    apiData.releaseDay = data.partialReleaseDate.day
  } else if (data.releaseDate) {
    // Fecha completa de estreno - convertir a campos parciales
    const partial = dateToPartialFields(data.releaseDate)
    apiData.releaseYear = partial.year
    apiData.releaseMonth = partial.month
    apiData.releaseDay = partial.day
  } else {
    // Sin fecha de estreno
    apiData.releaseYear = null
    apiData.releaseMonth = null
    apiData.releaseDay = null
  }

  // Procesar fecha de inicio de rodaje
  if (data.isPartialFilmingStartDate && data.partialFilmingStartDate) {
    // Fecha parcial de inicio de rodaje
    apiData.filmingStartYear = data.partialFilmingStartDate.year
    apiData.filmingStartMonth = data.partialFilmingStartDate.month
    apiData.filmingStartDay = data.partialFilmingStartDate.day
  } else if (data.filmingStartDate) {
    // Fecha completa de inicio de rodaje - convertir a campos parciales
    const partial = dateToPartialFields(data.filmingStartDate)
    apiData.filmingStartYear = partial.year
    apiData.filmingStartMonth = partial.month
    apiData.filmingStartDay = partial.day
  } else {
    // Sin fecha de inicio de rodaje
    apiData.filmingStartYear = null
    apiData.filmingStartMonth = null
    apiData.filmingStartDay = null
  }

  // Procesar fecha de fin de rodaje
  if (data.isPartialFilmingEndDate && data.partialFilmingEndDate) {
    // Fecha parcial de fin de rodaje
    apiData.filmingEndYear = data.partialFilmingEndDate.year
    apiData.filmingEndMonth = data.partialFilmingEndDate.month
    apiData.filmingEndDay = data.partialFilmingEndDate.day
  } else if (data.filmingEndDate) {
    // Fecha completa de fin de rodaje - convertir a campos parciales
    const partial = dateToPartialFields(data.filmingEndDate)
    apiData.filmingEndYear = partial.year
    apiData.filmingEndMonth = partial.month
    apiData.filmingEndDay = partial.day
  } else {
    // Sin fecha de fin de rodaje
    apiData.filmingEndYear = null
    apiData.filmingEndMonth = null
    apiData.filmingEndDay = null
  }

  return apiData
}

/**
 * Convierte los datos de la API al formato del formulario
 */
function formatMovieFromAPI(movie: any): MovieCompleteData {
  const formData: MovieCompleteData = {
    title: movie.title || '',
    year: movie.year || null,
    releaseDate: '',
    duration: movie.duration || null,
    durationSeconds: movie.durationSeconds || null,
    tipoDuracion: movie.tipoDuracion || '',
    synopsis: movie.synopsis || '',
    synopsisLocked: movie.synopsisLocked ?? false,
    notes: movie.notes || '',
    tagline: movie.tagline || '',
    posterUrl: movie.posterUrl || '',
    trailerUrl: movie.trailerUrl || '',
    imdbId: movie.imdbId || '',
    stage: movie.stage || 'COMPLETA',
    filmingStartDate: '',
    filmingEndDate: '',
    colorTypeId: movie.colorTypeId || null,
    soundType: movie.soundType || '',
    ratingId: movie.ratingId || null,
    countries: movie.countries || ['Argentina'],
    is_coproduction: movie.is_coproduction || false,
    production_type: movie.production_type || 'national',
    dataCompleteness: movie.dataCompleteness || 'BASIC_PRESS_KIT',
    metaDescription: movie.metaDescription || '',
    metaKeywords: movie.metaKeywords || [],
    genres: movie.genres || [],
    cast: movie.cast || [],
    crew: movie.crew || [],
    productionCompanies: movie.productionCompanies || [],
    distributionCompanies: movie.distributionCompanies || [],
    themes: movie.themes || [],
    movieCountries: movie.movieCountries || [],
    links: movie.links || [],
    screeningVenues: movie.screeningVenues || []
  }

  // Procesar fecha de estreno
  if (movie.releaseYear) {
    const releasePartial: PartialDate = {
      year: movie.releaseYear,
      month: movie.releaseMonth,
      day: movie.releaseDay
    }

    // Si la fecha est√° completa, convertirla a formato ISO
    if (movie.releaseYear && movie.releaseMonth && movie.releaseDay) {
      formData.releaseDate = partialFieldsToDate(releasePartial) || ''
      formData.isPartialReleaseDate = false
    } else {
      // Fecha parcial
      formData.partialReleaseDate = releasePartial
      formData.isPartialReleaseDate = true
      formData.releaseDate = ''
    }
  }

  // Procesar fecha de inicio de rodaje
  if (movie.filmingStartYear) {
    const filmingStartPartial: PartialDate = {
      year: movie.filmingStartYear,
      month: movie.filmingStartMonth,
      day: movie.filmingStartDay
    }

    // Si la fecha est√° completa, convertirla a formato ISO
    if (movie.filmingStartYear && movie.filmingStartMonth && movie.filmingStartDay) {
      formData.filmingStartDate = partialFieldsToDate(filmingStartPartial) || ''
      formData.isPartialFilmingStartDate = false
    } else {
      // Fecha parcial
      formData.partialFilmingStartDate = filmingStartPartial
      formData.isPartialFilmingStartDate = true
      formData.filmingStartDate = ''
    }
  }

  // Procesar fecha de fin de rodaje
  if (movie.filmingEndYear) {
    const filmingEndPartial: PartialDate = {
      year: movie.filmingEndYear,
      month: movie.filmingEndMonth,
      day: movie.filmingEndDay
    }

    // Si la fecha est√° completa, convertirla a formato ISO
    if (movie.filmingEndYear && movie.filmingEndMonth && movie.filmingEndDay) {
      formData.filmingEndDate = partialFieldsToDate(filmingEndPartial) || ''
      formData.isPartialFilmingEndDate = false
    } else {
      // Fecha parcial
      formData.partialFilmingEndDate = filmingEndPartial
      formData.isPartialFilmingEndDate = true
      formData.filmingEndDate = ''
    }
  }

  return formData
}

export const moviesService = {
  /**
   * Obtiene la lista de pel√≠culas con filtros y paginaci√≥n
   */
  async getAll(filters: MovieFilters): Promise<MoviesResponse> {
    const params = new URLSearchParams({
      page: filters.currentPage.toString(),
      limit: '20',
      search: filters.searchTerm,
      year: filters.selectedYear,
      sortBy: 'createdAt',
      sortOrder: 'desc'
    })

    const response = await fetch(`/api/movies?${params}`)

    if (!response.ok) {
      throw new Error('Error al cargar las pel√≠culas')
    }

    const data = await response.json()

    // Las pel√≠culas ya vienen con los campos de fecha parcial desde la API
    return {
      movies: data.movies || [],
      pagination: data.pagination || { totalPages: 1, currentPage: 1, totalItems: 0 }
    }
  },

  /**
   * Obtiene una pel√≠cula por ID con todas sus relaciones
   */
  async getById(id: number): Promise<any> {
    const response = await fetch(`/api/movies/${id}`)

    if (!response.ok) {
      throw new Error('Error al cargar los datos de la pel√≠cula')
    }

    const movie = await response.json()

    // Devolver la pel√≠cula tal cual, con los campos de fecha parcial
    return movie
  },

  /**
   * Obtiene una pel√≠cula por ID en formato de formulario para edici√≥n
   */
  async getByIdForEdit(id: number): Promise<MovieCompleteData> {
    const response = await fetch(`/api/movies/${id}`)

    if (!response.ok) {
      throw new Error('Error al cargar los datos de la pel√≠cula')
    }

    const movie = await response.json()
    return formatMovieFromAPI(movie)
  },

  /**
   * Crea una nueva pel√≠cula
   */
  async create(data: MovieCompleteData): Promise<any> {
    // Mismo tratamiento que update
    let formattedData = data;

    if (!('releaseYear' in data) && !('filmingStartYear' in data)) {
      formattedData = formatMovieDataForAPI(data);
    }

    const response = await fetch('/api/movies', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(formattedData)
    })

    if (!response.ok) {
      let errorMessage = 'Error al crear la pel√≠cula'
      try {
        const error = await response.json()
        errorMessage = error.error || error.message || errorMessage
      } catch (e) {
        console.error('Error parsing response:', e)
      }
      throw new Error(errorMessage)
    }

    return response.json()
  },

  /**
   * Actualiza una pel√≠cula existente
   */
  async update(id: number, data: MovieCompleteData): Promise<any> {
    console.log('üé¨ movies.service.update - Datos recibidos:', {
      tieneGenres: 'genres' in data,
      genres: data.genres,
      tieneLinks: 'links' in data,
      links: data.links,
      tieneMetaDescription: 'metaDescription' in data,
      metaDescription: data.metaDescription,
      tieneSynopsisLocked: 'synopsisLocked' in data,
      synopsisLocked: data.synopsisLocked
    })

    // NO volver a formatear si los datos ya vienen con campos de fecha separados
    let formattedData = data;

    // Solo formatear si vienen campos de fecha completos (releaseDate, etc.)
    // Si ya vienen releaseYear, releaseMonth, etc., no hacer nada
    if (!('releaseYear' in data) && !('filmingStartYear' in data)) {
      // Solo formatear si es necesario
      formattedData = formatMovieDataForAPI(data);
    }

    const response = await fetch(`/api/movies/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(formattedData)
    })

    if (!response.ok) {
      let errorMessage = 'Error al actualizar la pel√≠cula'
      try {
        const error = await response.json()
        errorMessage = error.error || error.message || errorMessage
      } catch (e) {
        console.error('Error completo:', e)
        console.error('Error parsing response:', e)
      }
      throw new Error(errorMessage)
    }

    return response.json()
  },

  /**
   * Elimina una pel√≠cula
   */
  async delete(id: number): Promise<void> {
    const response = await fetch(`/api/movies/${id}`, {
      method: 'DELETE'
    })

    if (!response.ok) {
      throw new Error('Error al eliminar la pel√≠cula')
    }
  },

  /**
   * Busca pel√≠culas por t√©rmino de b√∫squeda (autocomplete)
   */
  async search(term: string, limit: number = 10): Promise<any[]> {
    const params = new URLSearchParams({
      search: term,
      limit: limit.toString()
    })

    const response = await fetch(`/api/movies/search?${params}`)

    if (!response.ok) {
      throw new Error('Error al buscar pel√≠culas')
    }

    return response.json()
  },

  /**
   * Verifica si un slug est√° disponible
   */
  async checkSlugAvailability(slug: string, excludeId?: number): Promise<boolean> {
    const params = new URLSearchParams({ slug })
    if (excludeId) params.append('excludeId', String(excludeId))

    const response = await fetch(`/api/movies/check-slug?${params}`)

    if (!response.ok) {
      throw new Error('Error al verificar disponibilidad del slug')
    }

    const { available } = await response.json()
    return available
  },

  /**
   * Obtiene estad√≠sticas de pel√≠culas
   */
  async getStats(): Promise<{
    total: number
    byYear: Record<string, number>
    byStage: Record<string, number>
    byDataCompleteness: Record<string, number>
  }> {
    const response = await fetch('/api/movies/stats')

    if (!response.ok) {
      throw new Error('Error al obtener estad√≠sticas')
    }

    return response.json()
  },

  /**
   * Exporta pel√≠culas a CSV
   */
  async exportToCSV(filters: MovieFilters): Promise<Blob> {
    const params = new URLSearchParams({
      search: filters.searchTerm,
      year: filters.selectedYear
    })

    const response = await fetch(`/api/movies/export?${params}`)

    if (!response.ok) {
      throw new Error('Error al exportar pel√≠culas')
    }

    return response.blob()
  }
}

// ==================================================
// src/services/people.service.ts
// ==================================================
// src/services/people.service.ts

import { apiClient } from './api-client';
import {
  Person,
  PersonWithRelations,
  PersonFormData,
  PersonFilters,
  PaginatedPeopleResponse
} from '@/lib/people/peopleTypes';
import { dateToPartialFields, partialFieldsToDate } from '@/lib/shared/dateUtils';

interface PersonSearchResult {
  id: number;
  name: string;
  slug?: string;
}

/**
* Formatea los datos del formulario para enviar a la API
* Convierte las fechas completas o parciales al formato esperado por el backend
*/
function formatPersonDataForAPI(data: PersonFormData): any {
  const apiData: any = {
    firstName: data.firstName || null,
    lastName: data.lastName || null,
    realName: data.realName || null,
    gender: data.gender || null,
    hideAge: data.hideAge,
    isActive: data.isActive,
    birthLocationId: data.birthLocationId,
    deathLocationId: data.deathLocationId,
    biography: data.biography || null,
    photoUrl: data.photoUrl || null,
  };

  // Procesar fecha de nacimiento
  if (data.isPartialBirthDate && data.partialBirthDate) {
    // Fecha parcial de nacimiento
    apiData.birthYear = data.partialBirthDate.year;
    apiData.birthMonth = data.partialBirthDate.month;
    apiData.birthDay = data.partialBirthDate.day;
  } else if (data.birthDate) {
    // Fecha completa de nacimiento - convertir a campos parciales
    const partial = dateToPartialFields(data.birthDate);
    apiData.birthYear = partial.year;
    apiData.birthMonth = partial.month;
    apiData.birthDay = partial.day;
  } else {
    // Sin fecha de nacimiento
    apiData.birthYear = null;
    apiData.birthMonth = null;
    apiData.birthDay = null;
  }

  // Procesar fecha de fallecimiento
  if (data.isPartialDeathDate && data.partialDeathDate) {
    // Fecha parcial de fallecimiento
    apiData.deathYear = data.partialDeathDate.year;
    apiData.deathMonth = data.partialDeathDate.month;
    apiData.deathDay = data.partialDeathDate.day;
  } else if (data.deathDate) {
    // Fecha completa de fallecimiento - convertir a campos parciales
    const partial = dateToPartialFields(data.deathDate);
    apiData.deathYear = partial.year;
    apiData.deathMonth = partial.month;
    apiData.deathDay = partial.day;
  } else {
    // Sin fecha de fallecimiento
    apiData.deathYear = null;
    apiData.deathMonth = null;
    apiData.deathDay = null;
  }

  // Procesar nacionalidades
  if (data.nationalities && data.nationalities.length > 0) {
    apiData.nationalities = data.nationalities;
  }

  // Procesar links si existen
  if (data.links && data.links.length > 0) {
    apiData.links = data.links;
  }

  // Procesar nombres alternativos si existen
  if (data.alternativeNames && data.alternativeNames.length > 0) {
    apiData.alternativeNames = data.alternativeNames;
  }

  return apiData;
}

/**
* Convierte los datos de la API al formato del formulario
*/
function formatPersonFromAPI(person: any): PersonFormData {
  const formData: PersonFormData = {
    firstName: person.firstName || '',
    lastName: person.lastName || '',
    realName: person.realName || '',
    birthDate: '',
    deathDate: '',
    gender: person.gender || '',
    hideAge: person.hideAge || false,
    isActive: person.isActive !== false, // Default true
    birthLocationId: person.birthLocationId || null,
    deathLocationId: person.deathLocationId || null,
    biography: person.biography || '',
    photoUrl: person.photoUrl || '',
    links: person.links || [],
    alternativeNames: person.alternativeNames || [],
    nationalities: []
  };

  // Procesar fecha de nacimiento
  if (person.birthYear) {
    const birthPartial = {
      year: person.birthYear,
      month: person.birthMonth,
      day: person.birthDay
    };

    // Si la fecha est√° completa, convertirla a formato ISO
    if (person.birthYear && person.birthMonth && person.birthDay) {
      formData.birthDate = partialFieldsToDate(birthPartial) || '';
      formData.isPartialBirthDate = false;
    } else {
      // Fecha parcial
      formData.partialBirthDate = birthPartial;
      formData.isPartialBirthDate = true;
      formData.birthDate = '';
    }
  }

  // Procesar fecha de fallecimiento
  if (person.deathYear) {
    const deathPartial = {
      year: person.deathYear,
      month: person.deathMonth,
      day: person.deathDay
    };

    // Si la fecha est√° completa, convertirla a formato ISO
    if (person.deathYear && person.deathMonth && person.deathDay) {
      formData.deathDate = partialFieldsToDate(deathPartial) || '';
      formData.isPartialDeathDate = false;
    } else {
      // Fecha parcial
      formData.partialDeathDate = deathPartial;
      formData.isPartialDeathDate = true;
      formData.deathDate = '';
    }
  }

  // Procesar nacionalidades
  if (person.nationalities && Array.isArray(person.nationalities)) {
    formData.nationalities = person.nationalities.map((n: any) => {
      // Si es un n√∫mero directo
      if (typeof n === 'number') {
        return n;
      }

      // Si es un objeto
      if (typeof n === 'object' && n !== null) {
        // Primero intentar con locationId (campo directo)
        if (n.locationId) {
          return n.locationId;
        }

        // Si tiene un campo 'location' con id (estructura que viene de la API con include)
        if (n.location && n.location.id) {
          return n.location.id;
        }

        // Si tiene un campo 'country' con id (por si acaso)
        if (n.country && n.country.id) {
          return n.country.id;
        }

        // Si tiene un id directo
        if (n.id) {
          return n.id;
        }
      }

      return null;
    }).filter((id: any) => id !== null); // Filtrar nulls
  }

  return formData;
}

export const peopleService = {
  /**
   * Obtiene una lista paginada de personas con filtros
   */
  async getAll(filters?: PersonFilters, signal?: AbortSignal): Promise<PaginatedPeopleResponse> {
    const params: Record<string, string> = {};

    if (filters?.search) params.search = filters.search;
    if (filters?.gender) params.gender = filters.gender;
    if (filters?.hasLinks !== undefined) params.hasLinks = String(filters.hasLinks);
    if (filters?.isActive !== undefined) params.isActive = String(filters.isActive);
    if (filters?.page) params.page = String(filters.page);
    if (filters?.limit) params.limit = String(filters.limit);
    if (filters?.sortBy) params.sortBy = filters.sortBy;
    if (filters?.sortOrder) params.sortOrder = filters.sortOrder;

    // Construir URL con par√°metros
    const queryString = new URLSearchParams(params).toString();
    const url = `/api/people${queryString ? `?${queryString}` : ''}`;

    // Usar fetch directamente con signal
    const response = await fetch(url, {
      method: 'GET',
      signal
    });

    if (!response.ok) {
      // Si el request fue abortado, lanzar error espec√≠fico
      if (signal?.aborted) {
        const error = new Error('Request aborted');
        error.name = 'AbortError';
        throw error;
      }
      throw new Error('Error al obtener personas');
    }

    return response.json();
  },

  /**
   * Busca personas por nombre (para autocomplete)
   */
  async search(query: string, limit: number = 10): Promise<PersonSearchResult[]> {
    if (query.length < 2) return [];

    try {
      // Usar fetch directamente para b√∫squeda
      const params = new URLSearchParams({
        search: query,
        limit: String(limit)
      });

      const response = await fetch(`/api/people?${params}`);

      if (!response.ok) {
        throw new Error('Error searching people');
      }

      return response.json();
    } catch (error) {
      console.error('Error searching people:', error);
      return [];
    }
  },

  /**
   * Obtiene una persona por ID con todas sus relaciones
   */
  async getById(id: number): Promise<PersonWithRelations> {
    return apiClient.get<PersonWithRelations>(`/people/${id}`);
  },

  /**
   * Obtiene una persona por ID en formato de formulario
   */
  async getByIdForEdit(id: number): Promise<PersonFormData> {
    const person = await apiClient.get<any>(`/people/${id}`);
    return formatPersonFromAPI(person);
  },

  /**
   * Crea una nueva persona
   */
  async create(data: PersonFormData): Promise<PersonWithRelations> {
    const formattedData = formatPersonDataForAPI(data);
    return apiClient.post<PersonWithRelations>('/people', formattedData);
  },

  /**
   * Crea una persona r√°pida (solo con nombre)
   */
  async createQuick(name: string): Promise<Person> {
    // El backend se encarga de separar el nombre
    return apiClient.post<Person>('/people', {
      name: name.trim(),
      isActive: true
    });
  },

  /**
   * Actualiza una persona
   */
  async update(id: number, data: PersonFormData): Promise<PersonWithRelations> {
    const formattedData = formatPersonDataForAPI(data);
    return apiClient.put<PersonWithRelations>(`/people/${id}`, formattedData);
  },

  /**
   * Elimina una persona
   */
  async delete(id: number): Promise<void> {
    await apiClient.delete(`/people/${id}`);
  },

  /**
   * Verifica si un slug est√° disponible
   */
  async checkSlugAvailability(slug: string, excludeId?: number): Promise<boolean> {
    const params = new URLSearchParams({ slug });
    if (excludeId) params.append('excludeId', String(excludeId));

    const { available } = await apiClient.get<{ available: boolean }>(
      `/people/check-slug?${params}`
    );
    return available;
  },

  /**
   * Obtiene estad√≠sticas de personas
   */
  async getStats(): Promise<{
    total: number;
    active: number;
    withLinks: number;
    byGender: Record<string, number>;
  }> {
    return apiClient.get('/people/stats');
  },

  /**
   * Exporta personas a CSV
   */
  async exportToCSV(filters: PersonFilters = {}): Promise<Blob> {
    const params = new URLSearchParams();

    if (filters.search) params.append('search', filters.search);
    if (filters.gender) params.append('gender', filters.gender);
    if (filters.hasLinks !== undefined) {
      params.append('hasLinks', String(filters.hasLinks));
    }
    if (filters.isActive !== undefined) {
      params.append('isActive', String(filters.isActive));
    }

    const response = await fetch(`/api/people/export?${params}`);

    if (!response.ok) {
      throw new Error('Error al exportar personas');
    }

    return response.blob();
  }
};

// ==================================================
// src/services/roles.service.ts
// ==================================================
// src/services/roles.service.ts

import { apiClient } from './api-client';
import type { 
  Role,
  RoleFormData, 
  RoleFilters, 
  PaginatedRolesResponse,
  Department 
} from '@/lib/roles/rolesTypes';

export const rolesService = {
  /**
   * Obtiene todos los roles con filtros y paginaci√≥n
   */
  async getAll(filters: RoleFilters = {}): Promise<PaginatedRolesResponse> {
    const params: Record<string, string> = {};
    
    if (filters.search) params.search = filters.search;
    if (filters.department) params.department = filters.department;
    if (filters.isActive !== undefined && filters.isActive !== '') {
      params.isActive = filters.isActive.toString();
    }
    if (filters.isMainRole !== undefined && filters.isMainRole !== '') {
      params.isMainRole = filters.isMainRole.toString();
    }
    if (filters.page) params.page = filters.page.toString();
    if (filters.limit) params.limit = filters.limit.toString();
    
    // A√ëADIR ORDENAMIENTO POR DEFECTO POR USOS
    // Removido filters.sortBy y filters.sortOrder porque no existen en RoleFilters
    params.sortBy = 'usage'; // Por defecto ordenar por usos
    params.sortOrder = 'desc'; // Descendente por defecto (m√°s usados primero)

    return apiClient.get<PaginatedRolesResponse>('/roles', { params });
  },

  /**
   * Obtiene roles por departamento
   */
  async getByDepartment(department: Department): Promise<Role[]> {
    const params = {
      department: department,
      isActive: 'true',
      limit: '100',
      sortBy: 'usage', // A√ëADIR ordenamiento por usos
      sortOrder: 'desc'
    };

    const response = await apiClient.get<PaginatedRolesResponse>('/roles', { params });
    return response.data;
  },

  /**
   * Obtiene un rol por ID
   */
  async getById(id: number): Promise<Role> {
    return apiClient.get<Role>(`/roles/${id}`);
  },

  /**
   * B√∫squeda r√°pida para autocomplete
   */
  async search(query: string, department?: Department, limit: number = 10): Promise<Role[]> {
    if (query.length < 2) return [];
    
    const params: Record<string, string> = {
      search: query,
      limit: limit.toString(),
      isActive: 'true',
      sortBy: 'usage', // A√ëADIR ordenamiento por usos
      sortOrder: 'desc'
    };

    if (department) params.department = department;

    const response = await apiClient.get<PaginatedRolesResponse>('/roles', { params });
    return response.data;
  },

  /**
   * Obtiene roles principales por departamento (para crew de pel√≠culas)
   */
  async getMainRolesByDepartment(): Promise<Record<string, Role[]>> {
    const response = await apiClient.get<Record<string, Role[]>>('/roles/main-by-department');
    return response;
  },

  /**
   * Obtiene lista simple para dropdowns
   */
  async getSimpleList(department?: Department): Promise<Pick<Role, 'id' | 'name' | 'department'>[]> {
    const params: Record<string, string> = {
      isActive: 'true',
      limit: '200',
      sortBy: 'usage', // A√ëADIR ordenamiento por usos
      sortOrder: 'desc'
    };

    if (department) params.department = department;

    const response = await apiClient.get<PaginatedRolesResponse>('/roles', { params });
    return response.data.map(role => ({
      id: role.id,
      name: role.name,
      department: role.department
    }));
  },

  /**
   * Crea un nuevo rol
   */
  async create(data: RoleFormData): Promise<Role> {
    console.log('üé≠ Creating role:', data);
    
    const formattedData = {
      ...data,
      isActive: data.isActive ?? true,
      isMainRole: data.isMainRole ?? false
    };

    return apiClient.post<Role>('/roles', formattedData);
  },

  /**
   * Actualiza un rol existente
   */
  async update(id: number, data: RoleFormData): Promise<Role> {
    console.log('üìù Updating role:', id, data);
    
    return apiClient.put<Role>(`/roles/${id}`, data);
  },

  /**
   * Elimina un rol
   */
  async delete(id: number): Promise<void> {
    console.log('üóëÔ∏è Deleting role:', id);
    return apiClient.delete(`/roles/${id}`);
  },

  /**
   * Verifica disponibilidad de slug
   */
  async checkSlugAvailability(slug: string, excludeId?: number): Promise<boolean> {
    const params: Record<string, string> = { slug };
    if (excludeId) params.excludeId = excludeId.toString();

    try {
      await apiClient.get('/roles/check-slug', { params });
      return true;
    } catch {
      return false;
    }
  },

  /**
   * Obtiene estad√≠sticas de roles
   */
  async getStats(): Promise<{
    total: number;
    active: number;
    mainRoles: number;
    byDepartment: Record<number, number>;
  }> {
    return apiClient.get('/roles/stats');
  },

  /**
   * Exporta roles a CSV
   */
  async exportToCSV(filters: RoleFilters = {}): Promise<Blob> {
    const params: Record<string, string> = { export: 'csv' };
    
    if (filters.search) params.search = filters.search;
    if (filters.department) params.department = filters.department;
    if (filters.isActive !== undefined && filters.isActive !== '') {
      params.isActive = filters.isActive.toString();
    }
    if (filters.isMainRole !== undefined && filters.isMainRole !== '') {
      params.isMainRole = filters.isMainRole.toString();
    }

    const response = await fetch(`/api/roles?${new URLSearchParams(params)}`);
    return response.blob();
  },

  /**
   * Reordena roles dentro de un departamento
   */
  async reorder(roleIds: number[]): Promise<void> {
    return apiClient.post('/roles/reorder', { roleIds });
  },

  /**
   * Crea rol r√°pido con solo nombre y departamento
   */
  async createQuick(name: string, department: Department): Promise<Role> {
    return this.create({
      name,
      department,
      isActive: true
    });
  },

  /**
   * Crea roles por defecto
   */
  async seedDefault(): Promise<{ created: number; skipped: number }> {
    const response = await fetch('/api/roles/seed', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error('Error al crear roles por defecto');
    }
    
    return response.json();
  }
};

// ==================================================
// src/types/home.types.ts
// ==================================================
// src/types/home.types.ts
export interface MovieWithRelease {
  id: number;
  slug: string;
  title: string;
  releaseYear: number | null;
  releaseMonth: number | null;
  releaseDay: number | null;
  posterUrl: string | null;
  genres: Array<{
    genre?: { id: number; name: string };
    id?: number;
    name?: string;
  }>;
  crew?: Array<{
    person: {
      id: number;
      firstName?: string;
      lastName?: string;
    };
    roleId?: number;
    role?: string;
    department?: string;
  }>;
}

export interface HeroMovie {
  id: number;
  titulo: string;
  a√±o: string;
  genero: string;
  director: string;
  imagen: string;
}

export interface Obituario {
  id: number;
  slug: string;
  firstName?: string | null;
  lastName?: string | null;
  birthYear?: number | null;
  birthMonth?: number | null;
  birthDay?: number | null;
  deathYear?: number | null;
  deathMonth?: number | null;
  deathDay?: number | null;
  photoUrl?: string | null;
  _count?: {
    links: number;
    castRoles: number;
    crewRoles: number;
  };
}

// Interfaz para un director individual
export interface DirectorInfo {
  name: string;
  slug: string;
}

export interface Efemeride {
  id: string; // √önico para cada efem√©ride
  tipo: 'pelicula' | 'persona';
  hace: string; // "Hace 23 a√±os"
  evento: string; // "se estrenaba Nueve Reinas, de Fabi√°n Bielinsky"
  fecha: Date; // Para ordenamiento
  slug?: string; // Para enlaces
  posterUrl?: string; // Para pel√≠culas
  photoUrl?: string; // Para personas
  titulo?: string; // T√≠tulo de pel√≠cula o nombre de persona
  director?: string; // Nombre del director (o directores concatenados) - mantiene compatibilidad
  directorSlug?: string; // Slug del primer director - mantiene compatibilidad
  directors?: DirectorInfo[]; // Array de todos los directores con nombre y slug
  tipoEvento?: 'estreno' | 'inicio_rodaje' | 'fin_rodaje' | 'nacimiento' | 'muerte';
}

export interface SimpleMovie {
  id: number;
  titulo: string;
}

export interface SimplePerson {
  id: number;
  nombre: string;
  rol: string;
}

export interface SimpleMovie {
  id: number;
  slug: string;
  title: string;
  posterUrl?: string | null;
}

export interface SimplePerson {
  id: number;
  slug: string;
  firstName?: string;
  lastName?: string;
  photoUrl?: string | null;
  gender?: 'MALE' | 'FEMALE' | 'OTHER' | null;
  role?: string;
}

export interface HomeDataResponse {
  ultimosEstrenos: MovieWithRelease[];
  proximosEstrenos: MovieWithRelease[];
  ultimasPeliculas: SimpleMovie[];
  ultimasPersonas: SimplePerson[];
}

// ==================================================
// src/types/next-auth.d.ts
// ==================================================
import { DefaultSession } from "next-auth"

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      role: string
    } & DefaultSession["user"]
  }

  interface User {
    role: string
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string
    role: string
  }
}

// ==================================================
// src/utils/movieHelpers.ts
// ==================================================
// src/utils/movieHelpers.ts
import { MovieWithRelease } from '@/types/home.types';

export const obtenerDirector = (movie: MovieWithRelease): string => {
  if (movie.crew && movie.crew.length > 0) {
    const director = movie.crew.find((c) => c.roleId === 2);
    if (director?.person) {
      const firstName = director.person.firstName || '';
      const lastName = director.person.lastName || '';
      const fullName = `${firstName} ${lastName}`.trim();
      if (fullName) return fullName;
    }
  }
  return 'Director no especificado';
};

export const obtenerGeneros = (movie: MovieWithRelease): string => {
  if (movie.genres && movie.genres.length > 0) {
    const genreNames = movie.genres
      .map((g) => g.genre?.name || g.name || null)
      .filter(Boolean);

    if (genreNames.length > 0) {
      return genreNames.slice(0, 2).join(', ');
    }
  }
  return '';
};