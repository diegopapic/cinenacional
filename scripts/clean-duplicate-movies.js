/**
 * Script interactivo para limpiar pel√≠culas duplicadas - VERSION 2
 * Completamente reescrito con manejo robusto de errores
 */

const { PrismaClient } = require('@prisma/client');
const readline = require('readline');

const prisma = new PrismaClient();

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function question(query) {
  return new Promise(resolve => rl.question(query, resolve));
}

function getPersonName(person) {
  if (!person) return 'Desconocido';
  const parts = [];
  if (person.firstName) parts.push(person.firstName);
  if (person.lastName) parts.push(person.lastName);
  return parts.join(' ') || 'Desconocido';
}

function getDirectorIds(crew) {
  if (!Array.isArray(crew)) return [];
  return crew
    .filter(member => member.roleId === 2)
    .map(member => member.person?.id)
    .filter(id => id !== undefined && id !== null);
}

function shareDirectors(movie1Directors, movie2Directors) {
  if (!Array.isArray(movie1Directors) || !Array.isArray(movie2Directors)) return false;
  if (movie1Directors.length === 0 || movie2Directors.length === 0) return false;
  return movie1Directors.some(id => movie2Directors.includes(id));
}

function normalizeTitle(title) {
  return title.trim().toLowerCase().replace(/\s+/g, ' ');
}

function identifyMixedAndOriginals(movies) {
  const moviesWithDirectorCount = movies.map(movie => ({
    movie,
    directorCount: getDirectorIds(movie.crew).length
  })).sort((a, b) => b.directorCount - a.directorCount);
  
  const mixed = moviesWithDirectorCount[0].movie;
  const originals = moviesWithDirectorCount.slice(1).map(item => item.movie);
  
  return { mixed, originals };
}

function findDuplicateCrewMembers(mixedCrew, originalsCrews) {
  if (!Array.isArray(mixedCrew)) return [];
  if (!Array.isArray(originalsCrews)) return [];
  
  const duplicates = [];
  
  mixedCrew.forEach(mixedMember => {
    const personId = mixedMember.person?.id;
    if (!personId) return;
    
    const existsInAnyOriginal = originalsCrews.some(originalCrew =>
      Array.isArray(originalCrew) && originalCrew.some(
        origMember => origMember.person?.id === personId && origMember.roleId === mixedMember.roleId
      )
    );
    
    if (existsInAnyOriginal) {
      duplicates.push(mixedMember);
    }
  });
  
  return duplicates;
}

function findDuplicateCastMembers(mixedCast, originalsCasts) {
  if (!Array.isArray(mixedCast)) return [];
  if (!Array.isArray(originalsCasts)) return [];
  
  const duplicates = [];
  
  mixedCast.forEach(mixedMember => {
    const personId = mixedMember.person?.id;
    if (!personId) return;
    
    const existsInAnyOriginal = originalsCasts.some(originalCast =>
      Array.isArray(originalCast) && originalCast.some(
        origMember => origMember.person?.id === personId && 
                     origMember.characterName === mixedMember.characterName
      )
    );
    
    if (existsInAnyOriginal) {
      duplicates.push(mixedMember);
    }
  });
  
  return duplicates;
}

function displayMovie(movie, label, highlight = false) {
  const year = movie.year && movie.year !== 0 ? movie.year : (movie.releaseYear || 'Sin a√±o');
  const directorCount = getDirectorIds(movie.crew).length;
  
  const border = highlight ? '‚ñà' : '=';
  console.log(`\n${border.repeat(70)}`);
  console.log(`  ${label}`);
  console.log(`${border.repeat(70)}`);
  console.log(`  ID: ${movie.id}`);
  console.log(`  T√≠tulo: "${movie.title}"`);
  console.log(`  A√±o: ${year}`);
  console.log(`  Slug: ${movie.slug}`);
  console.log(`  Directores: ${directorCount} ${highlight ? '‚Üê M√ÅS DIRECTORES (MEZCLADA)' : ''}`);
  
  // Mostrar CREW
  const crew = Array.isArray(movie.crew) ? movie.crew : [];
  console.log(`\n  CREW (${crew.length} personas):`);
  
  if (crew.length === 0) {
    console.log(`    (sin crew)`);
  } else {
    const crewByRole = {};
    crew.forEach(member => {
      const roleName = member.role?.name || 'Sin rol';
      if (!crewByRole[roleName]) {
        crewByRole[roleName] = [];
      }
      crewByRole[roleName].push(getPersonName(member.person));
    });
    
    Object.entries(crewByRole).forEach(([role, people]) => {
      console.log(`    ${role}:`);
      people.forEach(person => {
        console.log(`      - ${person}`);
      });
    });
  }
  
  // Mostrar CAST
  const cast = Array.isArray(movie.cast) ? movie.cast : [];
  console.log(`\n  CAST (${cast.length} personas):`);
  
  if (cast.length === 0) {
    console.log(`    (sin cast)`);
  } else {
    cast.slice(0, 5).forEach(member => {
      const personName = getPersonName(member.person);
      const character = member.characterName ? ` como "${member.characterName}"` : '';
      console.log(`    - ${personName}${character}`);
    });
    if (cast.length > 5) {
      console.log(`    ... y ${cast.length - 5} m√°s`);
    }
  }
}

function displayDuplicates(crewDuplicates, castDuplicates) {
  // Validaci√≥n robusta
  const crew = Array.isArray(crewDuplicates) ? crewDuplicates : [];
  const cast = Array.isArray(castDuplicates) ? castDuplicates : [];
  const total = crew.length + cast.length;
  
  console.log(`\n${'‚îÄ'.repeat(70)}`);
  console.log(`  ‚ö†Ô∏è  DUPLICADOS A ELIMINAR (${total} personas):`);
  console.log(`${'‚îÄ'.repeat(70)}`);
  
  if (total === 0) {
    console.log(`  (ninguno)`);
    return;
  }
  
  // CREW
  if (crew.length > 0) {
    console.log(`\n  üé¨ CREW DUPLICADO (${crew.length}):`);
    
    const byRole = {};
    crew.forEach(member => {
      const roleName = member.role?.name || 'Sin rol';
      if (!byRole[roleName]) {
        byRole[roleName] = [];
      }
      byRole[roleName].push({
        name: getPersonName(member.person),
        id: member.id
      });
    });
    
    Object.entries(byRole).forEach(([role, people]) => {
      console.log(`    ${role}:`);
      people.forEach(person => {
        console.log(`      ‚ùå ${person.name} (ID: ${person.id})`);
      });
    });
  }
  
  // CAST
  if (cast.length > 0) {
    console.log(`\n  üé≠ CAST DUPLICADO (${cast.length}):`);
    
    cast.forEach(member => {
      const personName = getPersonName(member.person);
      const character = member.characterName ? ` como "${member.characterName}"` : '';
      console.log(`    ‚ùå ${personName}${character} (ID: ${member.id})`);
    });
  }
}

async function detectDuplicateGroups() {
  console.log('üîç Buscando pel√≠culas duplicadas...\n');

  try {
    const movies = await prisma.movie.findMany({
      select: {
        id: true,
        title: true,
        year: true,
        releaseYear: true,
        slug: true,
        crew: {
          select: {
            id: true,
            roleId: true,
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true
              }
            },
            role: {
              select: {
                id: true,
                name: true,
                department: true
              }
            }
          }
        },
        cast: {
          select: {
            id: true,
            characterName: true,
            person: {
              select: {
                id: true,
                firstName: true,
                lastName: true
              }
            }
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    });

    console.log(`üìä Total de pel√≠culas: ${movies.length}\n`);

    const titleGroups = new Map();
    
    movies.forEach(movie => {
      const normalizedTitle = normalizeTitle(movie.title);
      if (!titleGroups.has(normalizedTitle)) {
        titleGroups.set(normalizedTitle, []);
      }
      titleGroups.get(normalizedTitle).push(movie);
    });

    const duplicateGroups = [];

    titleGroups.forEach((movies) => {
      if (movies.length > 1) {
        const moviesWithSharedDirectors = [];
        
        for (let i = 0; i < movies.length; i++) {
          const movie1Directors = getDirectorIds(movies[i].crew);
          
          for (let j = i + 1; j < movies.length; j++) {
            const movie2Directors = getDirectorIds(movies[j].crew);
            
            if (shareDirectors(movie1Directors, movie2Directors)) {
              if (!moviesWithSharedDirectors.find(m => m.id === movies[i].id)) {
                moviesWithSharedDirectors.push(movies[i]);
              }
              if (!moviesWithSharedDirectors.find(m => m.id === movies[j].id)) {
                moviesWithSharedDirectors.push(movies[j]);
              }
            }
          }
        }
        
        if (moviesWithSharedDirectors.length >= 2) {
          const { mixed, originals } = identifyMixedAndOriginals(moviesWithSharedDirectors);
          const originalsCrews = originals.map(m => m.crew);
          const originalsCasts = originals.map(m => m.cast);
          const duplicateCrewMembers = findDuplicateCrewMembers(mixed.crew, originalsCrews);
          const duplicateCastMembers = findDuplicateCastMembers(mixed.cast, originalsCasts);
          
          if (duplicateCrewMembers.length > 0 || duplicateCastMembers.length > 0) {
            duplicateGroups.push({
              mixed,
              originals,
              duplicateCrewMembers,
              duplicateCastMembers,
              totalMovies: moviesWithSharedDirectors.length
            });
          }
        }
      }
    });

    console.log(`‚úÖ Se encontraron ${duplicateGroups.length} grupos de pel√≠culas con crew duplicado\n`);
    
    const groupsBySize = {};
    duplicateGroups.forEach(group => {
      const size = group.totalMovies;
      groupsBySize[size] = (groupsBySize[size] || 0) + 1;
    });
    
    console.log('üìä Distribuci√≥n de grupos:');
    Object.entries(groupsBySize).sort((a, b) => a[0] - b[0]).forEach(([size, count]) => {
      console.log(`   - ${size} pel√≠culas mezcladas: ${count} grupo(s)`);
    });
    console.log('');
    
    return duplicateGroups;

  } catch (error) {
    console.error('‚ùå Error al buscar duplicados:', error);
    throw error;
  }
}

async function processGroup(group, index, total) {
  console.log('\n\n');
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log(`‚ïë  GRUPO ${index + 1} DE ${total} (${group.totalMovies} pel√≠culas mezcladas)${' '.repeat(Math.max(0, 30 - group.totalMovies.toString().length))}‚ïë`);
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  
  displayMovie(group.mixed, '‚ö†Ô∏è  PEL√çCULA MEZCLADA (se limpiar√° el crew y cast duplicado)', true);
  
  group.originals.forEach((original, idx) => {
    displayMovie(original, `‚úÖ PEL√çCULA ORIGINAL #${idx + 1} (se mantendr√° intacta)`);
  });
  
  displayDuplicates(group.duplicateCrewMembers, group.duplicateCastMembers);
  
  const crewCount = Array.isArray(group.duplicateCrewMembers) ? group.duplicateCrewMembers.length : 0;
  const castCount = Array.isArray(group.duplicateCastMembers) ? group.duplicateCastMembers.length : 0;
  
  console.log('\n');
  console.log(`${'‚ïê'.repeat(70)}`);
  console.log(`\nResumen:`);
  console.log(`  - Pel√≠culas originales: ${group.originals.length}`);
  console.log(`  - Pel√≠cula mezclada: 1 (ID: ${group.mixed.id})`);
  console.log(`  - Crew duplicado a eliminar: ${crewCount} personas`);
  console.log(`  - Cast duplicado a eliminar: ${castCount} personas`);
  console.log(`  - TOTAL a eliminar: ${crewCount + castCount} registros`);
  
  const answer = await question('\n¬øDeseas ELIMINAR los duplicados de esta pel√≠cula? (s/n/q para salir): ');
  
  if (answer.toLowerCase() === 'q') {
    console.log('\n‚ùå Proceso cancelado por el usuario.\n');
    return 'quit';
  }
  
  if (answer.toLowerCase() === 's' || answer.toLowerCase() === 'y') {
    try {
      let crewDeleted = 0;
      let castDeleted = 0;
      
      if (crewCount > 0) {
        const crewIds = group.duplicateCrewMembers.map(m => m.id);
        const crewResult = await prisma.movieCrew.deleteMany({
          where: { id: { in: crewIds } }
        });
        crewDeleted = crewResult.count;
      }
      
      if (castCount > 0) {
        const castIds = group.duplicateCastMembers.map(m => m.id);
        const castResult = await prisma.movieCast.deleteMany({
          where: { id: { in: castIds } }
        });
        castDeleted = castResult.count;
      }
      
      console.log(`\n‚úÖ Eliminados ${crewDeleted} crew + ${castDeleted} cast = ${crewDeleted + castDeleted} registros totales.\n`);
      return { status: 'cleaned', crewDeleted, castDeleted };
    } catch (error) {
      console.error(`\n‚ùå Error al eliminar:`, error.message);
      return { status: 'error', crewDeleted: 0, castDeleted: 0 };
    }
  } else {
    console.log('\n‚è≠Ô∏è  Saltando este grupo...\n');
    return { status: 'skipped', crewDeleted: 0, castDeleted: 0 };
  }
}

async function main() {
  console.log('\n');
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë                                                                   ‚ïë');
  console.log('‚ïë         LIMPIADOR AUTOM√ÅTICO DE PEL√çCULAS DUPLICADAS             ‚ïë');
  console.log('‚ïë              (Maneja 2, 3 o m√°s pel√≠culas mezcladas)             ‚ïë');
  console.log('‚ïë                                                                   ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('\n');
  console.log('Este script detecta pel√≠culas mezcladas (con directores de m√∫ltiples');
  console.log('pel√≠culas) y limpia autom√°ticamente el crew y cast duplicado.\n');
  console.log('La pel√≠cula con M√ÅS directores se considera la mezclada y se limpia.\n');

  try {
    const duplicateGroups = await detectDuplicateGroups();
    
    if (duplicateGroups.length === 0) {
      console.log('üéâ No se encontraron pel√≠culas con crew o cast duplicado para limpiar.\n');
      rl.close();
      return;
    }
    
    console.log(`‚ö†Ô∏è  Se encontraron ${duplicateGroups.length} grupos de pel√≠culas para limpiar.\n`);
    const answer = await question('¬øDeseas proceder con la limpieza autom√°tica de TODOS los grupos? (s/n): ');
    
    if (answer.toLowerCase() !== 's' && answer.toLowerCase() !== 'y') {
      console.log('\n‚ùå Proceso cancelado por el usuario.\n');
      rl.close();
      return;
    }
    
    console.log('\nüöÄ Iniciando limpieza autom√°tica...\n');
    
    let cleaned = 0;
    let errors = 0;
    let totalCrewDeleted = 0;
    let totalCastDeleted = 0;
    
    for (let i = 0; i < duplicateGroups.length; i++) {
      const group = duplicateGroups[i];
      const crewCount = Array.isArray(group.duplicateCrewMembers) ? group.duplicateCrewMembers.length : 0;
      const castCount = Array.isArray(group.duplicateCastMembers) ? group.duplicateCastMembers.length : 0;
      
      console.log(`[${i + 1}/${duplicateGroups.length}] Procesando: "${group.mixed.title}"`);
      console.log(`   - Pel√≠cula mezclada: ID ${group.mixed.id} (${group.mixed.slug})`);
      console.log(`   - Pel√≠culas originales: ${group.originals.length}`);
      console.log(`   - Crew duplicado: ${crewCount} | Cast duplicado: ${castCount}`);
      
      try {
        let crewDeleted = 0;
        let castDeleted = 0;
        
        if (crewCount > 0) {
          const crewIds = group.duplicateCrewMembers.map(m => m.id);
          const crewResult = await prisma.movieCrew.deleteMany({
            where: { id: { in: crewIds } }
          });
          crewDeleted = crewResult.count;
        }
        
        if (castCount > 0) {
          const castIds = group.duplicateCastMembers.map(m => m.id);
          const castResult = await prisma.movieCast.deleteMany({
            where: { id: { in: castIds } }
          });
          castDeleted = castResult.count;
        }
        
        console.log(`   ‚úÖ Eliminados: ${crewDeleted} crew + ${castDeleted} cast = ${crewDeleted + castDeleted} registros\n`);
        cleaned++;
        totalCrewDeleted += crewDeleted;
        totalCastDeleted += castDeleted;
        
      } catch (error) {
        console.error(`   ‚ùå Error: ${error.message}\n`);
        errors++;
      }
    }
    
    console.log('\n');
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                      RESUMEN FINAL                                ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    console.log(`\n  Total de grupos encontrados: ${duplicateGroups.length}`);
    console.log(`  ‚úÖ Grupos limpiados: ${cleaned}`);
    console.log(`  ‚ùå Errores: ${errors}`);
    console.log(`  üóëÔ∏è  Total eliminado:`);
    console.log(`      - Crew duplicado: ${totalCrewDeleted} registros`);
    console.log(`      - Cast duplicado: ${totalCastDeleted} registros`);
    console.log(`      - TOTAL: ${totalCrewDeleted + totalCastDeleted} registros`);
    console.log('\n‚ú® Proceso completado.\n');

  } catch (error) {
    console.error('\n‚ùå Error en el proceso:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
    rl.close();
  }
}

main();